

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="End0rph1n">
  <meta name="keywords" content="">
  
    <meta name="description" content="前置知识csapp 3e 第6章 Part A: Writing a Cache SimulatorIn Part A you will write a cache simulator in csim.c that takes a valgrind memory trace as input, simulates the hit&#x2F;miss behavior of a cache memo">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp cash_lab">
<meta property="og:url" content="http://htwzxwj.github.io/2023/11/17/csapp-cash-lab/index.html">
<meta property="og:site_name" content="End0rph1n&#39;s  blog">
<meta property="og:description" content="前置知识csapp 3e 第6章 Part A: Writing a Cache SimulatorIn Part A you will write a cache simulator in csim.c that takes a valgrind memory trace as input, simulates the hit&#x2F;miss behavior of a cache memo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171058687.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171122572.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171809124.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171842802.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171853615.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171855951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171905736.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171910654.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171914483.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171938540.png">
<meta property="article:published_time" content="2023-11-17T02:37:08.000Z">
<meta property="article:modified_time" content="2023-11-17T11:42:23.494Z">
<meta property="article:author" content="End0rph1n">
<meta property="article:tag" content="cache">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171058687.png">
  
  
  
  <title>csapp cash_lab - End0rph1n&#39;s  blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"htwzxwj.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Running up that hill</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/4.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="csapp cash_lab"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-17 10:37" pubdate>
          2023年11月17日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          85 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">csapp cash_lab</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>csapp 3e 第6章</p>
<h2 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h2><p>In Part A you will write a cache simulator in <code>csim.c</code> that takes a <code>valgrind</code> memory trace as input, simulates the hit&#x2F;miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions.</p>
<p>要求编写cache模拟器，模拟cache在这个trace的hit&#x2F;miss表现，并输出hit miss evictions的总数</p>
<p>lab给出了可供参考的cache模拟器，其有以下六个参数</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">Usage: ./csim-ref [-hv] -s <span class="hljs-symbol">&lt;s&gt;</span> -E <span class="hljs-symbol">&lt;E&gt;</span> -<span class="hljs-keyword">b</span> <span class="hljs-symbol">&lt;b&gt;</span> -t <span class="hljs-symbol">&lt;tracefile&gt;</span><br>• -h: Optional <span class="hljs-keyword">help</span> flag that prints usage info<br>• -v: Optional <span class="hljs-keyword">verbose</span> flag that displays trace info<br>• -s <span class="hljs-symbol">&lt;s&gt;</span>: Number of <span class="hljs-keyword">set</span> <span class="hljs-built_in">index</span> bits (S = <span class="hljs-number">2</span>^s <span class="hljs-keyword">is</span> the <span class="hljs-keyword">number</span> of sets)<br>• -E <span class="hljs-symbol">&lt;E&gt;</span>: Associativity (<span class="hljs-keyword">number</span> of lines per <span class="hljs-keyword">set</span>)<br>• -<span class="hljs-keyword">b</span> <span class="hljs-symbol">&lt;b&gt;</span>: Number of block bits (B = <span class="hljs-number">2</span>^<span class="hljs-keyword">b</span> <span class="hljs-keyword">is</span> the block size)<br>• -t <span class="hljs-symbol">&lt;tracefile&gt;</span>: Name of the valgrind trace <span class="hljs-keyword">to</span> replay<br></code></pre></td></tr></table></figure>

<p>trace文件夹包含了用于评估模拟器的trace文件，其使用<code>valgrind</code>生成</p>
<p>trace文件中具体定义为</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span> <span class="hljs-number">0400</span>d7d4,<span class="hljs-number">8</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">0421</span>c7f0,<span class="hljs-number">4</span><br><span class="hljs-attribute">L</span> <span class="hljs-number">04</span>f6b868,<span class="hljs-number">8</span><br><span class="hljs-attribute">S</span> <span class="hljs-number">7</span>ff0005c8,<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<p>其具体格式为</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[space]</span>operation <span class="hljs-selector-tag">address</span>,size<br></code></pre></td></tr></table></figure>

<p>The operation field denotes the type of memory access: “I” denotes an instruction load, “L” a data load, “S” a data store, and “M” a data modify (i.e., a data load followed by a data store). There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address field specifies a 64-bit hexadecimal memory address. The size field specifies the number of bytes accessed by the operation.</p>
<p>4种operation</p>
<ul>
<li><code>I</code> 表示加载指令  其之前不加[space]</li>
<li><code>L</code>表示加载数据</li>
<li><code>S</code>表示存储数据</li>
<li><code>M</code>表示修改数据</li>
</ul>
<h3 id="回顾cache结构"><a href="#回顾cache结构" class="headerlink" title="回顾cache结构"></a>回顾cache结构</h3><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171058687.png" srcset="/img/loading.gif" lazyload alt="cache"></p>
<p>Cache 类似于一个二维数组，它有 S&#x3D;2^s 组，每组有 E 行，每行存储的字节也是固定的。其中，每行都有一个有效位，和一个标记位。想要查找到对应的字节，我们的地址需要三部分组成：</p>
<ul>
<li>s，索引位，找到对应的组序号</li>
<li>tag，标记位，在组中的每一行进行匹配，判断能否命中</li>
<li>b，块偏移，表明在找到的行中的具体位置。本实验不考虑块偏移，完全可以忽略。</li>
</ul>
<p>那么，Cache 中的有效位是干什么的呢？判断该行是否为空。这里有一个概念：<strong>冷不命中</strong>，表示该缓存块为空造成的不命中。而一旦确定不命中不是冷不命中，那么就需要考虑行替换的问题了。我认为，行替换关乎着 Cache 的效率，是 Cache 设计的核心。</p>
<h3 id="回顾替换策略"><a href="#回顾替换策略" class="headerlink" title="回顾替换策略"></a>回顾替换策略</h3><p>当 CPU 要处理的字不在组中任何一行，且组中没有一个空行，那就必须从里面选取一个非空行进行替换。选取哪个空行进行替换呢？书上给了我们两种策略：</p>
<ul>
<li>LFU，最不常使用策略。替换在过去某个窗口时间内引用次数最少的那一行</li>
<li>LRU，最近最少使用策略。替换最后一次访问时间最久远的哪一行</li>
</ul>
<p>本实验要求采取的策略为 <strong>LRU</strong>。</p>
<p>下面正式开始Part A。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> S;<br>    <span class="hljs-type">int</span> E;<br>    <span class="hljs-type">int</span> B;<br>    Cache_line **line;<br>&#125; Cache;<br></code></pre></td></tr></table></figure>

<p>用<code>Cache</code>来表示一个缓存，其包括S，B，E等特征，每一个缓存类似于一个二维数组，数组的每一个元素就是缓存中的一个行，数组的每一个元素就是缓存中的行，所以用<code>line</code>来表示这一类信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> valid;     <span class="hljs-comment">//有效位</span><br>    <span class="hljs-type">int</span> tag;       <span class="hljs-comment">//标记位</span><br>    <span class="hljs-type">int</span> time_tamp; <span class="hljs-comment">//时间戳</span><br>&#125; Cache_line;<br></code></pre></td></tr></table></figure>

<p>valid和tag不赘述，time_tamp是LRU算法用到的特征。</p>
<p>Cache的初始化如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Init_Cache</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-type">int</span> S = <span class="hljs-number">1</span> &lt;&lt; s;<br>    <span class="hljs-type">int</span> B = <span class="hljs-number">1</span> &lt;&lt; b;<br>    cache = (Cache *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache));<br>    cache-&gt;S = S;<br>    cache-&gt;E = E;<br>    cache-&gt;B = B;<br>    cache-&gt;line = (Cache_line **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache_line *) * S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++)<br>    &#123;<br>        cache-&gt;line[i] = (Cache_line *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache_line) * E);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; E; j++)<br>        &#123;<br>            cache-&gt;line[i][j].valid = <span class="hljs-number">0</span>; <br>            cache-&gt;line[i][j].tag = <span class="hljs-number">-1</span>;<br>            cache-&gt;line[i][j].time_tamp = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间戳的初始设置为0</p>
<h3 id="LRU时间戳实现"><a href="#LRU时间戳实现" class="headerlink" title="LRU时间戳实现"></a>LRU时间戳实现</h3><p>时间戳越大则表示该行最后访问的时间越久远，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> op_s, <span class="hljs-type">int</span> op_tag)</span>&#123;<br>    cache-&gt;line[op_s][i].valid=<span class="hljs-number">1</span>;<br>    cache-&gt;line[op_s][i].tag = op_tag;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cache-&gt;E; k++)<br>        <span class="hljs-keyword">if</span>(cache-&gt;line[op_s][k].valid==<span class="hljs-number">1</span>)<br>            cache-&gt;line[op_s][k].time_tamp++;<br>    cache-&gt;line[op_s][i].time_tamp = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码在找到要进行的操作行后调用（无论是不命中还是命中，还是驱逐后）。前两行是对有效位和标志位的设置，与时间戳无关，主要关注后几行：</p>
<ul>
<li>遍历组中每一行，并将它们的值加1，也就是说每一行在进行一次操作后时间戳都会变大，表示它离最后操作的时间变久</li>
<li>将本次操作的行时间戳设置为最小，也就是0</li>
</ul>
<p>由此，每次只需要找到时间戳最大的行进行替换就可以了：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int find_LRU(int op_s)<br>&#123;<br>    int max_index <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    int max_stamp <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    for(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; cache-&gt;E; i++)&#123;</span><br>        if(cache-&gt;line[op_s][i].time_tamp &gt; max_stamp)&#123;<br>            max_stamp <span class="hljs-operator">=</span> cache-&gt;line[op_s][i].time_tamp<span class="hljs-comment">;</span><br>            max_index <span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    return max_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="缓存搜索与更新"><a href="#缓存搜索与更新" class="headerlink" title="缓存搜索与更新"></a>缓存搜索与更新</h3><p>先解决比较核心的问题，在得知要操作的组<code>op_s</code>以及标志位<code>op_tag</code>后，判断是<code>miss</code>还是<code>hit</code>还是应该<code>eviction</code>调用<code>find_LRU</code>。</p>
<p>先判断是<code>miss</code>还是<code>hit</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">get_index</span><span class="hljs-params">(<span class="hljs-type">int</span> op_s, <span class="hljs-type">int</span> op_tag)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cache-&gt;E; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cache-&gt;line[op_s][i].valid &amp;&amp; cache-&gt;line[op_s][i].tag == op_tag)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>遍历所有行，如果某一行有效，且标志位相同，则<code>hit</code>，返回该索引。否则，<code>miss</code>，返回 -1。当接收到-1后，有两种情况：</p>
<ul>
<li>冷不命中。组中有空行，只不过还未操作过，有效位为0，找到这个空行即可</li>
<li>所有行都满了。那么就要用到上面得 LRU 进行选择驱逐</li>
</ul>
<p>所以，设计一个判满的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_full</span><span class="hljs-params">(<span class="hljs-type">int</span> op_s)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cache-&gt;E; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cache-&gt;line[op_s][i].valid == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>扫描完成后，得到对应行的索引值，就可以调用 LRU 更新函数进行更新了。整体调用如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void update<span class="hljs-constructor">_info(<span class="hljs-params">int</span> <span class="hljs-params">op_tag</span>, <span class="hljs-params">int</span> <span class="hljs-params">op_s</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index = get<span class="hljs-constructor">_index(<span class="hljs-params">op_s</span>, <span class="hljs-params">op_tag</span>)</span>;<br>    <span class="hljs-keyword">if</span> (index<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)<br>    &#123;<br>        miss_count++;<br>        <span class="hljs-keyword">if</span> (verbose)<br>            printf(<span class="hljs-string">&quot;miss &quot;</span>);<br>        <span class="hljs-built_in">int</span> i = is<span class="hljs-constructor">_full(<span class="hljs-params">op_s</span>)</span>;<br>        <span class="hljs-keyword">if</span>(i==-<span class="hljs-number">1</span>)&#123;<br>            eviction_count++;<br>            <span class="hljs-keyword">if</span>(verbose) printf(<span class="hljs-string">&quot;eviction&quot;</span>);<br>            i = find<span class="hljs-constructor">_LRU(<span class="hljs-params">op_s</span>)</span>;<br>        &#125;<br>        update(i,op_s,op_tag);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        hit_count++;<br>        <span class="hljs-keyword">if</span>(verbose)<br>            printf(<span class="hljs-string">&quot;hit&quot;</span>);<br>        update(index,op_s,op_tag);    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>核心函数已完成</p>
<h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><p>设计的数据结构解决了对 Cache 的操作问题，LRU 时间戳的实现解决了核心的驱逐问题，缓存扫描解决了对块中哪一列进行操作的问题，而应该对哪一块进行操作呢？接下来要解决的就是指令的解析问题了。</p>
<p>输入数据为<code>[space]operation address, size</code>的形式，<code>operation</code>很容易获取，重要的是从<code>address</code>中分别获取我们需要的<code>s</code>和<code>tag</code>，<code>address</code>结构如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171122572.png" srcset="/img/loading.gif" lazyload alt="address结构"></p>
<p>这边用到了位移运算，右移（b+s）位即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> op_tag = address &gt;&gt; (s + b);<br></code></pre></td></tr></table></figure>

<p>获取 s，考虑先右移 b 位，再用无符号 0xFF… 右移后进行与操作将 tag 抹去。为什么要用无符号 0xFF… 右移呢？因为C语言中的右移为算术右移，有符号数右移补位的数为符号位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="hljs-type">unsigned</span>)(<span class="hljs-number">-1</span>) &gt;&gt; (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>) - s));<br></code></pre></td></tr></table></figure>

<p>由于数据读写对于本模拟器而言没有区别，因此不同的指令对应的只是cache更新次数的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_trace</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    FILE *pFile;<br>    pFile = fopen(t, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> identifier;<br>    <span class="hljs-type">unsigned</span> address;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">// Reading lines like &quot; M 20,1&quot; or &quot;L 19,3&quot;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(pFile, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// I读不进来,忽略---size没啥用</span><br>    &#123;<br>        <span class="hljs-comment">//想办法先得到标记位和组序号</span><br>        <span class="hljs-type">int</span> op_tag = address &gt;&gt; (s + b);<br>        <span class="hljs-type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="hljs-type">unsigned</span>)(<span class="hljs-number">-1</span>) &gt;&gt; (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>) - s));<br>        <span class="hljs-keyword">switch</span> (identifier)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-comment">//一次存储一次加载</span><br>            update_info(op_tag, op_s);<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    fclose(pFile);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>update_info</code>就是对 Cache 进行更新的函数。如果指令是<code>M</code>则一次存储一次加载，总共更新两次，其他指令只用更新一次，而<code>I</code>无需考虑。</p>
<h3 id="命令行获取参数"><a href="#命令行获取参数" class="headerlink" title="命令行获取参数"></a>命令行获取参数</h3><p>通过阅读<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementation and Blocking</a>的提示，我们使用<code>getopt()</code>函数来获取命令行参数的字符串形式，然后用<code>atoi()</code>转换为要用的参数，最后用<code>switch</code>语句跳转到对应功能块。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> opt;<br>    <span class="hljs-type">int</span> s, E, b;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * s:S=2^s是组的个数</span><br><span class="hljs-comment">     * E:每组中有多少行</span><br><span class="hljs-comment">     * b:B=2^b每个缓冲块的字节数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">-1</span> != (opt = getopt(argc, argv, <span class="hljs-string">&quot;hvs:E:b:t:&quot;</span>)))<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (opt)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>            print_help();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>            verbose = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            s = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>            E = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            b = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">strcpy</span>(t, optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            print_help();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    Init_Cache(s, E, b); <span class="hljs-comment">//初始化一个cache</span><br>    get_trace(s, E, b);<br>    free_Cache();<br>    <span class="hljs-comment">// printSummary(hit_count, miss_count, eviction_count)</span><br>    printSummary(hit_count, miss_count, eviction_count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171809124.png" srcset="/img/loading.gif" lazyload alt="模拟结果"></p>
<h2 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h2><p>In Part B you will write a transpose function in trans.c that causes as few cache misses as possible.</p>
<p>要求本地变量最多定义12个</p>
<ul>
<li>32 × 32: 8 points if m &lt; 300, 0 points if m &gt; 600</li>
<li>64 × 64: 8 points if m &lt; 1, 300, 0 points if m &gt; 2, 000</li>
<li>61 × 67: 10 points if m &lt; 2, 000, 0 points if m &gt; 3, 000</li>
</ul>
<p>s &#x3D; 5, E &#x3D; 1, b &#x3D; 5，缓存有32组，每组一行，一行存8个int</p>
<h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32"></a>32*32</h4><p>根据pdf的提示，这里肯定要使用矩阵<strong>分块</strong>进行优化</p>
<p>首先考虑最最简单的转置情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trans_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-type">int</span> tmp = A[i][j];<br>            B[j][i] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以第1行为例，在从内存读 <code>A[0][0]</code> 的时候，除了 <code>A[0][0]</code> 被加载到缓存中，它之后的 <code>A[0][1]---A[0][7]</code> 也会被加载进缓存。</p>
<p>但是内容写入 <code>B</code> 矩阵的时候是一列一列地写入，在列上相邻的元素不在一个内存块上，这样每次写入都不命中缓存。并且一列写完之后再返回，原来的缓存可能被覆盖了，这样就又会不命中，我们来定量分析。</p>
<p>缓存只够存储一个矩阵的四分之一，<code>A</code>中的元素对应的缓存行每隔8行就会重复。<code>A</code>和<code>B</code>的地址由于取余关系，每个元素对应的地址是相同的</p>
<p>对于<code>A</code>，每8个<code>int</code>就会占满缓存的一组，所以每一行会有 32&#x2F;8 &#x3D; 4 次不命中；而对于<code>B</code>，考虑最坏情况，每一列都有 32 次不命中，由此，算出总不命中次数为 4 × 32 + 32 × 32 &#x3D; 1152。拿程序跑一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171842802.png" srcset="/img/loading.gif" lazyload alt="最简单转置测试"></p>
<p>结果是1183，这是对角线部分两者冲突造成的</p>
<table>
<thead>
<tr>
<th>D</th>
<th>D</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在写入<code>B</code>的前 8 行后，<code>B</code>的<code>D</code>区域就全部进入了缓存，此时如果能对<code>D</code>进行操作，那么就能利用上缓存的内容，不会<code>miss</code>；但是，暴力解法接下来操作的是<code>C</code>，每一个元素的写都要驱逐之前的缓存区，当来到第 2 列继续写<code>D</code>时，它对应的缓存行很可能已经被驱逐了，于是又要<code>miss</code>，也就是说，暴力解法的问题在于没有充分利用上已经进入缓存的元素</p>
<p>分块解决的就是同一个矩阵内部缓存块相互替换的问题。</p>
<p>由上述分析，显然应考虑 8 × 8 分块，这样在块的内部不会冲突，接下来判断<code>A</code>与<code>B</code>之间会不会冲突</p>
<p><code>A</code>中块占用的是缓存的第 0，4，8，12，16，20，24，28组，而<code>B</code>中块占用的是缓存的第2，6，10，14，18，16，30组，刚好不会冲突。事实上，<strong>除了对角线</strong>，<code>A</code>与<code>B</code>中对应的块都不会冲突。所以，我们的想法是可行的，写出代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">8</span>; k++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; <span class="hljs-number">8</span>; s++)<br>                    B[j + s][i + k] = A[i + k][j + s];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于<code>A</code>中每一个操作块，只有每一行的第一个元素会不命中，所以为8次不命中；对于<code>B</code>中每一个操作块，只有每一列的第一个元素会不命中，所以也为 8 次不命中。总共<code>miss</code>次数为：8 × 16 × 2 &#x3D; 256</p>
<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171853615.png" srcset="/img/loading.gif" lazyload alt="第二次测试"></p>
<p>以<code>A</code>的一个对角线块<code>p</code>，<code>B</code>与<code>p</code>相应的对角线块<code>q</code>为例，复制前， <code>p</code> 在缓存中。 复制时，<code>q</code>会驱逐<code>p</code>。 下一个开始复制 <code>p</code> 又被重新加载进入缓存驱逐 <code>q</code>，这样就会多产生两次<code>miss</code>。</p>
<p>如何解决这种问题呢？题目给了我们提示：</p>
<blockquote>
<p>You are allowed to define at most 12 local variables of type int per transpose function</p>
</blockquote>
<p>考虑使用 8 个本地变量一次性存下 <code>A</code> 的一行后，再复制给 <code>B</code>，代码如下：</p>
<p>对于非对角线上的块，本身就没有额外的冲突；对于对角线上的块，写入<code>A</code>每一行的第一个元素后，这一行的元素都进入了缓存，我们就立即用本地变量存下这 8 个元素，随后再复制给<code>B</code>。这样，就避免了第一个元素复制时，<code>B</code>把<code>A</code>的缓冲行驱逐，导致没有利用上<code>A</code>的缓冲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j += <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; i + <span class="hljs-number">8</span>; k++)<br>            &#123;<br>                <span class="hljs-type">int</span> a_0 = A[k][j];<br>                <span class="hljs-type">int</span> a_1 = A[k][j+<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> a_2 = A[k][j+<span class="hljs-number">2</span>];<br>                <span class="hljs-type">int</span> a_3 = A[k][j+<span class="hljs-number">3</span>];<br>                <span class="hljs-type">int</span> a_4 = A[k][j+<span class="hljs-number">4</span>];<br>                <span class="hljs-type">int</span> a_5 = A[k][j+<span class="hljs-number">5</span>];<br>                <span class="hljs-type">int</span> a_6 = A[k][j+<span class="hljs-number">6</span>];<br>                <span class="hljs-type">int</span> a_7 = A[k][j+<span class="hljs-number">7</span>];<br>                B[j][k] = a_0;<br>                B[j+<span class="hljs-number">1</span>][k] = a_1;<br>                B[j+<span class="hljs-number">2</span>][k] = a_2;<br>                B[j+<span class="hljs-number">3</span>][k] = a_3;<br>                B[j+<span class="hljs-number">4</span>][k] = a_4;<br>                B[j+<span class="hljs-number">5</span>][k] = a_5;<br>                B[j+<span class="hljs-number">6</span>][k] = a_6;<br>                B[j+<span class="hljs-number">7</span>][k] = a_7;<br>            &#125;         <br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171855951.png" srcset="/img/loading.gif" lazyload alt="第三次测试"></p>
<h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64"></a>64*64</h4><p>每4行就会占满一行缓存，先考虑先考虑 4 × 4 分块，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171905736.png" srcset="/img/loading.gif" lazyload alt="64*64第一次测试"></p>
<p>还是考虑 8 × 8 分块，由于存在着每 4 行就会占满一个缓存的问题，在分块内部处理时就需要技巧了，我们把分块内部分成 4 个 4 × 4 的小分块分别处理：</p>
<ul>
<li>第一步，将<code>A</code>的左上和右上一次性复制给<code>B</code></li>
<li>第二步，用本地变量把<code>B</code>的右上角存储下来</li>
<li>第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li>
<li>第四步，利用第二步存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li>
<li>第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void transpose_64x64(int M, int N, int A<span class="hljs-comment">[N]</span><span class="hljs-comment">[M]</span>, int B<span class="hljs-comment">[M]</span><span class="hljs-comment">[N]</span>)<br>&#123;<br>    int a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7;<br>    for (int i = 0; i &lt; 64; i += 8)&#123;<br>        for (int j = 0; j &lt; 64; j += 8)&#123;<br>            for (int k = i; k &lt; i + 4; k++)&#123;<br>                // 得到A的第1,2块<br>                a_0 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 0]</span>;<br>                a_1 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 1]</span>;<br>                a_2 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 2]</span>;<br>                a_3 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 3]</span>;<br>                a_4 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 4]</span>;<br>                a_5 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 5]</span>;<br>                a_6 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 6]</span>;<br>                a_7 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 7]</span>;<br>                // 复制给B的第1,2块<br>                B<span class="hljs-comment">[j + 0]</span><span class="hljs-comment">[k]</span> = a_0;<br>                B<span class="hljs-comment">[j + 1]</span><span class="hljs-comment">[k]</span> = a_1;<br>                B<span class="hljs-comment">[j + 2]</span><span class="hljs-comment">[k]</span> = a_2;<br>                B<span class="hljs-comment">[j + 3]</span><span class="hljs-comment">[k]</span> = a_3;<br>                B<span class="hljs-comment">[j + 0]</span><span class="hljs-comment">[k + 4]</span> = a_4;<br>                B<span class="hljs-comment">[j + 1]</span><span class="hljs-comment">[k + 4]</span> = a_5;<br>                B<span class="hljs-comment">[j + 2]</span><span class="hljs-comment">[k + 4]</span> = a_6;<br>                B<span class="hljs-comment">[j + 3]</span><span class="hljs-comment">[k + 4]</span> = a_7;<br>            &#125;<br>            for (int k = j; k &lt; j + 4; k++)&#123;<br>                // 得到B的第2块<br>                a_0 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 4]</span>;<br>                a_1 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 5]</span>;<br>                a_2 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 6]</span>;<br>                a_3 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 7]</span>;<br>                // 得到A的第3块<br>                a_4 = A<span class="hljs-comment">[i + 4]</span><span class="hljs-comment">[k]</span>;<br>                a_5 = A<span class="hljs-comment">[i + 5]</span><span class="hljs-comment">[k]</span>;<br>                a_6 = A<span class="hljs-comment">[i + 6]</span><span class="hljs-comment">[k]</span>;<br>                a_7 = A<span class="hljs-comment">[i + 7]</span><span class="hljs-comment">[k]</span>;<br>                // 复制给B的第2块<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 4]</span> = a_4;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 5]</span> = a_5;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 6]</span> = a_6;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 7]</span> = a_7;<br>                // B原来的第2块移动到第3块<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 0]</span> = a_0;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 1]</span> = a_1;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 2]</span> = a_2;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 3]</span> = a_3;<br>            &#125;<br>            for (int k = i + 4; k &lt; i + 8; k++)<br>            &#123;<br>                // 处理第4块<br>                a_4 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 4]</span>;<br>                a_5 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 5]</span>;<br>                a_6 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 6]</span>;<br>                a_7 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 7]</span>;<br>                B<span class="hljs-comment">[j + 4]</span><span class="hljs-comment">[k]</span> = a_4;<br>                B<span class="hljs-comment">[j + 5]</span><span class="hljs-comment">[k]</span> = a_5;<br>                B<span class="hljs-comment">[j + 6]</span><span class="hljs-comment">[k]</span> = a_6;<br>                B<span class="hljs-comment">[j + 7]</span><span class="hljs-comment">[k]</span> = a_7;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171910654.png" srcset="/img/loading.gif" lazyload alt="64*64第二次测试"></p>
<h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67"></a>61*67</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">void transpose_61x67(<span class="hljs-built_in">int</span> M, <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>, <span class="hljs-built_in">int</span> A[<span class="hljs-built_in">N</span>][M], <span class="hljs-built_in">int</span> B[M][<span class="hljs-built_in">N</span>])&#123;<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">N</span>; i += <span class="hljs-number">16</span>)<br>        for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>            for (<span class="hljs-built_in">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; <span class="hljs-built_in">N</span>; k++)<br>                for (<span class="hljs-built_in">int</span> s = j; s &lt; j + <span class="hljs-number">16</span> &amp;&amp; s &lt; M; s++)<br>                    B[s][k] = A[k][s];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171914483.png" srcset="/img/loading.gif" lazyload alt="61*67测试"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171938540.png" srcset="/img/loading.gif" lazyload alt="总成绩"></p>
<ul>
<li>太库鲁西了，太菜了做不出来，参考了许多大佬的代码，逻辑思维能力太差劲了</li>
<li>整个lab向我们展示了计算机缓存的美。个人感觉替换策略可以重新思考怎么优化；在看书就能意识到仅仅是代码上的不同就能带来性能上的巨大差距。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CSAPP/" class="category-chain-item">CSAPP</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cache/" class="print-no-link">#cache</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>csapp cash_lab</div>
      <div>http://htwzxwj.github.io/2023/11/17/csapp-cash-lab/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>End0rph1n</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/29/csapp-shlab/" title="csapp shlab">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">csapp shlab</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/10/csapp-arch-lab/" title="csapp arch_lab">
                        <span class="hidden-mobile">csapp arch_lab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
